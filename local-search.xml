<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>bug解决——hexo插件冲突导致tocbot生成目录跳转异常</title>
    <link href="/xiaohei07.github.io/2024/07/16/bug%E8%A7%A3%E5%86%B3%E2%80%94%E2%80%94hexo%E6%8F%92%E4%BB%B6%E5%86%B2%E7%AA%81%E5%AF%BC%E8%87%B4tocbot%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC%E5%BC%82%E5%B8%B8/"/>
    <url>/xiaohei07.github.io/2024/07/16/bug%E8%A7%A3%E5%86%B3%E2%80%94%E2%80%94hexo%E6%8F%92%E4%BB%B6%E5%86%B2%E7%AA%81%E5%AF%BC%E8%87%B4tocbot%E7%94%9F%E6%88%90%E7%9B%AE%E5%BD%95%E8%B7%B3%E8%BD%AC%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h3 id="问题说明"><a href="#问题说明" class="header-anchor">¶</a>问题说明</h3><p>在使用hexo部署博客时，使用了<a href="https://hexo.fluid-dev.com/">fluid主题</a>，该主题可以使用<a href="https://github.com/tscanlin/tocbot">tocbot</a>在右侧生成一个跳转的目录，如下：</p><p><img src="https://s21.ax1x.com/2024/07/16/pkIezKH.png" alt="image-20240716091527332"></p><p>为了使用更强的markdown渲染器，选择将hexo默认markdown渲染器的hexo-renderer-marked卸载，转而<strong>安装<a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a></strong>，该渲染器支持在**&lt;hi&gt;<strong>标签上</strong>自动生成标题锚点，并自动生成标题id**，该标题id即可用于tocbot自动扫描，并为右侧的目录生成跳转链接，保证右侧目录的正确跳转</p><p>但为了在文章正文中插入目录（一般是开头），需要其他的插件的支持，考虑到<a href="https://github.com/medfreeman/markdown-it-toc-and-anchor">markdown-it-toc-and-anchor</a>现在已不再维护，其使用的markdown-it版本太低，故添加插件<a href="https://github.com/bubkoo/hexo-toc"><strong>hexo-toc</strong></a>用于<strong>生成标题锚点和文章目录</strong>（标题锚点请在hexo-renderer-markdown-it和hexo-toc中二选一），该插件只需要在markdown文章中任意位置添加**&lt;div class=&quot;tocStart&quot;&gt;</p><!-- toc --><ul class="lvl-0"><li class="lvl-2"><p><a href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3">问题解决</a></p></li></ul><!-- tocstop --></div>**即可生成目录<p>但是，同时使用二者导致了一个特殊的bug，<strong>即右侧的tocbot目录的跳转只能回到文章页面的顶部，无法正确跳转到标题位置</strong>，通过浏览器的F12检查得知了其原因：</p><img src="https://s21.ax1x.com/2024/07/16/pkIm1iV.png" alt="image-20240716092938088" style="zoom: 80%;"><p><img src="https://s21.ax1x.com/2024/07/16/pkImwIx.png" alt="image-20240716092903108"></p><p>这里可以看到，&lt;h3&gt;目录并未像预期的那样生成id，而是添加了一个**&lt;span&gt;**标签，并在其中生成了标题id，这使得tocbot的扫描结果变成了如下的情况：</p><p><img src="https://s21.ax1x.com/2024/07/16/pkImGzF.png" alt="image-20240716093158727"></p><p>通过<strong>标题跳转的超链接标签&lt;a title&gt;中的href=“#”可知，tocbot生成的标题超链接只能回滚到页面顶部，无法跳转到指定的目录标题位置，而这正是因为标题id位于&lt;span&gt;标签，无法被tocbot获得所导致的</strong>，此时，只能通过tocbot中的标题锚点，即“¶”完成正确跳转</p><p><span id="correct_html"> </span><strong>如果需要tocbot正常工作，标题处的html结构和tocbot的html结构应如下</strong>：</p><img src="https://s21.ax1x.com/2024/07/16/pkImDJK.png" alt="image-20240716094617125" style="zoom:150%;"><p><img src="https://s21.ax1x.com/2024/07/16/pkIm6Qe.png" alt="image-20240716094654457"></p><p>观察可知，<strong>在&lt;h3&gt;标签中生成了标题的id，而不是在一个span标签中，进而tocbot在扫描后可以在自动目录中正确生成对应的href链接，指向该标题id，此时的点击应能正确跳转</strong></p><h3 id="问题解决"><a href="#问题解决" class="header-anchor">¶</a>问题解决</h3><p>在本人尝试了多种方法后，最终在github的issue区<a href="https://github.com/YenYuHsuan/hexo-theme-beantech/issues/11">Content's link show 'undefine' · Issue #11 · YenYuHsuan/hexo-theme-beantech (github.com)</a>中，看到了**<a href="https://github.com/fawks96">fawks96</a>**这位大佬的回复，并以此解决了问题：</p><p><img src="https://s21.ax1x.com/2024/07/16/pkImNL9.png" alt="image-20240716094108934"></p><p>这里的代码位于博客目录下的<strong>node_modules\hexo-toc\lib\filter.js</strong>文件内，打开后如下：</p><p><img src="https://s21.ax1x.com/2024/07/16/pkImdd1.png" alt="image-20240716094343221"></p><p>代码说明如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 为<span class="hljs-variable">$title</span>元素设置一个<span class="hljs-built_in">id</span>属性，属性值为变量<span class="hljs-built_in">id</span>的值。<br><span class="hljs-variable">$title</span>.attr(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-built_in">id</span>);<br><br>// 移除标题元素<span class="hljs-variable">$title</span>下的所有直接子元素中的&lt;a&gt;标签，即：如果标题元素<span class="hljs-variable">$title</span>的子元素中包含&lt;a&gt;标签，这些&lt;a&gt;标签会被从html结构中移除<br><span class="hljs-variable">$title</span>.children(<span class="hljs-string">&#x27;a&#x27;</span>).remove();<br>// 将标题元素<span class="hljs-variable">$title</span> 的HTML内容包裹在一个&lt;span&gt;元素内，并设置这个 &lt;span&gt; 元素的 <span class="hljs-built_in">id</span> 属性为变量<span class="hljs-built_in">id</span>的值<br><span class="hljs-variable">$title</span>.html( <span class="hljs-string">&#x27;&lt;span id=&quot;&#x27;</span> + <span class="hljs-built_in">id</span> + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span> + <span class="hljs-variable">$title</span>.html() + <span class="hljs-string">&#x27;&lt;/span&gt;&#x27;</span> );<br>// 移除标题元素<span class="hljs-variable">$title</span>上的<span class="hljs-built_in">id</span>属性<br><span class="hljs-variable">$title</span>.removeAttr(<span class="hljs-string">&#x27;id&#x27;</span>);<br></code></pre></td></tr></table></figure><p>从这里可以看出，<strong>hexo-toc在更新后直接移除了标题中的id和子元素中的超链接，改为添加&lt;span&gt;标签，这里没有考虑其他插件的工作过程和效果，因此最终导致了问题的发生</strong></p><p>解决方法也很简单，直接修改源码(回滚版本)，即可：</p><p><img src="https://s21.ax1x.com/2024/07/16/pkIMYfx.png" alt="image-20240716100825645"></p><p>重新部署，可以看到其效果如<a href="#correct_html">上面的正确结构</a>所示，且所有跳转均恢复正常</p><p>最后，附上我个人Blog中的**_config.yml<strong>的</strong>hexo-renderer-markdown-it<strong>和</strong>hexo-toc**配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># hexo-toc config—— by &lt;!-- toc --&gt; to insert toc</span><br><span class="hljs-attr">toc:</span><br>  <span class="hljs-attr">maxdepth:</span> <span class="hljs-number">6</span><br>  <span class="hljs-attr">class:</span> <span class="hljs-string">toc</span><br>  <span class="hljs-attr">slugify:</span> <span class="hljs-string">usluq</span><br>  <span class="hljs-attr">decodeEntities:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">anchor:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">before</span><br>    <span class="hljs-attr">symbol:</span> <span class="hljs-string">&#x27;¶&#x27;</span><br>    <span class="hljs-attr">style:</span> <span class="hljs-string">header-anchor</span><br><br><span class="hljs-comment"># Markdown renderer config —— using hexo-renderer-markdown-it-plus</span><br><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">preset:</span> <span class="hljs-string">&quot;default&quot;</span><br>  <span class="hljs-attr">render:</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">xhtmlOut:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">langPrefix:</span> <span class="hljs-string">&quot;language-&quot;</span><br>    <span class="hljs-attr">breaks:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">linkify:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">typographer:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">quotes:</span> <span class="hljs-string">&#x27;“”‘’&#x27;</span><br>  <span class="hljs-attr">enable_rules:</span><br>  <span class="hljs-attr">disable_rules:</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-emoji</span>     <span class="hljs-comment"># 表情</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-footnote</span>  <span class="hljs-comment"># 脚注(参考文献)</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-abbr</span>      <span class="hljs-comment"># 支持&lt;abbr&gt;标签缩写</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-cjk-breaks</span>  <span class="hljs-comment"># 移除不符合规范的单换行</span><br>    <span class="hljs-comment"># - markdown-it-deflist   # 支持将markdown定义列表</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sup</span>       <span class="hljs-comment"># 上标</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-sub</span>       <span class="hljs-comment"># 下标</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-ins</span>       <span class="hljs-comment"># 下划线和中划线(就是划掉指定内容的线)</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-mark</span>      <span class="hljs-comment"># 高亮文本</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-checkbox</span>  <span class="hljs-comment"># 复选框</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-imsize</span>    <span class="hljs-comment"># 自定义图片宽高</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-expandable</span>  <span class="hljs-comment"># 折叠/展开内容</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">markdown-it-task-lists</span>  <span class="hljs-comment"># 处理任务列表语法(GFM可使用Todo list)</span><br>  <span class="hljs-attr">anchors:</span><br>    <span class="hljs-attr">level:</span> <span class="hljs-number">1</span><span class="hljs-comment"># 用2时一级标题无法跳转，建议打开</span><br>    <span class="hljs-attr">collisionSuffix:</span> <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-attr">permalink:</span> <span class="hljs-literal">false</span><span class="hljs-comment"># 取消permalink，使用toc即可，或者也可以toc后不添加任何内容，使用permalink: true</span><br>    <span class="hljs-attr">permalinkClass:</span> <span class="hljs-string">&#x27;header-anchor&#x27;</span><br>    <span class="hljs-attr">permalinkSide:</span> <span class="hljs-string">&#x27;left&#x27;</span><br>    <span class="hljs-attr">permalinkSymbol:</span> <span class="hljs-string">&#x27;¶&#x27;</span><br>    <span class="hljs-attr">case:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">separator:</span> <span class="hljs-string">&#x27;-&#x27;</span><br></code></pre></td></tr></table></figure><p>如果同样使用fluid主题的话，注意主题配置文件**_config.yml<strong>的</strong>anchorjs**需要关闭：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 为文章内容中的标题添加锚图标，此处需要关系</span><br><span class="hljs-comment"># Add an anchor icon to the title on the post page</span><br><span class="hljs-attr">anchorjs:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">element:</span> <span class="hljs-string">h1,h2,h3,h4,h5,h6</span><br>  <span class="hljs-comment"># Options: left | right</span><br>  <span class="hljs-attr">placement:</span> <span class="hljs-string">left</span><br>  <span class="hljs-comment"># Options: hover | always | touch</span><br>  <span class="hljs-attr">visible:</span> <span class="hljs-string">always</span><br>  <span class="hljs-comment"># Options: § | # | ❡</span><br>  <span class="hljs-attr">icon:</span> <span class="hljs-string">&quot;❡&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>bug_solve</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo个人博客</tag>
      
      <tag>fluid主题</tag>
      
      <tag>markdown it插件</tag>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期目标</title>
    <link href="/xiaohei07.github.io/2024/07/15/%E8%BF%91%E6%9C%9F%E7%9B%AE%E6%A0%87/"/>
    <url>/xiaohei07.github.io/2024/07/15/%E8%BF%91%E6%9C%9F%E7%9B%AE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>恢复更新.jpg</p><p>保研名额稳了，不枉这三年的努力</p><p>接下来主要更新Python语言、计算机视觉、图神经网络的内容</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>python标准库——os模块常用方法</title>
    <link href="/xiaohei07.github.io/2024/07/14/python%E6%A0%87%E5%87%86%E5%BA%93%E2%80%94%E2%80%94os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/xiaohei07.github.io/2024/07/14/python%E6%A0%87%E5%87%86%E5%BA%93%E2%80%94%E2%80%94os%E6%A8%A1%E5%9D%97%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<div class="toc"><!-- toc --><ul class="lvl-0"><li class="lvl-2"><p><a href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2">写在前面：</a></p></li><li class="lvl-2"><p><a href="#0ospath%E6%A8%A1%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">0.os.path模块中使用的数据类型</a></p></li><li class="lvl-2"><p><a href="#1ospath%E6%A8%A1%E5%9D%97">1.os.path模块：</a></p><ul class="lvl-2"><li class="lvl-4"><a href="#1ospathjoin%E6%96%B9%E6%B3%95">(1)os.path.join方法：</a></li><li class="lvl-4"><a href="#2ospathabspath%E6%96%B9%E6%B3%95">(2)os.path.abspath方法：</a></li><li class="lvl-4"><a href="#2%E7%BB%ADospathrealpath%E6%96%B9%E6%B3%95">(2)[续]os.path.realpath方法：</a></li><li class="lvl-4"><a href="#2%E7%BB%ADospathisabs%E6%96%B9%E6%B3%95">(2)[续]os.path.isabs方法：</a></li><li class="lvl-4"><a href="#3ospathsplitext%E6%96%B9%E6%B3%95">(3)os.path.splitext方法：</a></li><li class="lvl-4"><a href="#3%E7%BB%ADospathsplit%E6%96%B9%E6%B3%95">(3)[续]os.path.split方法：</a></li><li class="lvl-4"><a href="#3%E7%BB%ADospathdirname%E6%96%B9%E6%B3%95">(3)[续]os.path.dirname方法：</a></li><li class="lvl-4"><a href="#3%E7%BB%ADospathbasename%E6%96%B9%E6%B3%95">(3)[续]os.path.basename方法：</a></li><li class="lvl-4"><a href="#4ospathexists%E6%96%B9%E6%B3%95">(4)os.path.exists方法：</a></li><li class="lvl-4"><a href="#4%E7%BB%ADospathisdir%E6%96%B9%E6%B3%95">(4)[续]os.path.isdir方法：</a></li><li class="lvl-4"><a href="#4%E7%BB%ADospathisfile%E6%96%B9%E6%B3%95">(4)[续]os.path.isfile方法：</a></li><li class="lvl-4"><a href="#5ospathnormpath%E6%96%B9%E6%B3%95">(5)os.path.normpath方法：</a></li></ul></li><li class="lvl-2"><p><a href="#2osgetcwd%E6%96%B9%E6%B3%95">2.os.getcwd方法：</a></p></li><li class="lvl-2"><p><a href="#2%E7%BB%ADosgetcwdu%E6%96%B9%E6%B3%95python3%E5%B7%B2%E7%A7%BB%E9%99%A4">2.[续]os.getcwdu方法(Python3已移除)：</a></p></li><li class="lvl-2"><p><a href="#2%E7%BB%ADosgetcwdb%E6%96%B9%E6%B3%95%E4%BB%85%E9%99%90python3">2.[续]os.getcwdb方法(仅限Python3)：</a></p></li><li class="lvl-2"><p><a href="#3oswalk%E6%96%B9%E6%B3%95">3.os.walk方法：</a></p></li><li class="lvl-2"><p><a href="#4osmakedirs%E6%96%B9%E6%B3%95">4.os.makedirs方法：</a></p></li><li class="lvl-2"><p><a href="#4%E7%BB%ADosmkdir%E6%96%B9%E6%B3%95">4[续].os.mkdir方法：</a></p></li></ul><!-- tocstop --></div><h3 id="写在前面"><a href="#写在前面" class="header-anchor">¶</a>写在前面：</h3><p>Python的os模块是Python的标准库之一，是访问多种操作系统的接口，主要涉及与<strong>文件系统的交互和操作功能</strong> ，具有如下作用：</p><ul class="lvl-0"><li class="lvl-2"><p>路径操作(<a href="#os.path"><strong>os.path模块</strong></a>)</p></li><li class="lvl-2"><p>文件和目录操作、文件属性获取</p></li><li class="lvl-2"><p>执行系统命令、执行特定系统功能</p></li><li class="lvl-2"><p>环境变量管理</p></li><li class="lvl-2"><p>进程管理</p></li></ul><p>鉴于网上对os相关方法的说明和使用大多太过含糊简单（特别是某菜鸟编程），或者存在错误理解和使用（特指某些博客），所以写了这篇文章，也是方便自己后续忘记时再次查看os模块中一些常用方法的特定用法</p><p>如果你能够读懂os模块的各个方法的源码，并且有耐心去读的话，那我建议跳过我的使用部分，可能看源码能够有更准确通透的理解。</p><p>观前提醒：需要读者起码具备基本的python代码阅读能力，对python中的字符串有基本的了解（特别是反斜杠&quot;&quot;），能够理解什么是字符串的转义，什么是相对路径、绝对路径（不要拿着什么文件名就问为什么找不到这个文件），并且起码了解windows下的路径(Linux都懂的话看我的博客我觉得应该没什么障碍)，有不懂的部分自行谷歌百度吧，总有比我讲的好的</p><p><strong>更重要的一点：如果你是初学者，希望使用os模块完成简单的路径操作的工作的话，我建议直接学pathlib模块的方法，比os要好，os太繁琐了，只是很多开源项目都是用的os模块，一点不懂的话可能看不懂内容，这个怎么取舍看各位了</strong></p><p>学习pathlib模块的话可以先看这篇知乎的文章入个门：</p><p><a href="https://zhuanlan.zhihu.com/p/475661402">Python路径操作模块pathlib，看这篇就够了！ - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/139783331">python路径操作新标准：pathlib 模块 - 知乎 (zhihu.com)</a></p><p>我的整理的话没有什么逻辑，基本是用了什么方法就整理了什么方法，后续也会不定期更新没有的方法(只要用上了就更)</p><h3 id="0ospath模块中使用的数据类型"><a href="#0ospath模块中使用的数据类型" class="header-anchor">¶</a>0.os.path模块中使用的数据类型</h3><p>如果是初学者，可以跳过下面的复杂说明，并<strong>默认os模块中的方法支持的数据类型为str类型和bytes类型，可以先不考虑自定义的路径类</strong></p><p>os模块中的<strong>os.path模块</strong>对各个方法提供了相应的类型别名，指定了各个方法支持传入的数据类型，为了避免使用python的<strong>typing库</strong>一次次进行<strong>类型注解</strong>，或能够处理特定的数据类型，os模块使用了自定义的类<strong>PathLike</strong>和其他库中支持的类型别名<strong>Anystr、StrPath、BytesPath、StrOrBytesPath</strong>进行类型注解，以说明每个方法可以使用的数据类型</p><p>注意，<strong>windows</strong>下请查看stdlib库的<strong>ntpath.pyi文件</strong>以获得os.path模块对各方法的类型注解，<strong>Linux</strong>下则需要查看stdlib库的<strong>pkgutil.pyi</strong>文件，另外，有部分方法的类型注解存放在<strong>genericpath.pyi文件</strong>下，此部分是两个操作系统共用的</p><p>此处对使用的各个类型进行详细的说明：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>PathLike</strong><span id="os.PathLike"> </span> ：class PathLike(abc.ABC)</p><p>是一个继承自抽象基类(abstract base class, ABC)，用于实现文件系统路径协议，<strong>使用者可以通过继承PathLike类，实现该类的抽象方法来自定义自己的路径类</strong></p><p>PathLike类含有的方法包括：</p><ul class="lvl-2"><li class="lvl-4"><p><strong>__fspath__</strong>：（@abc.abstractmethod）<strong>返回对象的文件系统路径表示</strong>，可以是<strong>str</strong>或者<strong>bytes</strong>类型，即在自定义类实现该方法，使得类的实例对象能够对应一个指定的路径，然后可以使用open()方法或者os模块的方法将实例对象作为一个参数传入这些方法中进行相应的路径操作</p><p>__fspath__是所有继承PathLike的子类必须实现的方法</p></li><li class="lvl-4"><p><strong>__subclasshook__</strong>：（@classmethod）<strong>检查传入的类cls是否是PathLike的子类，通过其是否实现了 <em>_fspath</em>_ 方法作为判断标准，并返回判断结果</strong>，如果传入的类继承PathLike但未实现__fspath__ 方法，也认为该类并不是PathLike类的子类</p></li><li class="lvl-4"><p><strong>_<em>class_getitem</em>_</strong>：用于支持PathLike的泛型语法</p></li></ul><p>其源代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PathLike</span>(abc.ABC):<br><br>    <span class="hljs-string">&quot;&quot;&quot;Abstract base class for implementing the file system path protocol.&quot;&quot;&quot;</span><br><br><span class="hljs-meta">    @abc.abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__fspath__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Return the file system path representation of the object.&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># NotImplementedError继承自RuntimeError</span><br>        <span class="hljs-keyword">raise</span> NotImplementedError<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__subclasshook__</span>(<span class="hljs-params">cls, subclass</span>):<br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">is</span> PathLike:<br>        <span class="hljs-comment"># _check_methods是_collections_abc的一个内置方法，用于检查类是否有对应方法名</span><br>            <span class="hljs-keyword">return</span> _check_methods(subclass, <span class="hljs-string">&#x27;__fspath__&#x27;</span>)<br>        <span class="hljs-comment"># NotImplemented实际是None</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NotImplemented</span><br>      <br><span class="hljs-comment"># 支持泛型使用，可以用PathLike[str]形式，GenericAlias是实现参数化的类型</span><br>    __class_getitem__ = <span class="hljs-built_in">classmethod</span>(GenericAlias)<br></code></pre></td></tr></table></figure><p>使用者可以据此定义自己的路径类并用于os模块和open()方法，下面是一个简单的实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##      自定义PathLike子类       ##</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">My_PathClass</span>(os.PathLike):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, path: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;保存传入的路径&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>._path = path<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__fspath__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;将保存的路径作为类的路径使用&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._path<br><br><span class="hljs-comment"># 简单测试子类实例作为path方法中的参数使用</span><br>mypathclass = My_PathClass(<span class="hljs-string">&quot;./os_test.py&quot;</span>)<br><span class="hljs-built_in">print</span>(os.path.abspath(mypathclass))<br><span class="hljs-comment"># result : H:\py_ipynb\audio_to_text_and_translate\os_test.py</span><br><br><span class="hljs-comment"># 测试读取内容，result略</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(mypathclass, encoding= <span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f.read())<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p><strong>AnyStr</strong><span id="os.AnyStr"> </span> ：TypeVar('AnyStr', bytes, str)</p><p>是typing模块中定义的一个<strong>泛型类型变量</strong>，名称为AnyStr，对应<strong>数据类型为str和bytes</strong>，为字符串和字节串的数据类型情况提供灵活和强大的类型注解支持</p></li><li class="lvl-2"><p><strong>StrPath</strong><span id="os.StrPath"> </span> ：Union[str, PathLike[str]]</p><p>是一个<strong>联合类型别名</strong>，表示一个可以是<strong>字符串</strong>或<strong>实现了PathLike接口</strong>的对象（PathLike对象需要<strong>返回str类型</strong>）</p><p>typing库的Union类型注解表示的是传入的参数可以是在&quot;[]&quot;内多种类型中的任何一种</p></li><li class="lvl-2"><p><strong>BytesPath</strong> <span id="os.BytesPath"> </span>：Union[bytes, PathLike[bytes]]</p><p>是一个<strong>联合类型别名</strong>，表示一个可以是<strong>字节串</strong>或<strong>实现了PathLike接口</strong>的对象（PathLike对象需要<strong>返回bytes类型</strong>）</p></li><li class="lvl-2"><p><strong>StrOrBytesPath</strong> <span id="os.StrOrBytesPath"> </span>：Union[str, bytes, PathLike[str], PathLike[bytes]]</p><p>是一个<strong>联合类型别名</strong>，表示一个可以是<strong>字符串</strong>、<strong>字节串</strong>或<strong>实现了PathLike接口</strong>的对象（PathLike对象需要<strong>返回str类型或bytes类型</strong>）</p></li></ul><p><span id="os.path"> </span></p><h3 id="1ospath模块"><a href="#1ospath模块" class="header-anchor">¶</a>1.os.path模块：</h3><p><span id="os.path.join"> </span></p><h4 id="1ospathjoin方法"><a href="#1ospathjoin方法" class="header-anchor">¶</a>(1)os.path.join方法：</h4><p>用途：拼接多个路径并返回最后的拼接结果</p><p>方法原型：<em><strong>os.path.join(path1[, path2[, ...]])</strong></em></p><p>参数说明：</p><ul class="lvl-0"><li class="lvl-2"><p><em><strong>path1</strong></em>：需要拼接的第一个路径片段，<a href="#os.StrPath"><strong>StrPath</strong></a>类型或<a href="#os.BytesPath"><strong>BytesPath</strong></a>类型，该参数必须传递</p></li><li class="lvl-2"><p><em><strong>path2</strong></em>：需要拼接的第二个路径片段，<strong>StrPath</strong>类型或<strong>BytesPath</strong>类型，该参数可选</p></li><li class="lvl-2"><p>…：其他需要拼接的路径片段，<strong>StrPath</strong>类型或<strong>BytesPath</strong>类型，均可选</p><p>需要注意的是，所有的路径片段的数据类型必须相同，即不可以将<strong>StrPath</strong>类型与<strong>BytesPath</strong>类型混用</p></li></ul><p>返回值：合并后的路径， 如果路径片段是<strong>StrPath</strong>，返回类型为<strong>str</strong>，如果是<strong>BytesPath</strong>，返回类型为<strong>bytes</strong></p><p>使用：</p><p>最简单的拼接是拼接目录+文件名，该方法会自动识别操作系统并补全目录分隔符，可以输入多级目录一次性合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;D:\\video&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))    <span class="hljs-comment"># result: D:\video\test.m4a</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;E:&quot;</span>, <span class="hljs-string">&quot;video&quot;</span>, <span class="hljs-string">&quot;audio\\test&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))   <span class="hljs-comment"># result: E:video\audio\test\test.m4a</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;video&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))    <span class="hljs-comment"># result: video\test.m4a</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;/video&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))   <span class="hljs-comment"># result: /test.m4a</span><br></code></pre></td></tr></table></figure><p>该方法实际有很多需要考虑的问题：</p><p>首先要注意的是，<strong>os.path.join</strong>方法全程不<strong>会去考虑路径是否真实存在，是否是有效路径</strong>，它只是一个<strong>处理字符串格式的路径方法，不涉及任何目录和文件的读写</strong></p><p>其次要注意的是，如果输入的路径有绝对路径(此处指以&quot;/&quot;开头的路径或者以盘符开头的路径)，<strong>os.path.join</strong>会根据情况对其中的部分参数的路径进行丢弃，规则如下：</p><ul class="lvl-0"><li class="lvl-2"><p>在不包括任何盘符时：</p><ul class="lvl-2"><li class="lvl-4">只有一个绝对路径：绝对路径之前的全部参数会被全部丢弃</li><li class="lvl-4">存在多个绝对路径：最后一个绝对路径之前的全部参数会被全部丢弃</li></ul></li><li class="lvl-2"><p>存在单个或多个盘符时：</p><p>绝对路径的逻辑同不包括任何盘符时的情况，但是丢弃参数时会保留最后一个出现的盘符，即，单独判断盘符出现的位置，选择最后一个盘符保存到路径中(即使这个盘符对应的后续路径被丢弃)</p></li></ul><p>从这些规则中可以看出，存在绝对路径时的逻辑是，<strong>只保留最后一个出现的盘符和绝对路径</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># result: /audio\test.m4a ——绝对路径&quot;/audio&quot;前面的&quot;root_path&quot;和&quot;video&quot;被丢弃</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;root_path&quot;</span>, <span class="hljs-string">&quot;video&quot;</span>, <span class="hljs-string">&quot;/audio&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))<br><br><span class="hljs-comment"># result: /test\test.m4a ——最后一个绝对路径&quot;/test&quot;之前的root_path&quot;、&quot;/video&quot;和&quot;/audio&quot;被丢弃</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;root_path&quot;</span>, <span class="hljs-string">&quot;/video&quot;</span>, <span class="hljs-string">&quot;/audio&quot;</span>, <span class="hljs-string">&quot;/test&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))<br><br><span class="hljs-comment"># result: E:/audio\test.m4a ——最后一个绝对路径/audio&quot;之前的参数&quot;&quot;test&quot;、&quot;/action&quot;和&quot;/audio&quot;被丢弃.而&quot;E:\\video&quot;的&quot;\\video&quot;被丢弃,&quot;E:&quot;盘符被保留</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;E:\\video&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;/action&quot;</span>, <span class="hljs-string">&quot;/audio&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))<br><br><span class="hljs-comment"># result: E:/video\test.m4a ——最后一个绝对路径/video&quot;之前的参数&quot;\\action&quot;、&quot;F:/test&quot;和&quot;E:\\audio&quot;除最后一个盘符&quot;E:&quot;外均被丢弃</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;\\action&quot;</span>, <span class="hljs-string">&quot;F:/test&quot;</span>, <span class="hljs-string">&quot;E:\\audio&quot;</span>, <span class="hljs-string">&quot;/video&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>))<br></code></pre></td></tr></table></figure><p>另外，对于出现在最后一个绝对路径之后的相对路径，会被原样保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># result: F:/video\./audio\test.m4a ——出现在最后一个绝对路径/video之后的相对路径./audio会被原样保存</span><br>os.path.join(<span class="hljs-string">&quot;F:/test&quot;</span>, <span class="hljs-string">&quot;/video&quot;</span>, <span class="hljs-string">&quot;./audio&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>)<br></code></pre></td></tr></table></figure><p>而对于只有相对路径的情况，<strong>os.path.join</strong>会正常保存，不对相对路径做任何处理，所以需要绝对路径时需要使用<a href="#os.path.abspath"><strong>os.path.abspath</strong></a>方法获得绝对路径再拼接，尽量不要在拼接后再使用<strong>os.path.abspath</strong>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\save_video\test.m4a 路径正确</span><br><span class="hljs-built_in">print</span>(os.path.abspath(os.path.join(<span class="hljs-string">&quot;./save_video&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>)))<br><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\save_video\test.m4a 路径正确</span><br><span class="hljs-built_in">print</span>(os.path.join(os.path.abspath(<span class="hljs-string">&quot;./save_video&quot;</span>), <span class="hljs-string">&quot;test.m4a&quot;</span>))<br><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\audio\save_video\test.m4a</span><br><span class="hljs-comment"># 路径错误，因为相对路径的格式有问题，此处os.path.abspath只是拼接了当前工作路径和传入的路径，并将&quot;.&quot;去除完成拼接</span><br><span class="hljs-comment"># 此处是audio\./save_video\test.m4a</span><br><span class="hljs-built_in">print</span>(os.path.abspath(os.path.join(<span class="hljs-string">&quot;audio&quot;</span>, <span class="hljs-string">&quot;./save_video&quot;</span>, <span class="hljs-string">&quot;test.m4a&quot;</span>)))<br><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\save_video\test.m4a #路径正确</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;/audio&quot;</span>, os.path.abspath(<span class="hljs-string">&quot;./save_video&quot;</span>), <span class="hljs-string">&quot;test.m4a&quot;</span>))<br></code></pre></td></tr></table></figure><p>可以看到，在某些情况下，先拼接相对路径再转绝对路径会出现问题，推荐拼接时先将相对路径转为绝对路径</p><p>最后，如果传入的最后一个路径是空字符串，则该方法会为路径最后添加一个目录分隔符作为结尾：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># result: ./save_video\</span><br><span class="hljs-built_in">print</span>(os.path.join(<span class="hljs-string">&quot;./save_video&quot;</span>, <span class="hljs-string">&quot;&quot;</span>))<br></code></pre></td></tr></table></figure><p><span id="os.path.abspath"> </span></p><h4 id="2ospathabspath方法"><a href="#2ospathabspath方法" class="header-anchor">¶</a>(2)os.path.abspath方法：</h4><p>用途：获得指定文件/目录<strong>路径</strong>的绝对路径</p><p>方法原型：<em><strong>os.path.abspath(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：需要获得绝对路径的对应文件的路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，可以是绝对路径/相对路径</p><p>返回值：<strong>AnyStr</strong>类型，返回其对应的绝对路径</p><p>使用：</p><p><strong>os.path.abspath</strong>方法没有想象的那么简单，其实际的使用基于<a href="#os.getcwd"><strong>os.getcwd</strong></a>方法，其内部逻辑分为三步：</p><ol><li class="lvl-3"><p>检验<em><strong>path</strong></em>是否是绝对路径，如果是，则直接返回</p></li><li class="lvl-3"><p>否则，利用<strong>os.getcwd</strong>方法(如果<em><strong>path</strong></em>是Unicode编码，使用<a href="#os.getcwdu"><strong>os.getcwdu</strong></a>方法)获得当前的工作路径</p></li><li class="lvl-3"><p>将传入的<em><strong>path</strong></em>与当前工作路径进行路径拼接</p></li></ol><p>在传入的<em><strong>path</strong></em>为绝对路径或者基于当前工作路径的正确相对路径时，该方法的工作是正常的，可以获得正确的绝对路径。但如果<em><strong>path</strong></em>是非当前工作目录的文件名，或者是错误的文件相对路径时，该方法只会错误的将传入的<em><strong>path</strong></em>与当前工作路径直接拼接，详细例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在子目录下有一个vidio/test.m4a文件</span><br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&quot;./vidio/test.m4a&quot;</span>))<br><br><span class="hljs-comment"># 在其他目录下有一个music_translate\music_use.ipynb文件路径</span><br><span class="hljs-comment"># result :H:\py_ipynb\music_trans\music_use.ipynb 结果准确</span><br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&quot;../music_translate/music_use.ipynb&quot;</span>))<br><br><span class="hljs-comment"># 传入错误的test.m4a文件相对路径</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\error_vidio\test.m4a 结果错误,只是去掉了&quot;.&quot;后进行了拼接</span><br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&quot;./error_vidio/test.m4a&quot;</span>))<br><br><span class="hljs-comment"># 直接传入music_use.ipynb文件路径</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\music_use.ipynb 结果错误,只是进行了拼接</span><br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&quot;music_use.ipynb&quot;</span>))<br><br><span class="hljs-comment"># 传入错误的music_use.ipynb文件相对路径</span><br><span class="hljs-comment"># result: H:\py_ipynb\error\music_use.ipynb 结果错误,只是去掉了&quot;..&quot;和当前工作路径的最后一个目录后进行了拼接</span><br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&quot;../error/music_use.ipynb&quot;</span>))<br><br><span class="hljs-comment"># 随便传入一个字符串</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text\you are happy 结果错误,只是进行了拼接</span><br><span class="hljs-built_in">print</span>(os.path.abspath(<span class="hljs-string">&quot;you are happy&quot;</span>))<br></code></pre></td></tr></table></figure><p>由此可以看出，该方法<strong>实际并不判断文件是否存在，路径是否有效</strong>，其只是将当前工作路径和传入的字符串中有效的相对路径进行合并，然后直接拼接，所以需要谨慎使用，或者结合其他判断路径/文件存在方法使用</p><p>另外，如果传入的是一个以&quot;/&quot;开头的绝对路径，该方法会直接将盘符与传入路径字符串进行合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 传入一个绝对路径</span><br><span class="hljs-comment"># result: H:\test.m4a 仅将盘符与其拼接</span><br>os.path.abspath(<span class="hljs-string">&quot;/test.m4a&quot;</span>)<br></code></pre></td></tr></table></figure><p><span id="os.path.realpath"> </span></p><h4 id="2续ospathrealpath方法"><a href="#2续ospathrealpath方法" class="header-anchor">¶</a>(2)[续]os.path.realpath方法：</h4><p>用途：获得指定文件/目录<strong>路径</strong>的绝对路径</p><p>方法原型：<em><strong>os.path.realpath(path, strict= False)</strong></em>（Python3.10以上版本有额外参数strict，3.9及以下是没有的）</p><p>参数说明：</p><ul class="lvl-0"><li class="lvl-2"><p><em><strong>path</strong></em>：需要获得绝对路径的对应文件的路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，可以是绝对路径/相对路径</p></li><li class="lvl-2"><p><em><strong>strict</strong></em>：解析<strong>符号链接</strong>的模式(详见下方使用部分)，<strong>True时表示严格模式</strong>，如果路径中的任何部分（包括符号链接的目标路径）不存在，会抛出错误FileNotFoundError，即<strong>使用的必须是文件系统实际存在的路径</strong>，<strong>False时表示非严格模式</strong>，此时方法会尽可能地解析路径的符号链接，但路径中某些部分不存在时不会引发错误，即<strong>允许路径包含未创建的部分</strong></p><p>对于<strong>Python3.9及以下版本</strong>，<strong>使用效果和strict= False相同</strong></p></li></ul><p>返回值：<strong>AnyStr</strong>类型，返回解析结果对应的绝对路径</p><p>使用：</p><p><strong>os.path.realpath</strong>方法与<a href="#os.path.abspath"><strong>os.path.abspath</strong></a>方法的基本用法是一致的，但前者在将相对路径转换为绝对路径时，会<strong>解析路径中的符号链接(软链接)</strong>，返回<strong>实际文件/目录</strong>的绝对路径</p><p>对于Windows用户，此处的<strong>软链接并非快捷方式</strong>，创建软链接需要使用<strong>cmd的mklink命令</strong>(详见这个博客<a href="https://blog.csdn.net/qq_35896136/article/details/105667678">Windows:在Windows下创建并删除软连接_如何查询windows删除软链接-CSDN博客</a>)</p><p>下面仅说明和<strong>os.path.abspath</strong>方法不同的用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># # 3.10以后可用，对不存在的文件strict为False时不报错</span><br><span class="hljs-comment"># # result:H:\py_ipynb\audio_to_text_and_translate\you are happy</span><br><span class="hljs-comment"># print(os.path.realpath(&quot;you are happy&quot;, strict=False))</span><br><br><span class="hljs-comment"># # 3.10以后可用，对不存在的文件strict为True时报错FileNotFoundError</span><br><span class="hljs-comment"># print(os.path.realpath(&quot;you are happy&quot;, strict=True))</span><br><br><span class="hljs-comment"># 否则这样使用，和strict=False的效果相同</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text_and_translate\you are happy</span><br><span class="hljs-built_in">print</span>(os.path.realpath(<span class="hljs-string">&quot;you are happy&quot;</span>))<br><br><span class="hljs-comment"># 尝试解析符号链接，链接为当前文件</span><br><span class="hljs-comment"># H:\py_ipynb\audio_to_text_and_translate\os_test.py，此为软链接指向的文件</span><br><span class="hljs-built_in">print</span>(os.path.realpath(<span class="hljs-string">&quot;./video/link.py&quot;</span>))<br></code></pre></td></tr></table></figure><p><span id="os.path.isabs"> </span></p><h4 id="2续ospathisabs方法"><a href="#2续ospathisabs方法" class="header-anchor">¶</a>(2)[续]os.path.isabs方法：</h4><p>用途：判断指定文件/目录<strong>路径</strong>是否为绝对路径</p><p>方法原型：<em><strong>os.path.isabs(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：指定的路径字符串，<a href="#os.StrOrBytesPath"><strong>StrOrBytesPath</strong></a>类型，可以是绝对路径/相对路径</p><p>返回值：bool类型，True表示路径是绝对路径，False表示不是绝对路径</p><p>使用：</p><p><strong>os.path.isabs</strong>方法只是判断<em><strong>path</strong></em>是否是一个绝对路径，即该参数值是否符合绝对路径的格式，<strong>不会判断该绝对路径是否是真实存在的</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##       os.path.isabs方法：判断传入路径是否是绝对路径       ##</span><br><span class="hljs-comment"># 相对报错</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;./music_use.ipynb&quot;</span>))   <span class="hljs-comment"># False</span><br><span class="hljs-comment"># 任意字符串报错</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;you are happy&quot;</span>))       <span class="hljs-comment"># False</span><br><span class="hljs-comment"># 绝对无论是否存在均不报错</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;H:\py_ipynb\\audio_to_text_and_translate\os_test.py&quot;</span>))    <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;H:\py_ipynb\error\music_use.ipynb&quot;</span>))   <span class="hljs-comment"># True</span><br><span class="hljs-comment"># 注意格式需要正确，以及转移字符不一定影响正确性</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;K:\\root\c\c\c\d&quot;</span>))    <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;K:\\root\ac\c\c\d&quot;</span>))   <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;K:\root\c\c\c\d&quot;</span>))     <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(os.path.isabs(<span class="hljs-string">&quot;Kk:\\root\c\c\c\d&quot;</span>))   <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p><span id="os.path.splitext"> </span></p><h4 id="3ospathsplitext方法"><a href="#3ospathsplitext方法" class="header-anchor">¶</a>(3)os.path.splitext方法：</h4><p>用途：将传入路径分割，获得<strong>文件路径名称</strong>(无扩展名)和<strong>文件扩展名</strong></p><p>方法原型：<em><strong>os.path.splitext(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：分割的路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，一般是绝对路径(相对路径也可以，但该方法<strong>不会主动转化相对路径为绝对路径</strong>)</p><p>返回值：含两个<strong>AnyStr</strong>元素的元组，前者为文件路径名称(包括文件所在目录路径+文件名称)，后者为文件扩展名</p><p>使用：</p><p><strong>os.path.splitext</strong>方法实际是通过<strong>从右向左寻找第一个点号分隔符</strong>完成的分割操作，如果没有点号分隔符(目录/无后缀文件)，则第二个元素(扩展名部分)为空字符串</p><p>该方法可用于更换扩展名、计算某文件夹下的对应文件类型数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过分割将txt扩展名更换为md</span><br>file_use = <span class="hljs-string">&quot;D:/save/a.txt&quot;</span><br><span class="hljs-comment"># result：(&#x27;D:/save/a&#x27;, &#x27;.txt&#x27;)</span><br><span class="hljs-built_in">print</span>(os.path.splitext(file_use))<br>new_suffix = <span class="hljs-string">&quot;.md&quot;</span><br><span class="hljs-comment"># result: D:/save/a.md</span><br><span class="hljs-built_in">print</span>(os.path.splitext(file_use)[<span class="hljs-number">0</span>] + new_suffix)<br><br><span class="hljs-comment"># 统计对特定目录的txt文件数量</span><br>target_dir = <span class="hljs-string">&quot;D:/file_count&quot;</span><br>file_number = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> os.walk(target_dir):<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>        <span class="hljs-keyword">if</span> os.path.splitext(file)[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;.txt&quot;</span>:<br>            file_number += <span class="hljs-number">1</span><br><span class="hljs-comment"># result: file_number = 10</span><br><span class="hljs-built_in">print</span>(file_number)<br><br><span class="hljs-comment"># 无扩展名文件的第二个元素是空字符串</span><br>file = <span class="hljs-string">&quot;D:/save/a&quot;</span><br><span class="hljs-comment"># result: &quot;&quot;</span><br><span class="hljs-built_in">print</span>(os.path.splitext(file)[<span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><span id="os.path.split"> </span></p><h4 id="3续ospathsplit方法"><a href="#3续ospathsplit方法" class="header-anchor">¶</a>(3)[续]os.path.split方法：</h4><p>用途：将传入路径分割，获得<strong>文件目录路径</strong>和<strong>文件名(文件名称+扩展名)</strong></p><p>方法原型：<em><strong>os.path.split(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：分割的路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，一般是绝对路径(相对路径也可以，但该方法<strong>不会主动转化相对路径为绝对路径</strong>)</p><p>返回值：含两个<strong>AnyStr</strong>元素的元组，前者为文件目录路径，后者为文件名</p><p>使用：</p><p><strong>os.path.split</strong>方法实际是通过<strong>从右向左寻找第一个路径分隔符</strong>完成的分割操作，如果没有路径分隔符，则第一个元素(目录路径部分)为空字符串</p><p>如果路径以路径分隔符结尾，第二个元素(文件名部分)为空字符串</p><p>该方法可用于文件重命名(基于已有名称)，路径规范化，通常与<a href="#os.path.join"><strong>os.path.join</strong></a>和<a href="#os.path.normpath"><strong>os.path.normpath</strong></a>组合使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过分割将文件名中的序号+1并规范化文件名</span><br>file_use = <span class="hljs-string">&quot;D:/save/1.txt&quot;</span><br><span class="hljs-comment"># result：(&#x27;D:/save/&#x27;, &#x27;1.txt&#x27;)</span><br>file_split = os.path.split(file_use)<br><span class="hljs-built_in">print</span>(file_split)<br>new_filename = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">int</span>(file_split[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>) + file_split[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>:]<br><span class="hljs-comment"># result: D:/save/2.txt</span><br><span class="hljs-built_in">print</span>(os.path.normpath(os.path.join(file_split[<span class="hljs-number">0</span>], new_filename)))<br><br><span class="hljs-comment"># 没有路径分隔符的第1个元素是空字符串</span><br>file_use = <span class="hljs-string">&quot;D:/save&quot;</span><br><span class="hljs-comment"># result: (&#x27;D:/&#x27;, &#x27;save&#x27;)</span><br><span class="hljs-built_in">print</span>(os.path.split(file_use))<br><br><span class="hljs-comment"># 以路径分隔符结尾的第2个元素是空字符串</span><br>file_use = <span class="hljs-string">&quot;D:/save/&quot;</span><br><span class="hljs-comment"># result: (&#x27;D:/save&#x27;, &#x27;&#x27;)</span><br><span class="hljs-built_in">print</span>(os.path.split(file_use))<br></code></pre></td></tr></table></figure><p><span id="os.path.dirname"> </span></p><h4 id="3续ospathdirname方法"><a href="#3续ospathdirname方法" class="header-anchor">¶</a>(3)[续]os.path.dirname方法：</h4><p>用途：获得指定路径的文件目录路径部分</p><p>方法原型：<em><strong>os.path.dirname(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：指定的文件路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，一般是绝对路径(相对路径也可以，但该方法<strong>不会主动转化相对路径为绝对路径</strong>)</p><p>返回值：<strong>AnyStr</strong>类型，返回指定路径的目录路径部分</p><p>使用：</p><p>实际获得的是<a href="#os.path.split"><strong>os.path.split</strong></a>方法所分割的第一个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">file_use = <span class="hljs-string">&quot;D:/save/1.txt&quot;</span><br><span class="hljs-comment"># result：D:/save/</span><br>dir_name = os.path.dirname(file_use)<br><span class="hljs-built_in">print</span>(dir_name)<br></code></pre></td></tr></table></figure><p><span id="os.path.basename"> </span></p><h4 id="3续ospathbasename方法"><a href="#3续ospathbasename方法" class="header-anchor">¶</a>(3)[续]os.path.basename方法：</h4><p>用途：获得指定路径的文件名部分</p><p>方法原型：<em><strong>os.path.basename(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：指定的文件路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，绝对路径/相对路径均可</p><p>返回值：<strong>AnyStr</strong>类型，返回指定路径的文件名部分</p><p>使用：</p><p>实际获得的是<a href="#os.path.split"><strong>os.path.split</strong></a>方法所分割的第二个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">file_use = <span class="hljs-string">&quot;D:/save/1.txt&quot;</span><br><span class="hljs-comment"># result：1.txt</span><br>base_name = os.path.basename(file_use)<br><span class="hljs-built_in">print</span>(base_name)<br></code></pre></td></tr></table></figure><p><span id="os.path.exists"> </span></p><h4 id="4ospathexists方法"><a href="#4ospathexists方法" class="header-anchor">¶</a>(4)os.path.exists方法：</h4><p>用途：判断文件系统中是否存在与传入的路径所对应的真实文件/目录</p><p>方法原型：<em><strong>os.path.exists(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：传入的路径，<a href="#os.StrOrBytesPath"><strong>StrOrBytesPath</strong></a>类型，可以是绝对路径/相对路径</p><p>返回值：bool类型，True表示传入路径存在真实文件/目录，False表示不存在真实文件/目录</p><p>使用：</p><p>该方法较简单，但是要注意传入路径的转义，在<em><strong>path</strong></em>前加&quot;r&quot;完成转义，另外，注意同一路径可能有同名的目录和文件，注意区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">file_use = <span class="hljs-string">r&quot;D:\save\1.txt&quot;</span><br><span class="hljs-built_in">print</span>(os.path.exists(file_use))     <span class="hljs-comment"># True</span><br>file_use = <span class="hljs-string">r&quot;D:\save\2.txt&quot;</span><br><span class="hljs-built_in">print</span>(os.path.exists(file_use))     <span class="hljs-comment"># False</span><br><span class="hljs-built_in">print</span>(os.path.exists(<span class="hljs-string">&quot;./os_test.py&quot;</span>))   <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(os.path.exists(<span class="hljs-string">&quot;./video&quot;</span>))    <span class="hljs-comment"># True</span><br><span class="hljs-built_in">print</span>(os.path.exists(<span class="hljs-string">&quot;./no_exist&quot;</span>))    <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p><span id="os.path.isdir"> </span></p><h4 id="4续ospathisdir方法"><a href="#4续ospathisdir方法" class="header-anchor">¶</a>(4)[续]os.path.isdir方法：</h4><p>用途：判断文件系统中是否存在与传入的路径所对应的真实目录</p><p>方法原型：<em><strong>os.path.isdir(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：传入的路径，<a href="#os.StrOrBytesPath"><strong>StrOrBytesPath</strong></a>类型，可以是绝对路径/相对路径</p><p>返回值：bool类型，True表示传入路径存在真实目录，False表示不存在真实目录</p><p>使用：</p><p>该方法逻辑和<strong>os.path.exists</strong>基本相同，判断的目标从是否存在文件/目录变为了是否是目录，使用该方法需要注意<strong>目录和文件存在同名现象</strong>，需要判断使用场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">file_use = <span class="hljs-string">r&quot;D:\save\1.txt&quot;</span><br><span class="hljs-built_in">print</span>(os.path.isdir(file_use))  <span class="hljs-comment"># False</span><br><span class="hljs-comment"># 文件夹以&quot;.&quot;+特定后缀名结尾判断</span><br>file_use = <span class="hljs-string">r&quot;D:\save\dir.txt&quot;</span><br><span class="hljs-built_in">print</span>(os.path.isdir(file_use))  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p><span id="os.path.isfile"> </span></p><h4 id="4续ospathisfile方法"><a href="#4续ospathisfile方法" class="header-anchor">¶</a>(4)[续]os.path.isfile方法：</h4><p>用途：判断文件系统中是否存在与传入的路径所对应的真实文件</p><p>方法原型：<em><strong>os.path.isfile(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：传入的路径，<a href="#os.StrOrBytesPath"><strong>StrOrBytesPath</strong></a>类型，可以是绝对路径/相对路径</p><p>返回值：bool类型，True表示传入路径存在真实文件，False表示不存在真实文件</p><p>使用：</p><p>该方法逻辑和<strong>os.path.exists</strong>基本相同，判断的目标从是否存在文件/目录变为了是否是文件，使用该方法需要注意<strong>目录和文件存在同名现象</strong>，需要判断使用场景：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">file_use = <span class="hljs-string">r&quot;D:\save\1.txt&quot;</span><br><span class="hljs-built_in">print</span>(os.path.isfile(file_use))  <span class="hljs-comment"># True</span><br><span class="hljs-comment"># 文件夹以&quot;.&quot;+特定后缀名结尾判断</span><br>file_use = <span class="hljs-string">r&quot;D:\save\dir.txt&quot;</span><br><span class="hljs-built_in">print</span>(os.path.isfile(file_use))  <span class="hljs-comment"># False</span><br></code></pre></td></tr></table></figure><p><span id="os.path.normpath"> </span></p><h4 id="5ospathnormpath方法"><a href="#5ospathnormpath方法" class="header-anchor">¶</a>(5)os.path.normpath方法：</h4><p>用途：规范化路径字符串</p><p>方法原型：<em><strong>os.path.normpath(path)</strong></em></p><p>参数说明：<em><strong>path</strong></em>：传入的路径，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，可以是绝对路径/相对路径</p><p>返回值：<strong>AnyStr</strong>类型，返回规范化后的路径字符串</p><p>使用：</p><p><strong>os.path.normpath</strong>方法是一个仅操作路径字符串的方法，<strong>不会访问文件系统</strong>，<strong>具有操作系统依赖性</strong></p><p>该方法的规范化方法主要包括：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>去除冗余的分隔符</strong>：将连续的分隔符合并为一个</p></li><li class="lvl-2"><p><strong>移除当前目录引用</strong>：当前目录引用 <code>.</code> 会被移除，因为其不改变路径</p></li><li class="lvl-2"><p><strong>解析上层目录引用</strong>：上层目录引用 <code>..</code> 会被解析为返回上一级目录，即移除上层目录引用的前一个目录路径</p></li><li class="lvl-2"><p><strong>转换路径分隔符</strong>：自动将路径的分隔符转换为当前操作系统的默认分隔符</p></li></ul><p>实际效果如下(windows平台)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 规范绝对路径</span><br><span class="hljs-comment"># result: D:\save\1.txt</span><br><span class="hljs-built_in">print</span>(os.path.normpath(<span class="hljs-string">&quot;D://////save\\\\1.txt&quot;</span>))<br><br><span class="hljs-comment"># 规范相对路径</span><br><span class="hljs-comment"># result: os_test.py</span><br><span class="hljs-built_in">print</span>(os.path.normpath(<span class="hljs-string">&quot;./\/\/\/\os_test.py&quot;</span>))<br><span class="hljs-comment"># result: ..\dir_file.txt</span><br><span class="hljs-built_in">print</span>(os.path.normpath(<span class="hljs-string">&quot;.///..///dir_file.txt&quot;</span>))<br><br><span class="hljs-comment"># 规范有冗余的相对路径</span><br><span class="hljs-comment"># result: folder\file.txt</span><br><span class="hljs-comment"># 移除多余的&quot;/&quot; -&gt; ./folder/./subfolder/../file.txt</span><br><span class="hljs-comment"># 转换路径分隔符 -&gt; .\folder\.\subfolder\..\file.txt</span><br><span class="hljs-comment"># 移除&quot;.&quot; -&gt; folder\subfolder\..\file.txt</span><br><span class="hljs-comment"># 解析&quot;..&quot;，将\subfolder\..移除 -&gt; folder\file.txt</span><br><span class="hljs-built_in">print</span>(os.path.normpath(<span class="hljs-string">&quot;./folder///./subfolder//../file.txt&quot;</span>))<br><br><span class="hljs-comment"># result: ..\dir_file.txt</span><br><span class="hljs-built_in">print</span>(os.path.normpath(<span class="hljs-string">&quot;../\/\././/./dirname/../dir_file.txt&quot;</span>))<br></code></pre></td></tr></table></figure><p><span id="os.getcwd"> </span></p><h3 id="2osgetcwd方法"><a href="#2osgetcwd方法" class="header-anchor">¶</a>2.os.getcwd方法：</h3><p>用途：获得当前工作目录(working directory)的路径</p><p>方法原型：<em><strong>os.getcwd()</strong></em></p><p>参数说明：无</p><p>返回值：当前的工作目录路径，在Python3中返回类型为<strong>unicode字符串</strong>(str数据类型)，在Python2中返回类型为<strong>字节字符串</strong>(bytes数据类型)</p><p>使用：</p><p><strong>os.getcwd()<strong>返回的不是使用该方法的py脚本文件的目录的路径，而是是</strong>运行/调用/执行脚本的工作文件的目录的路径</strong>，<strong>前者称为当前文件目录，后者称为当前工作路径</strong>，如果希望获得当前文件路径的话，需要使用**_<em>file</em>_**属性，而目录需要结合其他os模块方法获得</p><p>如果执行脚本即为运行**os.getcwd()<strong>和</strong>_<em>file</em>_**的脚本，则当前工作目录和当前文件目录是一致的</p><p>一般情况下，**os.getcwd()<strong>和</strong>_<em>file</em>_**会结合<a href="#os.path.abspath"><strong>os.path.abspath</strong></a>和<a href="#os.path.dirname"><strong>os.path.dirname</strong></a>使用：</p><ul class="lvl-0"><li class="lvl-2"><p>当前文件路径通过os.path.abspath(_<em>file</em>_))获得(直接__file__也可以)</p></li><li class="lvl-2"><p>当前文件目录通过os.path.abspath(os.path.dirname(_<em>file</em>_))获得</p></li><li class="lvl-2"><p>当前工作目录通过os.path.abspath(os.getcwd())获得(直接os.getcwd()也可以)</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##      os.getcwd方法：获得当前工作路径        ##</span><br><span class="hljs-comment"># 当前工作目录</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text_and_translate</span><br><span class="hljs-built_in">print</span>(os.path.abspath(os.getcwd()))<br><br><span class="hljs-comment"># 当前文件路径</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text_and_translate\os_test.py</span><br><span class="hljs-built_in">print</span>(os.path.abspath(__file__))<br><br><span class="hljs-comment"># 当前文件目录</span><br><span class="hljs-comment"># result: H:\py_ipynb\audio_to_text_and_translate</span><br><span class="hljs-built_in">print</span>(os.path.abspath(os.path.dirname(__file__)))<br></code></pre></td></tr></table></figure><p><span id="os.getcwdu"> </span></p><h3 id="2续osgetcwdu方法python3已移除"><a href="#2续osgetcwdu方法python3已移除" class="header-anchor">¶</a>2.[续]os.getcwdu方法(Python3已移除)：</h3><p>只能在Python2中使用，且返回类型为<strong>unicode字符串</strong>(str数据类型)，其返回内容和Python3中<a href="#os.getcwd"><strong>os.getcwd()</strong></a>方法相同</p><p><strong>Python3用户请不要使用此方法</strong></p><p><span id="os.getcwdb"> </span></p><h3 id="2续osgetcwdb方法仅限python3"><a href="#2续osgetcwdb方法仅限python3" class="header-anchor">¶</a>2.[续]os.getcwdb方法(仅限Python3)：</h3><p>只能在Python3中使用，且返回类型在Python3.8之前为ANSI编码的字节字符串(bytes数据类型)，在Python3.8及以后为UTF-8的编码的字节字符串(<a href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html">Python 3.8 有什么新变化 — Python 3.8.19 文档</a>)，其返回内容和Python3中<a href="#os.getcwd"><strong>os.getcwd()</strong></a>方法相同</p><p><strong>Python2用户请不要使用此方法</strong></p><p><span id="os.walk"> </span></p><h3 id="3oswalk方法"><a href="#3oswalk方法" class="header-anchor">¶</a>3.os.walk方法：</h3><p>用途：递归地遍历指定目录下的全部子文件及子目录的全部文件</p><p>方法原型：<em><strong>os.walk( top [, topdown=True [, onerror=None [, followlinks=False] ] ] )</strong></em></p><p>参数说明：</p><ul class="lvl-0"><li class="lvl-2"><p><em><strong>top</strong></em>：需要遍历的目录，<a href="#os.AnyStr"><strong>AnyStr</strong></a>或者<a href="#os.PathLike"><strong>PathLike[AnyStr]</strong></a>类型，该参数必须传递</p></li><li class="lvl-2"><p><em><strong>topdown</strong></em>：是否优先遍历<em><strong>top</strong></em>对应的目录，bool类型，True时优先遍历<em><strong>top</strong></em>目录，对应目录树的向下查找；False时优先遍历<em><strong>top</strong></em>子目录，对应目录树的向上查找，默认为True，该参数可选</p></li><li class="lvl-2"><p><em><strong>onerror</strong></em>：自定义的回调函数，<strong>Callable对象类型</strong>(实际是Callable[[OSError], Any])，在<em><strong>os.walk</strong></em>遇到异常(权限不足、文件被删除或无法访问)时调用<em><strong>onerror</strong></em>处理遍历时发生的错误，可以使用日志记录，输出错误信息等函数作为<em><strong>onerror</strong></em>参数，默认为None，该参数可选</p></li><li class="lvl-2"><p><em><strong>followlinks</strong></em>：是否遍历目录下的快捷方式实际指向的目录 ，bool类型，True时遍历快捷方式实际指向的目录，False时不遍历快捷方式实际指向的目录，默认为False，该参数可选</p></li></ul><p>返回值：<em><strong>os.walk</strong></em>返回一个生成器对象，<strong>类型为Iterator[tuple[AnyStr, list[AnyStr], list[AnyStr]]]</strong>，实际上，其每次返回的是(<em><strong>root,dirs,files</strong></em>)的三元组作为该次遍历时的返回值</p><ul class="lvl-0"><li class="lvl-2"><p><em><strong>root</strong></em>：<strong>AnyStr</strong>类型，对应当前遍历的目录路径</p></li><li class="lvl-2"><p><em><strong>dirs</strong></em>：**list[AnyStr]**类型，对应当前遍历的目录下的全部目录名集合</p></li><li class="lvl-2"><p><em><strong>files</strong></em>：**list[AnyStr]**类型，对应当前遍历的目录下的全部文件名集合</p></li></ul><p>使用：如果希望获得的是<em><strong>top</strong></em>目录下的文件/目录的相对路径，需要将root与dirs/files拼接，此处可使用<a href="#os.path.join"><strong>os.path.join</strong></a>方法完成，例子如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">path_files = []<br><span class="hljs-keyword">for</span> root, dirs, <span class="hljs-keyword">files</span> in os.walk(path):<br>    <span class="hljs-keyword">for</span> <span class="hljs-keyword">file</span> in <span class="hljs-keyword">files</span>:<br>        path_files.<span class="hljs-keyword">append</span>(os.path.<span class="hljs-keyword">join</span>(root, <span class="hljs-keyword">file</span>))<br><span class="hljs-keyword">return</span> path_files<br></code></pre></td></tr></table></figure><p>如果希望该路径是绝对路径，需要在append方法前使用<a href="#os.path.abspath"><strong>os.path.abspath</strong></a>方法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">path_files = []<br><span class="hljs-keyword">for</span> root, dirs, files <span class="hljs-keyword">in</span> <span class="hljs-built_in">os</span>.walk(<span class="hljs-built_in">path</span>):<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>        path_files.append(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(root, file)))<br><span class="hljs-keyword">return</span> path_files<br></code></pre></td></tr></table></figure><p><span id="os.makedirs"> </span></p><h3 id="4osmakedirs方法"><a href="#4osmakedirs方法" class="header-anchor">¶</a>4.os.makedirs方法：</h3><p>用途：递归地创建多级目录，对于中间级不存在的目录也会自动创建</p><p>方法原型：<em><strong>os.makedirs(name [, mode=0o777 [, exist_ok=False]])</strong></em></p><p>参数说明：</p><ul class="lvl-0"><li class="lvl-2"><p><em><strong>name</strong></em>：需要递归创建的目录路径，<a href="#os.StrOrBytesPath"><strong>StrOrBytesPath</strong></a>类型，可以是绝对路径/相对路径，该参数必须传递</p></li><li class="lvl-2"><p><em><strong>mode</strong></em>：Linux目录权限数字模式，windows下该参数无效，int类型(一般用3位八进制数字表示)，默认为0o777(即任何用户均可读可写可执行)，该参数可选</p></li><li class="lvl-2"><p><em><strong>exist_ok</strong></em>：是否在目录存在时抛出异常，bool类型，如果<em><strong>name</strong></em>已存在且为目录，在<em><strong>exist_ok</strong></em>为True不抛出异常，否则均抛出<strong>FileExistsError</strong>异常(Windows下为<strong>WinError183</strong>)，默认为False，该参数可选</p></li></ul><p>返回值：无返回值</p><p>使用：该方法实际上要注意的点很多</p><p>首先，在基本使用时，由于其递归创建多级目录，所以在中间级目录名出现错误的情况下该方法不会报错，而是会沿着一个错误的路径进行创建，需要注意检查：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf"><span class="hljs-comment"># 尝试当前目录创建</span><br><span class="hljs-keyword">os</span>.makedirs(name=<span class="hljs-string">&quot;./test&quot;</span>)    <span class="hljs-comment"># 正确，在当前工作目录子目录下创建了一个test目录</span><br><span class="hljs-keyword">os</span>.makedirs(name=<span class="hljs-string">&quot;./vidio/test&quot;</span>)    <span class="hljs-comment"># 错误，创建了不存在的vidio目录，并在该目录下创建了test目录，与实际预期不符</span><br></code></pre></td></tr></table></figure><p>其次，Linux用户需要考虑mode模式的权限，有些目录的权限不可使用默认的777；而windows用户无论怎么修改mode，实际对创建的目录是没有权限影响的，使用的都是windows默认创建目录的权限，需要自行手动修改：</p><img src="https://s21.ax1x.com/2024/04/15/pFvcmzq.png" alt="image-20240415132343397" style="zoom:50%;"><p>上图为手动创建的video文件夹和指定mode=0o111时创建的vidio文件夹，可以看到二者权限完全一致(其他组/用户也相同，此处不再一一展示)</p><p>另外，使用<a href="#os.path.exists"><strong>os.path.exists</strong></a>方法和该方法的一种常见创建多级目录方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text"># 错误的创建方法<br>if not os.path.exists(path):<br>    os.makedirs(path)<br></code></pre></td></tr></table></figure><p>这样的处理是错误的，在多线程或多进程环境中，即使在执行两个方法之间没有其他线程或进程修改文件系统，也同样存在着竞态条件：</p><p>假定存在线程A、B，线程A执行了<strong>os.path.exists</strong>方法后被操作系统中断——此时操作系统切换到线程B，因为path未存在，线程B执行了完整的<strong>os.path.exist</strong>和<strong>os.makedirs</strong>方法并创建了path目录——线程B被操作系统中断并切换到线程A，此时的A在执行<strong>os.makedirs</strong>方法时就会因path目录已存在而抛出异常，影响程序执行</p><p>解决的方法是设置<em><strong>exist_ok</strong></em>为True避免报错，且此目录一旦被创建，其他线程/进程希望创建此目录时能够发现此目录已存在，进而终止创建操作，保证创建时不会报错</p><p>同时，考虑到目录和文件可能同名影响创建，判断时最好使用<a href="#os.path.isdir"><strong>os.path.isdir</strong></a>方法判断<em><strong>name</strong></em>是否是一个目录：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"># 正确的创建方法<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(<span class="hljs-built_in">path</span>):<br><span class="hljs-built_in">os</span>.makedirs(<span class="hljs-built_in">path</span>, exist_ok = True)<br></code></pre></td></tr></table></figure><p><span id="os.mkdir"> </span></p><h3 id="4续osmkdir方法"><a href="#4续osmkdir方法" class="header-anchor">¶</a>4[续].os.mkdir方法：</h3><p>用途：创建单级目录，即对于多级目录的路径，只为最后一级目录创建</p><p>方法原型：<em><strong>os.makedirs(path [, mode=0o777])</strong></em></p><p>参数说明：</p><ul class="lvl-0"><li class="lvl-2"><p><em><strong>path</strong></em>：需要创建的目录路径，<a href="#os.StrOrBytesPath"><strong>StrOrBytesPath</strong></a>类型，可以是绝对路径/相对路径，该参数必须传递</p></li><li class="lvl-2"><p><em><strong>mode</strong></em>：和<a href="#os.makedirs"><strong>os.makedirs</strong></a>方法的mode相同</p></li></ul><p>返回值：无返回值</p><p>使用：</p><p>该方法的使用较简单，其创建只针对最后一级目录，如果最后一集目录的上级目录有任何一级不存在均会抛出<strong>FileNotFoundError</strong>错误(Windows下为<strong>WinError3</strong>)，如果已存在文件/目录与<em><strong>path</strong></em>对应，则抛出<strong>FileExistsError</strong>异常，否则正常创建目录，故一般先使用<a href="#os.path.isdir"><strong>os.path.isdir</strong></a>方法判断<em><strong>path</strong></em>是否是一个目录：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(<span class="hljs-built_in">path</span>):<br><span class="hljs-built_in">os</span>.mkdir(<span class="hljs-built_in">path</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——类(五)类装饰器</title>
    <link href="/xiaohei07.github.io/2023/07/23/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%BA%94)%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/xiaohei07.github.io/2023/07/23/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%BA%94)%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="八类装饰器"><a href="#八类装饰器" class="header-anchor">¶</a>（八）类装饰器</h3><p>在阅读本篇博客之前，需要对装饰器有一个基础的了解，请先阅读<a href="https://07xiaohei.com/2023/07/12/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%89)/">python进阶——函数(三) - ZZHの个人博客 (07xiaohei.com)</a>中关于函数的装饰器内容。</p><h4 id="1-把装饰器写在类里"><a href="#1-把装饰器写在类里" class="header-anchor">¶</a>1. 把装饰器写在类里：</h4><p>严格来说是函数装饰器的内容，只是作为装饰器的函数被写在了类中，同时用于修饰其他函数。</p><p>简单的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">debbug</span>(<span class="hljs-params">self,function</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_para</span>(<span class="hljs-params">*args,**kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start debbug&quot;</span>)<br>            function(*args,**kwargs)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;finish debbug&quot;</span>)<br>        <span class="hljs-keyword">return</span> get_para<br>t=test()<br><span class="hljs-meta">@t.debbug</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_test</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;add result:&quot;</span>,a+b)<br>add_test(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># start debbug</span><br><span class="hljs-comment"># add result: 7</span><br><span class="hljs-comment"># finish debbug</span><br></code></pre></td></tr></table></figure><p>注意，此时的实例方法因为没有实例化无法使用，所以必须先创建一个实例再将该实例的对应装饰器方法绑定给被装饰的函数。</p><p>实际上可以直接创建类方法跳过实例化步骤完成绑定，稍后会讲解。</p><p>除了装饰类外的函数，也可以装饰同一个类内的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i1=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.i2=<span class="hljs-number">12</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_para</span>(<span class="hljs-params">self,*args,**kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start info&quot;</span>)<br>            result =func(<span class="hljs-variable language_">self</span>, *args, **kwargs)<br>            <span class="hljs-variable language_">self</span>.i1 += <span class="hljs-number">10</span><br>            <span class="hljs-built_in">print</span>(result)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end info&quot;</span>)<br>            <span class="hljs-keyword">return</span> result<br>        <span class="hljs-keyword">return</span> get_para<br><span class="hljs-meta">    @info</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i1+<span class="hljs-variable language_">self</span>.i2<br>t=test()<br><span class="hljs-built_in">print</span>(t.i1)<br><span class="hljs-built_in">print</span>(t.func())<br><span class="hljs-built_in">print</span>(t.i1)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># start info</span><br><span class="hljs-comment"># 22</span><br><span class="hljs-comment"># end info</span><br><span class="hljs-comment"># 22</span><br><span class="hljs-comment"># 20</span><br></code></pre></td></tr></table></figure><h4 id="2-类作为装饰器使用"><a href="#2-类作为装饰器使用" class="header-anchor">¶</a>2. 类作为装饰器使用：</h4><p>类作为装饰器，需要保证已经定义了__call__方法，这样类才可以作为装饰器，并在装饰函数时运行__call__方法的内容——也就是把类中的__call__方法作为一个装饰器函数来使用了。</p><p>简单的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,func</span>):<br>        <span class="hljs-variable language_">self</span>.rate=<span class="hljs-number">0.8</span><br>        <span class="hljs-variable language_">self</span>.func=func<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self,*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;class decorator:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;class rate:&quot;</span>,<span class="hljs-variable language_">self</span>.rate)<br>        result =<span class="hljs-variable language_">self</span>.func(<span class="hljs-variable language_">self</span>.rate,*args,**kwargs)<br>        <span class="hljs-keyword">return</span> result<br><span class="hljs-meta">@test</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mulfunc</span>(<span class="hljs-params">r,a,b</span>):<br>    <span class="hljs-keyword">return</span> r*a*b<br>res=mulfunc(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(res)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># class decorator:</span><br><span class="hljs-comment"># class rate: 0.8</span><br><span class="hljs-comment"># 4.800000000000001</span><br></code></pre></td></tr></table></figure><p>__init__方法将函数进行了实例化，此时可以在任意位置使用self.func调用函数，但是只有在__call__中定义的方法会被装饰到函数中，同时也可以为其传入相关的参数。</p><p>除了装饰一般的函数，也可以用于装饰另一个类的方法——此时要将__call__方法修改为__get__方法，这相当于把另一个类的实例方法变成了属性，调用时不需要加()。</p><p>__get__方法涉及到了Python中的描述器机制，其机制比较复杂，这里不进行介绍，只是使用，如有兴趣可以自行了解，如果之后使用频繁也可能单开一篇博客讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,func</span>):<br>        <span class="hljs-variable language_">self</span>.rate=<span class="hljs-number">0.8</span><br>        <span class="hljs-variable language_">self</span>.func=func<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__get__</span>(<span class="hljs-params">self,otherself,owner,*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(otherself)<br>        <span class="hljs-built_in">print</span>(owner)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;class decorator:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;class rate:&quot;</span>, <span class="hljs-variable language_">self</span>.rate)<br>        result = <span class="hljs-variable language_">self</span>.func(otherself,<span class="hljs-variable language_">self</span>.rate,*args,**kwargs)<br>        <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">use_test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,a,b</span>):<br>        <span class="hljs-variable language_">self</span>.a=a<br>        <span class="hljs-variable language_">self</span>.b=b<br><span class="hljs-meta">    @test</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">use</span>(<span class="hljs-params">self,r</span>):<br>        <span class="hljs-keyword">return</span> r*<span class="hljs-variable language_">self</span>.a*<span class="hljs-variable language_">self</span>.b<br>ut=use_test(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(ut.use)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># &lt;__main__.use_test object at 0x0000014AD8A188D0&gt;</span><br><span class="hljs-comment"># &lt;class &#x27;__main__.use_test&#x27;&gt;</span><br><span class="hljs-comment"># class decorator:</span><br><span class="hljs-comment"># class rate: 0.8</span><br><span class="hljs-comment"># 9.600000000000001</span><br></code></pre></td></tr></table></figure><p>可以看到，另一个类的实例方法作为对象被传给了test，__get__方法的第一个参数是类自身，第二个otherself参数代表着实例化的对象，第三个owner代表实例的类本身，use方法被作为属性调用和输出了。</p><h4 id="3-为类增加装饰器"><a href="#3-为类增加装饰器" class="header-anchor">¶</a>3. 为类增加装饰器：</h4><p>类本身也可以增加装饰器，相当于在实例化开始进行了额外的操作。</p><p>可以用一个类或者函数作为装饰器。</p><p>函数作为装饰器，可以输出信息，可以为被装饰的类增加属性或者方法，甚至直接重写类。</p><p>类也可以直接作为装饰器修饰另一个类，注意要定义__call__方法。</p><p>简单的例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def function_add(func):<br>    def create_use(class_obj):<br>        <span class="hljs-built_in">print</span>(class_obj)<br>        class_obj.<span class="hljs-attribute">add_val</span>=10<br>        class_obj.<span class="hljs-attribute">add_func</span>=func<br>        return class_obj<br>    return create_use<br>def add_print(self,a,b):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a+b=&quot;</span>,a+b)<br>@function_add(add_print)<br>class test:<br>    pass<br><span class="hljs-attribute">t</span>=test()<br><span class="hljs-built_in">print</span>(t.add_val)<br>t.add_val+=10<br><span class="hljs-built_in">print</span>(t.add_val)<br>t.add_func(3,4)<br><span class="hljs-attribute">tt</span>=test()<br><span class="hljs-built_in">print</span>(tt.add_val)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &lt;class &#x27;__main__.test&#x27;&gt;</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># 20</span><br><span class="hljs-comment"># a+b= 7</span><br><span class="hljs-comment"># 10</span><br><br>def change_class(class_obj):<br>    class newclass:<br>        <span class="hljs-attribute">i</span>=10<br>    return newclass<br>@change_class<br>class test:<br>    <span class="hljs-attribute">i</span>=5<br><span class="hljs-attribute">t</span>=test()<br><span class="hljs-built_in">print</span>(t.i)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,class_obj</span>):<br>        <span class="hljs-built_in">print</span>(class_obj)<br>        <span class="hljs-variable language_">self</span>.class_obj=class_obj<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;传入args=&quot;</span>,args)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;create an animal!&quot;</span>)<br>        res =<span class="hljs-variable language_">self</span>.class_obj(*args, **kwargs)<br>        <span class="hljs-keyword">return</span>  res<br><span class="hljs-meta">@animal</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name</span>):<br>        <span class="hljs-variable language_">self</span>.name=name<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.name+<span class="hljs-string">&quot; is eating!&quot;</span>)<br>c=cat(<span class="hljs-string">&quot;小喵&quot;</span>)<br>c.eat()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &lt;class &#x27;__main__.cat&#x27;&gt;</span><br><span class="hljs-comment"># 传入args= (&#x27;小喵&#x27;,)</span><br><span class="hljs-comment"># create an animal!</span><br><span class="hljs-comment"># 小喵 is eating!</span><br></code></pre></td></tr></table></figure><h4 id="4-python内置常用装饰器"><a href="#4-python内置常用装饰器" class="header-anchor">¶</a>4. Python内置常用装饰器：</h4><p>内置的装饰器和普通装饰器的原理是一样的，但返回的不是函数，而是类对象。</p><p>下面对最常用的五个装饰器分别进行阐述。</p><h5 id="1abstractmethod"><a href="#1abstractmethod" class="header-anchor">¶</a>（1）@abstractmethod：</h5><p>如果学习过c++语言的话，会知道一个叫做&quot;抽象类&quot;的概念，这种类不能被直接创建对象，必须被继承且实现了对应的虚函数才能创建，Python中实现这一机制就是通过@abstractmethod这个装饰器完成的。</p><p>@abstractmethod用于对程序接口的控制，含有@abstractmethod的基类不能实例化，继承的派生类必须实现@abstractmethod装饰的方法。</p><p>使用@abstractmethod需要内置库abc，abc提供了抽象类ABC和@abstractmethod装饰器，想要使用抽象类必须直接或者间接继承ABC才能定义。</p><p>简单的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC,abstractmethod<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">abs_class</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,i</span>):<br>        <span class="hljs-variable language_">self</span>.i=i<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span>(<span class="hljs-title class_ inherited__">abs_class</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span>(<span class="hljs-title class_ inherited__">abs_class</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">testt</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;testt&quot;</span>)<br></code></pre></td></tr></table></figure><p>定义的abs_class为抽象基类，son1和son2是抽象类的派生类，son1完成了test方法的覆盖，son2则没有。</p><p>因此，实例化abc_class和son2均会报错。</p><p>错误如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">a =abs_class()<br># <span class="hljs-type">Traceback</span> (most recent call last):<br>#   <span class="hljs-type">File</span> <span class="hljs-string">&quot;D:\pycharmwork\blog_use.py&quot;</span>, line <span class="hljs-number">3799</span>, in &lt;module&gt;<br>#     a =abs_class()<br>#        ^^^^^^^^^^^<br># <span class="hljs-type">TypeError</span>: <span class="hljs-type">Can</span>&#x27;t instantiate <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">abs_class</span> <span class="hljs-keyword">with</span> <span class="hljs-title">abstract</span> <span class="hljs-title">method</span> <span class="hljs-title">test</span></span><br><br>s2=son2()<br># <span class="hljs-type">Traceback</span> (most recent call last):<br>#   <span class="hljs-type">File</span> <span class="hljs-string">&quot;D:\pycharmwork\blog_use.py&quot;</span>, line <span class="hljs-number">3805</span>, in &lt;module&gt;<br>#     s2=son2()<br>#        ^^^^^^<br># <span class="hljs-type">TypeError</span>: <span class="hljs-type">Can</span>&#x27;t instantiate <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">son2</span> <span class="hljs-keyword">with</span> <span class="hljs-title">abstract</span> <span class="hljs-title">method</span> <span class="hljs-title">test</span></span><br><br>s1=son1(<span class="hljs-number">5</span>)<br>s1.test()<br># 运行结果：<br># test<br></code></pre></td></tr></table></figure><p>​</p><h5 id="2property"><a href="#2property" class="header-anchor">¶</a>（2）@property：</h5><p>property用于装饰方法，被装饰的方法不可在类被实例化后被调用，只能通过访问与函数同名的属性进行调用——相当于把方法伪装成了一个属性。</p><p>伪装的属性和普通属性不同，需要自行实现一个实例属性的get、set和delete的内部逻辑，此实现是通过属性的装饰器setter、getter和deleter完成的。</p><p>getter装饰器和不带getter的属性装饰器效果一致，所以可以不定义getter装饰器。</p><p>而没有实现setter或者deleter的话，是一个只读属性，可以用于Python的安全访问。</p><p>@property将返回的函数变味了一个property对象。</p><p>被装饰的方法内部可以实现处理逻辑，对外又提供统一的调用方式。</p><p>简单的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,i</span>):<br>        <span class="hljs-variable language_">self</span>.number1=i<br>        <span class="hljs-variable language_">self</span>.number2=i*i<br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">num</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.number1<br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">num2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.number2<br><span class="hljs-meta">    @num2.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">num2</span>(<span class="hljs-params">self,temp</span>):<br>        <span class="hljs-variable language_">self</span>.number2=temp<br><span class="hljs-meta">    @num2.deleter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">num2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.number2<br><br>t=test(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(t.num)<br><span class="hljs-built_in">print</span>(t.num2)<br>t.num2+=<span class="hljs-number">20</span><br><span class="hljs-built_in">print</span>(t.num2)<br><span class="hljs-built_in">print</span>(t.__dict__)<br><span class="hljs-keyword">del</span> t.num2<br><span class="hljs-built_in">print</span>(t.__dict__)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 5</span><br><span class="hljs-comment"># 25</span><br><span class="hljs-comment"># 45</span><br><span class="hljs-comment"># &#123;&#x27;number1&#x27;: 5, &#x27;number2&#x27;: 45&#125;</span><br><span class="hljs-comment"># &#123;&#x27;number1&#x27;: 5&#125;</span><br></code></pre></td></tr></table></figure><p>上述代码中，num方法伪装成了属性，对应的是number1属性，此时没有定义setter和deleter的装饰器，所以不能修改和删除该属性，只读；而num2方法伪装成属性时定义了两个装饰器，这导致了number2属性的值可以被修改或者删除。</p><h5 id="3staticmethod"><a href="#3staticmethod" class="header-anchor">¶</a>（3）@staticmethod：</h5><p>是把函数嵌入到类中的一种方式，增加@staticmethod的类函数被声明为类的静态函数，静态函数是独立于类的，不需要类的实例化就可以直接被调用，也因此被装饰的函数不需要代表对象实例的self参数。</p><p>可以把这种函数看作是寄存在类名下的普通函数。</p><p>类似于c++中的静态成员函数。</p><p>简单的例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class test:<br>    <span class="hljs-attribute">j</span>=100<br>    def __init__(self):<br>        self.<span class="hljs-attribute">i</span>=100<br>    @staticmethod<br>    def outertest(class_obj):<br>        <span class="hljs-built_in">print</span>(class_obj.j)<br>class test2:<br>    <span class="hljs-attribute">j</span>=200<br><span class="hljs-attribute">t</span>=test()<br><span class="hljs-attribute">t2</span>=test2()<br>t.outertest(t)<br>t.outertest(t2)<br>test.outertest(t)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 100</span><br><span class="hljs-comment"># 200</span><br><span class="hljs-comment"># 100</span><br></code></pre></td></tr></table></figure><p>可以看到，outertest函数的可以不通过实例，也可以利用实例，不能直接调用和使用类内的属性，仍然需要传入类实例对象才可以完成对属性的操作，而且没有self参数，也可以传入其他类实例对象完成操作。</p><p>如果想要完成不实例化就操作类的类属性（实例属性一定要实例化），需要配合类方法完成。</p><p>下面介绍类方法。</p><h5 id="4classmethod"><a href="#4classmethod" class="header-anchor">¶</a>（4）@classmethod：</h5><p>被@classmethod装饰的方法是类方法，类方法的调用可以通过类，也可以通过实例。</p><p>类方法只是用于类的，只能访问类属性，并完成一定的处理，不能访问实例属性。</p><p>这种方法必须有一个参数，一般用cls命名，代表类本身，调用时第一个参数隐性传递该参数，不需要主动传入。</p><p>同样类似于c++中的静态成员函数。</p><p>@classmethod和@staticmethod区别主要在于，前者主要用于该类的静态属性的操作，而后者则是与实例无关但与类的封装功能有关的函数。</p><p>简单的例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class test:<br>    <span class="hljs-attribute">i</span>=10<br>    @classmethod<br>    def square_i(cls):<br>        cls.<span class="hljs-attribute">i</span>=cls.i**2<br>        return cls.i<br><span class="hljs-built_in">print</span>(test().square_i())<br><span class="hljs-attribute">t</span>=test()<br><span class="hljs-built_in">print</span>(t.square_i())<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 100</span><br><span class="hljs-comment"># 10000</span><br></code></pre></td></tr></table></figure><p>可以把@classmethod的方法和@staticmethod的函数联合使用完成一些特定功能。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class test:<br>    <span class="hljs-attribute">i</span>=10<br>    def __init__(self):<br>        self.<span class="hljs-attribute">j</span>=100<br>    @classmethod<br>    def square_i(cls):<br>        cls.<span class="hljs-attribute">i</span>=cls.i**2<br>        return cls.i<br>    @staticmethod<br>    def test_use(class_name):<br>        return test.square_i()<span class="hljs-number">*c</span>lass_name.j<br>class test2:<br>    <span class="hljs-attribute">j</span>=200<br><span class="hljs-attribute">t</span>=test()<br><span class="hljs-attribute">t2</span>=test2()<br><span class="hljs-built_in">print</span>(test.test_use(t))<br><span class="hljs-built_in">print</span>(test.test_use(t2))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 10000</span><br><span class="hljs-comment"># 2000000</span><br></code></pre></td></tr></table></figure><h5 id="5wraps"><a href="#5wraps" class="header-anchor">¶</a>（5）@wraps：</h5><p>先来看一段简单的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">debbug</span>(<span class="hljs-params">func</span>):<br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_para</span>(<span class="hljs-params">*args,**kwargs</span>):<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start debbug&quot;</span>)<br>       result =func(*args,**kwargs)<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end debbug&quot;</span>)<br>       <span class="hljs-keyword">return</span> result<br>   <span class="hljs-keyword">return</span> get_para<br><span class="hljs-meta">@debbug</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">use_de</span>():<br>    <span class="hljs-built_in">print</span>(use_de.__name__)<br>use_de()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># start debbug</span><br><span class="hljs-comment"># get_para</span><br><span class="hljs-comment"># end debbug</span><br></code></pre></td></tr></table></figure><p>装饰器在修饰函数时，可以看到，use_de的__name__名称并不是use_de，而是get_para，说明装饰器&quot;污染&quot;了被装饰函数的属性，被装饰函数的函数名和属性是属于新函数的。</p><p>因此，为了保证被装饰器修饰后的函数还有原来的属性，需要使用functools.wraps装饰器来保证被装饰函数的函数名和属性不会发生改变。</p><p>修改的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">debbug</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_para</span>(<span class="hljs-params">*args,**kwargs</span>):<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;start debbug&quot;</span>)<br>       result =func(*args,**kwargs)<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;end debbug&quot;</span>)<br>       <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> get_para<br><span class="hljs-meta">@debbug</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">use_de</span>():<br>    <span class="hljs-built_in">print</span>(use_de.__name__)<br>use_de()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># start debbug</span><br><span class="hljs-comment"># get_para</span><br><span class="hljs-comment"># end debbug</span><br></code></pre></td></tr></table></figure><p>可以看到，结果发生了改变。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——类(四)常用内置方法</title>
    <link href="/xiaohei07.github.io/2023/07/23/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E5%9B%9B)%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/xiaohei07.github.io/2023/07/23/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E5%9B%9B)%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="七常用内置方法"><a href="#七常用内置方法" class="header-anchor">¶</a>（七）常用内置方法</h3><h4 id="1-简介"><a href="#1-简介" class="header-anchor">¶</a>1. 简介：</h4><p>这里介绍的常用内置方法主要是对类的一些相关用法的补充，便于解决创建类遇到的一些常见问题，同时对其进行简单演示来表示其具体的应用场景。</p><p>__init__方法不再介绍，前面的使用和介绍已经非常详细了。</p><ul class="lvl-0"><li class="lvl-2"><p>__str__()和__repr__()：</p><p>这两个方法的目的使为了显式的显示对象的必要信息，方便查看和调试。</p><p>__str__()被print默认调用，控制用户的展示；而__repr__被控制台输出默认调用,控制调试的展示。</p><ul class="lvl-2"><li class="lvl-4"><p>__str__用于表示对象代表的含义，返回一个字符串，可以根据需要返回一个实例转化成字符串之后的结果。</p><p>具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">exmp</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.x=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.y=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__class__&#125;</span>:x=<span class="hljs-subst">&#123;self.x&#125;</span>,y=<span class="hljs-subst">&#123;self.y&#125;</span>&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">exmp2</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.x=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.y=<span class="hljs-number">2</span><br>e=exmp()<br>e2=exmp2()<br><span class="hljs-built_in">print</span>(e)<br><span class="hljs-built_in">print</span>(e2)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># &lt;class &#x27;__main__.exmp&#x27;&gt;:x=1,y=2</span><br><span class="hljs-comment"># &lt;__main__.exmp2 object at 0x0000017336228210&gt;</span><br></code></pre></td></tr></table></figure><p>能够看出输出实例时的内容发生了改变。</p></li><li class="lvl-4"><p>__repr__的用途和用法都与__str__类似，所以一般直接使用__repr__= __str__将其返回字符串复制给__repr__</p><p>如果为使用者和开发者提供的信息不一致，再单独定义__repr__即可。</p><p>简单例子如下（）此为控制台的输入和输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">exmp3</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.x=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.y=<span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__class__&#125;</span>:x=<span class="hljs-subst">&#123;self.x&#125;</span>,y=<span class="hljs-subst">&#123;self.y&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__repr__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.__class__&#125;</span>:x=<span class="hljs-subst">&#123;self.x&#125;</span>,y=<span class="hljs-subst">&#123;self.y&#125;</span>&#x27;</span>+<span class="hljs-string">&#x27;——repr&#x27;</span><br>    <br>e=exmp3()<br>e<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.exmp3&#x27;</span>&gt;:x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>——<span class="hljs-built_in">repr</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>__call__()：</p><p>不管是内置函数还是自定以函数，函数实际上是实现了__call__方法的对象，这是可调用对象的一种——调用函数时，&quot;名称()&quot;实际上等价于&quot;名称.__call__()&quot;的写法。</p><p>其他的可调用对象还包括Python的实例对象和实例方法。</p><p>__call__方法除了函数以外，也可以给实例对象提供被执行的能力，也就是将实例对象转变为一个可调用对象，其实际功能效果类似于在类中重载了()运算符，使得类的实例对象可以以&quot;对象名()&quot;的形式使用。</p><p>实现了__call__方法的类实例，可以传入参数也可以返回值。</p><p>具体例子如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">exmp</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">__init__</span>(self,a):<br>        self.a=a<br>    def __call__(self,b):<br>        print(<span class="hljs-string">&quot;a=&quot;</span>,self.a)<br>        print(<span class="hljs-string">&quot;b=&quot;</span>,b)<br>        print(<span class="hljs-string">&quot;a+b=&quot;</span>,self.a+b)<br>        <span class="hljs-keyword">return</span> self.a+b<br>e=exmp(<span class="hljs-number">10</span>)<br>result=e(<span class="hljs-number">20</span>)<br>print(result)<br>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(i)</span></span>:<br>    print(<span class="hljs-string">&quot;fun&quot;</span>,i)<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span><br><span class="hljs-keyword">fun</span>.__call__(<span class="hljs-number">20</span>)<br># 运行结果:<br># a= <span class="hljs-number">10</span><br># b= <span class="hljs-number">20</span><br># a+b= <span class="hljs-number">30</span><br># <span class="hljs-number">30</span><br># <span class="hljs-function"><span class="hljs-keyword">fun</span> 10</span><br># <span class="hljs-function"><span class="hljs-keyword">fun</span> 20</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>__iter__()和__next__()：</p><p>这两个方法的具体内容在<a href="https://07xiaohei.com/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%BA%8C)%E8%BF%AD%E4%BB%A3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/">python进阶——高级特性(二)迭代、迭代器 - ZZHの个人博客 (07xiaohei.com)</a>种已经进行了详细的介绍，这里只进行简要介绍。</p><p>这两个方法用于将一个对象模拟成序列，内部类型如列表、元组等都可以迭代，重写这两个方法就可以实现自定义的迭代对象。__iter__方法向系统说明了这是一个可迭代对象，__next__方法向系统说明了该可迭代对象的迭代算法。</p><p>__iter__方法需要返回self，__next__方法需要返回对应的元素。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Myfib:<br>    def __iter__(self):<br>        self.<span class="hljs-attribute">i1</span>=0<br>        self.<span class="hljs-attribute">i2</span>=1<br>        return self<br>    def __next__(self):<br>        <span class="hljs-attribute">result</span>=self.i1+self.i2<br>        self.<span class="hljs-attribute">i1</span>=self.i2<br>        self.<span class="hljs-attribute">i2</span>=result<br>        return result<br><span class="hljs-attribute">use_fib</span>=Myfib()<br>j = 1<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> use_fib:<br>    <span class="hljs-keyword">if</span> i&lt;100000:<br>        <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br>        j+=1<br>    <span class="hljs-keyword">else</span>:<br>        break<br>    <span class="hljs-keyword">if</span> <span class="hljs-attribute">j</span>==10:<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-attribute">j</span>=1<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 1 2 3 5 8 13 21 34 55</span><br><span class="hljs-comment"># 89 144 233 377 610 987 1597 2584 4181</span><br><span class="hljs-comment"># 6765 10946 17711 28657 46368 75025</span><br></code></pre></td></tr></table></figure><p>再举一个例子，写一个首项为10，公差为5的等差数列：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mysequence</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>se=<span class="hljs-title class_">Mysequence</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-symbol">se:</span><br>    <span class="hljs-keyword">if</span> i&lt;=<span class="hljs-number">100</span>:<br>        print(i,<span class="hljs-keyword">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-symbol">else:</span><br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>__getitem__()，__setitem__()，__delitem__()：</p><p>__getitem__()方法把类中的属性定义为序列或者字典，并且可以用此方法输出其中的某个元素，其效果类似于重载[]运算符给类，可以通过&quot;实例名[索引]/[切片]&quot;的方式来访问实例对象的某个元素。</p><p>对于传入的是索引还是切片，可以通过isinstance函数判断。</p><p>判断是索引，使用ininstance(item,int)判断item是否为int类型，确定其是否为数字索引；使用ininstance(item,slice)判断其是否为切片；使用ininstance(item,str)等判断其是否为key。</p><p>具体的例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mynumlist</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.list_use=[]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.list_use.append(<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-variable language_">self</span>.list_use.append(<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.list_use[item]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">slice</span>):<br>            start=item.start<br>            stop=item.stop<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.list_use[start:stop]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>mn=mynumlist()<br>y=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mn:<br>    <span class="hljs-keyword">if</span> y!=<span class="hljs-number">30</span>:<br>        y+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">10</span>])<br><span class="hljs-built_in">print</span>(mn[:])<br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">2</span>:<span class="hljs-number">10</span>])<br><span class="hljs-built_in">print</span>(mn[-<span class="hljs-number">8</span>:-<span class="hljs-number">2</span>])<br><span class="hljs-built_in">print</span>(mn[<span class="hljs-string">&quot;1&quot;</span>])<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160</span><br><span class="hljs-comment"># 60</span><br><span class="hljs-comment"># [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, 105, 110, 115, 120, 125, 130, 135, 140, 145, 150, 155, 160, 165]</span><br><span class="hljs-comment"># [20, 25, 30, 35, 40, 45, 50, 55]</span><br><span class="hljs-comment"># [130, 135, 140, 145, 150, 155]</span><br><span class="hljs-comment"># error</span><br></code></pre></td></tr></table></figure><p>除了上面的列表，还可以是字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mydic</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.dirc_use=&#123;&#125;<br>        <span class="hljs-variable language_">self</span>.index=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.dirc_use[<span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.index)]=<span class="hljs-variable language_">self</span>.i<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.index+=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-variable language_">self</span>.dirc_use[<span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.index)] = <span class="hljs-variable language_">self</span>.i<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dirc_use.get(item)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>md=mydic()<br>y=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> md:<br>    <span class="hljs-keyword">if</span> y!=<span class="hljs-number">30</span>:<br>        y+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;1&quot;</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;10&quot;</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-number">8</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;1000&quot;</span>])<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># 55</span><br><span class="hljs-comment"># error</span><br><span class="hljs-comment"># None</span><br></code></pre></td></tr></table></figure><p>可以自行定义更具体的判断条件和处理方法。</p><p>__setitem__方法则是对上面某个使用索引内值的修改，可以让类按照一定的方法存储和映射key对应的value，该方法的赋值是通过类实例名直接完成的。</p><p>具体例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mynumlist</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.list_use=[]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.list_use.append(<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-variable language_">self</span>.list_use.append(<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.list_use[item]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">slice</span>):<br>            start=item.start<br>            stop=item.stop<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.list_use[start:stop]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-variable language_">self</span>.list_use[key]=value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>mn=mynumlist()<br>y=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mn:<br>    <span class="hljs-keyword">if</span> y!=<span class="hljs-number">30</span>:<br>        y+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">10</span>])<br>mn[<span class="hljs-number">10</span>]=<span class="hljs-number">114514</span><br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">8</span>:<span class="hljs-number">11</span>])<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160</span><br><span class="hljs-comment"># 60</span><br><span class="hljs-comment"># [50, 55, 114514]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mydic</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.dirc_use=&#123;&#125;<br>        <span class="hljs-variable language_">self</span>.index=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.dirc_use[<span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.index)]=<span class="hljs-variable language_">self</span>.i<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.index+=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-variable language_">self</span>.dirc_use[<span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.index)] = <span class="hljs-variable language_">self</span>.i<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dirc_use.get(item)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key,<span class="hljs-built_in">str</span>):<br>            <span class="hljs-variable language_">self</span>.dirc_use[key]=value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>md=mydic()<br>y=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> md:<br>    <span class="hljs-keyword">if</span> y!=<span class="hljs-number">30</span>:<br>        y+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;1&quot;</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-number">8</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;1000&quot;</span>])<br>md[<span class="hljs-string">&quot;3&quot;</span>]=<span class="hljs-string">&quot;123456789&quot;</span><br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;3&quot;</span>])<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># error</span><br><span class="hljs-comment"># None</span><br><span class="hljs-comment"># 123456789</span><br></code></pre></td></tr></table></figure><p>__delitem__方法在对对象的组成部分使用__del__语句的时候被调用，需删除与key相关联的值。</p><p>举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mynumlist</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.list_use=[]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.list_use.append(<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-variable language_">self</span>.list_use.append(<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.list_use[item]<br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">slice</span>):<br>            start=item.start<br>            stop=item.stop<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.list_use[start:stop]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-variable language_">self</span>.list_use[key]=value<br>        <span class="hljs-keyword">else</span>:<br>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.list_use[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>mn=mynumlist()<br>y=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> mn:<br>    <span class="hljs-keyword">if</span> y!=<span class="hljs-number">30</span>:<br>        y+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">10</span>])<br>mn[<span class="hljs-number">10</span>]=<span class="hljs-number">114514</span><br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">8</span>:<span class="hljs-number">11</span>])<br><span class="hljs-keyword">del</span> mn[<span class="hljs-number">10</span>]<br><span class="hljs-built_in">print</span>(mn[<span class="hljs-number">8</span>:<span class="hljs-number">11</span>])<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160</span><br><span class="hljs-comment"># 60</span><br><span class="hljs-comment"># [50, 55, 114514]</span><br><span class="hljs-comment"># [50, 55, 65]</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">mydic</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.dirc_use=&#123;&#125;<br>        <span class="hljs-variable language_">self</span>.index=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__iter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.i=<span class="hljs-number">10</span><br>        <span class="hljs-variable language_">self</span>.dirc_use[<span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.index)]=<span class="hljs-variable language_">self</span>.i<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__next__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.index+=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.i+=<span class="hljs-number">5</span><br>        <span class="hljs-variable language_">self</span>.dirc_use[<span class="hljs-built_in">str</span>(<span class="hljs-variable language_">self</span>.index)] = <span class="hljs-variable language_">self</span>.i<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.i<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(item,<span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.dirc_use.get(item)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setitem__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key,<span class="hljs-built_in">str</span>):<br>            <span class="hljs-variable language_">self</span>.dirc_use[key]=value<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delitem__</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">str</span>):<br>            <span class="hljs-keyword">del</span> <span class="hljs-variable language_">self</span>.dirc_use[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br>md=mydic()<br>y=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> md:<br>    <span class="hljs-keyword">if</span> y!=<span class="hljs-number">30</span>:<br>        y+=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;1&quot;</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-number">8</span>])<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;1000&quot;</span>])<br>md[<span class="hljs-string">&quot;3&quot;</span>]=<span class="hljs-string">&quot;123456789&quot;</span><br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;3&quot;</span>])<br><span class="hljs-keyword">del</span> md[<span class="hljs-string">&quot;3&quot;</span>]<br><span class="hljs-built_in">print</span>(md[<span class="hljs-string">&quot;3&quot;</span>])<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># error</span><br><span class="hljs-comment"># None</span><br><span class="hljs-comment"># 123456789</span><br><span class="hljs-comment"># None</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>__slots__：</p><p>__slots__是一个类属性，可以赋值为字符串、可迭代对象或由实例使用的变量名构成的字符串序列。</p><p>__slots__允许显式声明数据成员，为已声明的变量保留空间，限制能够添加的属性名（也就是禁止为每个实例创建__dict__和__weakref__）。</p><p>通过阻止每个实例创建自己的__dict__而使用__slots__，在大量创建实例时，可以显著地节省内存空间并提升属性的查找速度。</p><p>——本质上，__dict__是哈希表结构，动态占用内存，开销大，而__slots__能够在编译时期使解释器确定属性，分配固定的空间存储已知的属性。</p><p>__slots__仅对当前类实例起作用，不会对继承的派生类起作用，需要派生类定义自己的__slots__。</p><p>例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class test:<br>    __slots__ = (<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)<br>    def __init__(self):<br>        self.<span class="hljs-attribute">a</span>=1<br>        self.<span class="hljs-attribute">b</span>=2<br>        self.<span class="hljs-attribute">c</span>=3<br>        self.<span class="hljs-attribute">d</span>=10<br><span class="hljs-attribute">t</span>=test()<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 3587, in &lt;module&gt;</span><br><span class="hljs-comment">#     t=test()</span><br><span class="hljs-comment">#       ^^^^^^</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 3586, in __init__</span><br><span class="hljs-comment">#     self.d=10</span><br><span class="hljs-comment">#     ^^^^^^</span><br><span class="hljs-comment"># AttributeError: &#x27;test&#x27; object has no attribute &#x27;d&#x27;</span><br></code></pre></td></tr></table></figure><p>可以看到，只有abc的属性名可以使用，其他的属性名使用均错误。</p></li><li class="lvl-2"><p>__getattr__()，__setattr__()，__delattr__()：</p><p>__getattr__方法用于处理访问不存在属性的方法，可以输出相关的异常信息。</p><p>__setattr__方法用于设置属性值的时候，每设置一次属性的值都要进入一次该方法，注意该方法不要递归调用，也不要在该方法种再次直接设置属性值，否则可能会造成死循环。</p><p>__delattr__方法用于删除属性值的时候，也要注意避开死循环。</p><p>使用的举例如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class test:<br>    def __init__(self):<br>        self.<span class="hljs-attribute">i</span>=1<br>    def __getattr__(self, item):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Don&#x27;t get!&quot;</span>)<br>        return <span class="hljs-literal">False</span><br>    def __setattr__(self, key, value):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Setting...&quot;</span>)<br>        self.__dict__[key]=value<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Finish!&quot;</span>)<br>    def __delattr__(self, item):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Deling...&quot;</span>)<br>        <span class="hljs-keyword">if</span> self.__dict__.<span class="hljs-built_in">get</span>(item):<br>            del self.__dict__[item]<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Successful!&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Failed!&quot;</span>)<br><span class="hljs-attribute">t</span>=test()<br>t.<span class="hljs-attribute">i</span>=5<br><span class="hljs-built_in">print</span>(t.i)<br>t.<span class="hljs-attribute">j</span>=10<br><span class="hljs-built_in">print</span>(t.j)<br><span class="hljs-built_in">print</span>(t.z)<br>del t.i<br>del t.z<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># Setting...</span><br><span class="hljs-comment"># Finish!</span><br><span class="hljs-comment"># Setting...</span><br><span class="hljs-comment"># Finish!</span><br><span class="hljs-comment"># 5</span><br><span class="hljs-comment"># Setting...</span><br><span class="hljs-comment"># Finish!</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># Don&#x27;t get!</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># Deling...</span><br><span class="hljs-comment"># Successful!</span><br><span class="hljs-comment"># Deling...</span><br><span class="hljs-comment"># Failed!</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——类(三)方法重写、多态</title>
    <link href="/xiaohei07.github.io/2023/07/23/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%B8%89)%E6%96%B9%E6%B3%95%E9%87%8D%E7%94%A8%E3%80%81%E5%A4%9A%E6%80%81/"/>
    <url>/xiaohei07.github.io/2023/07/23/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%B8%89)%E6%96%B9%E6%B3%95%E9%87%8D%E7%94%A8%E3%80%81%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h3 id="五方法重写"><a href="#五方法重写" class="header-anchor">¶</a>（五）方法重写</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念</h4><p>继承是对基类的完全继承，但是很多时候基类的方法并不能完全适用于派生类，此时需要对派生类继承的方法进行重写(override)。</p><p>方法重写是在派生类中定义一个和基类的同名方法，方法内部的代码块被重新实现，重写后的运行只会运行重写完成的方法，而不会调用基类的同名方法。</p><h4 id="2-分类"><a href="#2-分类" class="header-anchor">¶</a>2. 分类：</h4><p>方法重写包括覆盖和扩展两种方法。</p><h5 id="1覆盖基类方法"><a href="#1覆盖基类方法" class="header-anchor">¶</a>（1）覆盖基类方法：</h5><p>当基类的方法实现与派生类的方法实现完全不同时，可以通过覆盖直接重新编写。</p><p>重写实际上就相当于派生类正常实现方法，只是该方法会导致继承而来的方法不再能够被调用。</p><p>简单的例子如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">fun</span>(self):<br>        print(<span class="hljs-string">&quot;father&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>(father):<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;son&quot;</span>)<br>s=son()<br>s.<span class="hljs-keyword">fun</span>()<br># 运行结果：<br># son<br><br></code></pre></td></tr></table></figure><p>对于__init__方法，派生类在不重写的情况下自动继承（继承顺序按上一篇博客决定），重写后也会发生覆盖，所以要注意此时的调用会无法访问基类__init__方法定义的属性。</p><h5 id="2扩展"><a href="#2扩展" class="header-anchor">¶</a>（2）扩展：</h5><p>当派生类除了自身功能外，还需要基类的方法提供的功能，也就是派生类的方法实现包含基类的方法实现，可以通过扩展完成重写。</p><p>扩展实际上就是覆盖，但是扩展在重写时使用super().基类方法完成调用基类方法，以此方式使基类方法成为了派生类方法的一部分。</p><p>也可以使用父类名.方法(self)完成调用基类方法，但不推荐使用。</p><p>简单的例子如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">fun</span>(self):<br>        print(<span class="hljs-string">&quot;father&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>(father):<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        <span class="hljs-keyword">super</span>().<span class="hljs-keyword">fun</span>()<br>        print(<span class="hljs-string">&quot;son&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span>(father):<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        father.<span class="hljs-keyword">fun</span>(self)<br>        print(<span class="hljs-string">&quot;son2&quot;</span>)<br>s=son()<br>s2=son2()<br>s.<span class="hljs-keyword">fun</span>()<br>s2.<span class="hljs-keyword">fun</span>()<br># 运行结果：<br># father<br># son<br># father<br># son2<br></code></pre></td></tr></table></figure><h3 id="六多态"><a href="#六多态" class="header-anchor">¶</a>（六）多态</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>多态包括多态和多态性。</p><p>多态是指一类事物具有多种形态，可以用单个类型的实体来表示不同场景中的不同类型——其对应的表现为不同的对象调用同一个接口，表示出了不同的状态。</p><p>多态性是指不同功能的函数可以使用相同的函数名，也就是用一个函数名调用不同功能的函数。</p><p>最直接的表现就是定义一个函数传入对象，通过方法名调用对象的某个方法，这样就可以根据不同对象调用不同方法了。</p><p>多态是在继承的基础上讨论的，多态必须发生在基类和派生类之间；多态要求必须发生方法重写——当然，即使对象所属的类之间没有继承关系也可以使用多态（不过多数时候这样的行为没有意义）。</p><p>多态只关心对象的实例方法是否同名，不关心对象所属类型。</p><p>多态实质就是：<strong>一个接口，多种实现</strong>。</p><h4 id="2-优点"><a href="#2-优点" class="header-anchor">¶</a>2. 优点：</h4><ul class="lvl-0"><li class="lvl-2"><p>增加了程序的灵活性，增加了代码外部调用的灵活度，使其的通用性比较强。</p></li><li class="lvl-2"><p>增加了程序的可扩展性，可以为已有接口建立新的实现。</p></li><li class="lvl-2"><p>多态是调用的技巧，不会影响类的内部设计。</p></li></ul><h4 id="3-应用"><a href="#3-应用" class="header-anchor">¶</a>3. 应用：</h4><ul class="lvl-0"><li class="lvl-2"><p>对象所属的类之间没有继承关系，可以使用多态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am dog&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am cat&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bird</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am bird&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">funwho</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):<br>    <span class="hljs-built_in">object</span>.who()<br>d=dog()<br>c=cat()<br>b=bird()<br>funwho(d)<br>funwho(c)<br>funwho(b)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># I am dog</span><br><span class="hljs-comment"># I am cat</span><br><span class="hljs-comment"># I am bird</span><br></code></pre></td></tr></table></figure><p>用funwho函数调用传入对象的who方法，通过不同对象表现出了不同结果。</p><p>扩展时不需要修改已有的内容，只需要定义新类和新方法，然后直接调用即可，便于扩展。</p></li><li class="lvl-2"><p>有继承关系，可以使用，应用更广泛：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am an animal&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dog</span>(<span class="hljs-title class_ inherited__">animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().who()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am dog&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>(<span class="hljs-title class_ inherited__">animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().who()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am cat&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bird</span>(<span class="hljs-title class_ inherited__">animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">who</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().who()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am bird&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">funwho</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):<br>    <span class="hljs-built_in">object</span>.who()<br>a=animal()<br>d=dog()<br>c=cat()<br>b=bird()<br>funwho(a)<br>funwho(d)<br>funwho(c)<br>funwho(b)<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># I am an animal</span><br><span class="hljs-comment"># I am an animal</span><br><span class="hljs-comment"># I am dog</span><br><span class="hljs-comment"># I am an animal</span><br><span class="hljs-comment"># I am cat</span><br><span class="hljs-comment"># I am an animal</span><br><span class="hljs-comment"># I am bird</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-鸭子类型"><a href="#4-鸭子类型" class="header-anchor">¶</a>4. 鸭子类型：</h4><p>实际上，python的多态并不是显式支持的，其多态更像是python强大功能的体现之一，python对于动态类型的使用更多的是鸭子类型（Duck Typing）。</p><p>鸭子类型是程序设计中动态类型的一种风格，在这种风格中，一个对象的有效语义，不是由继承自特定类或者实现特定接口决定，而是由当前方法和属性的集合决定。</p><p>鸭子类型实际上可以由James Whitcomb Riley的鸭子测试来表述：</p><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p><p>鸭子类型中，关注的不是对象类型本身，而是对象的用法。</p><p>鸭子类型的表现形式就是上面所谓“多态”的表现形式，函数不会检查对象的类型，而是只关注其是否有相关的方法，有的话即可正确调用。</p><p>比起多态，鸭子类型更符合Python的&quot;一切接对象&quot;的设计理念。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——模块化(二)模块和包</title>
    <link href="/xiaohei07.github.io/2023/07/15/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%BA%8C)%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <url>/xiaohei07.github.io/2023/07/15/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%BA%8C)%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="三模块module"><a href="#三模块module" class="header-anchor">¶</a>（三）模块(Module)</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>Python中的模块，是一个Python的文件，以&quot;.py&quot;为后缀，其余部分作为模块名称，包括Python的对象定义和Python的一组可执行代码语句（函数和类）。</p><p>一个模块对应了一组特定的功能，一些定义的对象或者变量使用。</p><p>模块是按照逻辑组织Python代码的方法，文件是按照物理组织模块内Python代码的方法——因此，一个文件被看作是一个独立模块，一个模块可以被看作是一个文件，<a href="http://%E6%A8%A1%E5%9D%97%E6%96%87%E4%BB%B6%E5%90%8D=%E6%A8%A1%E5%9D%97%E5%90%8D+.py">模块文件名=模块名+.py</a>。</p><p>模块的名称实际上就存储在全局变量__name__中，以字符串表示。</p><p>可以通过导入sys库调用其modules功能来获得__name__的对应模块名。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> sys<br>print(sys.modules[__name__])<br># 运行结果：<br># &lt;<span class="hljs-keyword">module</span> <span class="hljs-string">&#x27;__main__&#x27;</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;D:\\pycharmwork\\blog_use.py&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h4 id="2-模块的创建"><a href="#2-模块的创建" class="header-anchor">¶</a>2. 模块的创建：</h4><p>Python中一般使用三个方法创建模块：</p><ul class="lvl-0"><li class="lvl-2"><p>创建一个python文件，并用python语言编写其功能。</p></li><li class="lvl-2"><p>用C语言实现功能，在运行时动态加载。</p></li><li class="lvl-2"><p>直接引用内置模块。</p></li></ul><p>绝大多数时候我们只使用第一个方法，自己写一个.py为后缀的文件即可。</p><p>编写一个模块主要是要注意不要直接编写可执行代码，而是把这些代码封装在函数中或者类中，再定义好需要对外使用的变量即可。</p><p>另外要注意.py文件的对应模块名必须符合标识符的命名规则。</p><h4 id="3-模块的导入和调用"><a href="#3-模块的导入和调用" class="header-anchor">¶</a>3. 模块的导入和调用：</h4><h5 id="1import"><a href="#1import" class="header-anchor">¶</a>(1)import：</h5><p>import语句可以引入已经定义好的模块。</p><ul class="lvl-0"><li class="lvl-2"><p>导入整个模块：</p><p>对于导入整个模块，import语句的语法格式为：<em><strong>import module1[, module2[,... moduleN]]</strong></em>，moduleN表示一个模块名。</p><p>此时，可以调用模块的所有功能，调用的格式为：<em><strong>模块名.函数名</strong></em>，模块名是不能省略的。</p><p>例如导入Python的math库并使用其sqrt函数：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">import math<br><span class="hljs-built_in">result</span> = math.<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">4</span>)<br>print(<span class="hljs-built_in">result</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 2.0</span><br></code></pre></td></tr></table></figure><p>要注意，一个模块只会被导入一次，以此来防止导入模块被一遍遍执行。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta">#如在pycharm中编写会发现只有第三个import是高亮的</span><br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> math<br><span class="hljs-title">result</span> = math.sqrt(<span class="hljs-number">4</span>)<br><span class="hljs-title">print</span>(result)<br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># 2.0</span><br></code></pre></td></tr></table></figure><p>如果想要重复导入执行模块顶层部分的代码，使用reload()函数重新导入。</p><p>语法格式：<em><strong>reload(module_name)</strong></em></p><p>不过奇葩的是，reload函数的调用需要导入iimportlib包才能使用。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br><span class="hljs-keyword">import</span> importlib<br>print(<span class="hljs-type">time</span>.struct_time)<br>importlib.reload(<span class="hljs-type">time</span>)<br>print(<span class="hljs-type">time</span>.struct_time)<br># 运行结果：<br># &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;time.struct_time&#x27;</span>&gt;<br># &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;time.struct_time&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>可以使用dir()函数返回模块内定义的所有模块、变量和函数。</p><p>语法格式：<em><strong>dir(module)</strong></em>，返回一个列表，列表即为上述的全部定义信息。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import math<br>result = dir(math)<br><span class="hljs-attribute">j</span>=0<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br>    j+=1<br>    <span class="hljs-keyword">if</span> <span class="hljs-attribute">j</span>== 10:<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-attribute">j</span>=0<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># __doc__ __loader__ __name__ __package__ __spec__ acos acosh asin asinh atan </span><br><span class="hljs-comment"># atan2 atanh cbrt ceil comb copysign cos cosh degrees dist </span><br><span class="hljs-comment"># e erf erfc exp exp2 expm1 fabs factorial floor fmod </span><br><span class="hljs-comment"># frexp fsum gamma gcd hypot inf isclose isfinite isinf isnan </span><br><span class="hljs-comment"># isqrt lcm ldexp lgamma log log10 log1p log2 modf nan </span><br><span class="hljs-comment"># nextafter perm pi pow prod radians remainder sin sinh sqrt </span><br><span class="hljs-comment"># tan tanh tau trunc ulp </span><br></code></pre></td></tr></table></figure><p>这其中有三个固定方法：</p><ul class="lvl-2"><li class="lvl-4"><p>__doc__：指向指定对象的注释部分。</p></li><li class="lvl-4"><p>__file__：指向该模块的导入文件名。</p></li><li class="lvl-4"><p>__name__：指向模块的名字。</p></li></ul></li><li class="lvl-2"><p>导入模块中的特定函数和变量：</p><p>当只需要一个模块的某些函数和变量时，可以只导入模块的指定函数和变量到当前的命名空间中。</p><p>使用from ...import语句，语法格式：<em><strong>from modname import name1[, name2[, ... nameN]]</strong></em></p><p>modname是模块名，nameN是函数名或者变量名。</p><p>此语句在全局命名空间中只会引入指定的变量和函数名称。</p><p>和import语句不同的是，import语句不会将这些符号保存到全局命名空间中，所以其调用必须显式指定模块名，而from....import语句是保存到全局命名空间中，所以不需要在调用时指定模块名，可以当做自己的函数使用。</p><p>注意导入功能名字有重复时，调用的是最后定义或者导入的功能。</p><p>例如导入math中的sin()、cos()和tan()函数以及pi变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">from <span class="hljs-built_in">math</span> import <span class="hljs-built_in">sin</span>,<span class="hljs-built_in">cos</span>,<span class="hljs-built_in">tan</span>,<span class="hljs-built_in">pi</span><br><span class="hljs-built_in">print</span>(globals().keys())<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sin</span>(<span class="hljs-built_in">pi</span>/<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">cos</span>(<span class="hljs-built_in">pi</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">tan</span>(<span class="hljs-built_in">pi</span>/<span class="hljs-number">4</span>))<br># 运行结果：<br># dict_keys([<span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__doc__&#x27;</span>, <span class="hljs-string">&#x27;__package__&#x27;</span>, <span class="hljs-string">&#x27;__loader__&#x27;</span>, <span class="hljs-string">&#x27;__spec__&#x27;</span>, <span class="hljs-string">&#x27;__annotations__&#x27;</span>, <span class="hljs-string">&#x27;__builtins__&#x27;</span>, <span class="hljs-string">&#x27;__file__&#x27;</span>, <span class="hljs-string">&#x27;__cached__&#x27;</span>, <span class="hljs-string">&#x27;sys&#x27;</span>, <span class="hljs-string">&#x27;sin&#x27;</span>, <span class="hljs-string">&#x27;cos&#x27;</span>, <span class="hljs-string">&#x27;tan&#x27;</span>, <span class="hljs-string">&#x27;pi&#x27;</span>])<br># <span class="hljs-number">1.0</span><br># <span class="hljs-number">-1.0</span><br># <span class="hljs-number">0.9999999999999999</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>导入模块中的全部内容：</p><p>除了指定内容，也可以全部的模块内容导入到当前的命名空间中。</p><p>仍使用from...import语句，但import内容为*，代表导入模块的全部内容。</p><p>语法格式为：<em><strong>from modname import *</strong></em>，modname为模块名。</p><p>注意这样的操作可能会导致全局命名空间有大量的冗余变量和函数，可能使其内存占用大大增加，产生很多命名冲突，和我们使用模块化的初衷不符，所以不建议过多使用。</p><p>另外，该方式不会导入下划线__开头的函数。</p><p>例如将time模块全部导入，能够看到time中的全部函数、类和变量都被保存到了全局命名空间中。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-keyword">from</span> <span class="hljs-built_in">time</span> import *<br>j=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-built_in">in</span> <span class="hljs-built_in">list</span>(globals().<span class="hljs-built_in">keys</span>()):<br>    print(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    j+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> j==<span class="hljs-number">10</span>:<br>        print()<br>        j=<span class="hljs-number">0</span><br>print(<span class="hljs-string">&quot;\n-----------------------------&quot;</span>)<br>j=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-built_in">in</span> <span class="hljs-built_in">list</span>(dir(<span class="hljs-built_in">time</span>)):<br>    print(i,end=<span class="hljs-string">&quot; &quot;</span>)<br>    j+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> j==<span class="hljs-number">10</span>:<br>        print()<br>        j=<span class="hljs-number">0</span><br># 运行结果：<br># <span class="hljs-variable">__name__</span> <span class="hljs-variable">__doc__</span> <span class="hljs-variable">__package__</span> <span class="hljs-variable">__loader__</span> <span class="hljs-variable">__spec__</span> <span class="hljs-variable">__annotations__</span> <span class="hljs-variable">__builtins__</span> <span class="hljs-variable">__file__</span> <span class="hljs-variable">__cached__</span> sys<br><span class="hljs-meta"># time time_ns sleep gmtime localtime asctime ctime mktime strftime strptime</span><br><span class="hljs-meta"># monotonic monotonic_ns process_time process_time_ns thread_time thread_time_ns perf_counter perf_counter_ns get_clock_info timezone</span><br><span class="hljs-meta"># altzone daylight tzname struct_time j</span><br># -----------------------------<br># <span class="hljs-variable">__call__</span> <span class="hljs-variable">__class__</span> <span class="hljs-variable">__delattr__</span> <span class="hljs-variable">__dir__</span> <span class="hljs-variable">__doc__</span> <span class="hljs-variable">__eq__</span> <span class="hljs-variable">__format__</span> <span class="hljs-variable">__ge__</span> <span class="hljs-variable">__getattribute__</span> <span class="hljs-variable">__getstate__</span><br># <span class="hljs-variable">__gt__</span> <span class="hljs-variable">__hash__</span> <span class="hljs-variable">__init__</span> <span class="hljs-variable">__init_subclass__</span> <span class="hljs-variable">__le__</span> <span class="hljs-variable">__lt__</span> <span class="hljs-variable">__module__</span> <span class="hljs-variable">__name__</span> <span class="hljs-variable">__ne__</span> <span class="hljs-variable">__new__</span><br># <span class="hljs-variable">__qualname__</span> <span class="hljs-variable">__reduce__</span> <span class="hljs-variable">__reduce_ex__</span> <span class="hljs-variable">__repr__</span> <span class="hljs-variable">__self__</span> <span class="hljs-variable">__setattr__</span> <span class="hljs-variable">__sizeof__</span> <span class="hljs-variable">__str__</span> <span class="hljs-variable">__subclasshook__</span> <span class="hljs-variable">__text_signature__</span><br></code></pre></td></tr></table></figure><ul class="lvl-2"><li class="lvl-4"><p>__all__变量：</p><p>如果模块文件中定义了__all__变量，使用from modname import *语句时，只能导入这个列表的元素。</p><p>另外，该变量允许导入以__为开头的变量，所以请谨慎使用。</p><p>下面展示一下导入时的情况</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#test.py文件代码</span><br>__all__ = [<span class="hljs-string">&quot;fun2&quot;</span>,<span class="hljs-string">&quot;fun3&quot;</span>]<br>def fun():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行模块功能中...&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行完成&quot;</span>)<br>def fun2():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;功能2&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2完成&quot;</span>)<br>def fun3():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;功能3&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3完成&quot;</span>)<br><br><span class="hljs-comment">#执行文件</span><br><span class="hljs-keyword">from</span> test import *<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;fun&quot;</span> <span class="hljs-keyword">in</span> globals().keys():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;True fun&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;fun2&quot;</span> <span class="hljs-keyword">in</span> globals().keys():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;True fun2&quot;</span>)<br><span class="hljs-keyword">if</span> <span class="hljs-string">&quot;fun3&quot;</span> <span class="hljs-keyword">in</span> globals().keys():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;True fun3&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># True fun2</span><br><span class="hljs-comment"># True fun3</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>为导入模块定义别名：</p><p>如果觉得原来的模块名比较繁琐，可以为模块名增加一个别名，简化代码的调用写法。</p><p>格式：<em><strong>import modname as newname</strong></em>，modname是原模块名，newname是新的别名。</p><p>在调用时使用两个中的任何一个均可。</p><p>例如为math模块增加一个ma别名：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> ma<br><span class="hljs-built_in">print</span>(ma.pi)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 3.141592653589793</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>模块的单独运行：</p><p>有时我们希望运行或者测试单个python文件时运行代码执行某些操作或者输出结果，但是作为模块被其他文件引用时不运行这些代码，也就是让这个python文件既能够作为脚本单独运行，又能够作为模块被其他文件使用。</p><p>此时需要为python文件中所有单独运行的代码上增加这样一句话：</p><p><strong>if __name__ == &quot;__main__&quot;:</strong></p><p>此语句的意思是，只有当前文件单独执行时才会执行此语句下的代码块，作为模块被引用时不会被执行。</p><p>例如我们在一个文件夹下创建.py文件并执行文件，<a href="http://xn--test-uh5fn22anwa.py">命名为test.py</a>，文件内容和运行结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def fun():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行模块功能中...&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行完成&quot;</span>)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试模块功能中&quot;</span>)<br>    fun()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;无问题&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 测试模块功能中</span><br><span class="hljs-comment"># 执行模块功能中...</span><br><span class="hljs-comment"># 执行完成</span><br><span class="hljs-comment"># 无问题</span><br></code></pre></td></tr></table></figure><p>然后在另外一个py文件中导入此模块：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake">import <span class="hljs-keyword">test</span><br><span class="hljs-keyword">test</span>.fun()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 执行模块功能中...</span><br><span class="hljs-comment"># 执行完成</span><br></code></pre></td></tr></table></figure><p>可以发现此时的if __name__ == &quot;__main__&quot;:语句下的代码块未被执行。</p></li></ul><h4 id="4-模块的搜索路径"><a href="#4-模块的搜索路径" class="header-anchor">¶</a>4. 模块的搜索路径：</h4><p>当导入一个模块时，Python解释器需要对模块进行路径搜索，以找到最适配的模块文件。</p><p>模块的基本搜索顺序如下：</p><ul class="lvl-0"><li class="lvl-2"><p>首先搜索内置模块，一旦查找到内置模块符合要求立刻导入内置模块——内置模块名与自定义的模块名同名时会导致自定义的模块名被覆盖，其功能无法使用，所以不能自定义和内置模块名相同的模块。</p></li><li class="lvl-2"><p>内置模块不匹配，查找当前执行文件所在目录下的模块，如果匹配则导入，不匹配则继续下一步——如果是一些简单的自定义模块，建议放在同一个文件夹下（上面的例子就是如此）。</p></li><li class="lvl-2"><p>如果不在当前目录，则搜索在shell变量PYTHONPATH（python环境变量）下的每个目录。</p><p>PYTHONPATH是一个列表，内部的元素是许多目录，这些目录会存储一些python模块文件。</p><p>PYTHONPATH允许我们修改和添加目录，具体步骤此处不再讲述，可自行查阅。</p></li><li class="lvl-2"><p>如果PYTHONPATH仍未找到，则查找默认路径。默认路径对于不同的安装方式、安装版本和操作系统来说是不同的，不是统一的。</p><p>对于UNIX，默认路径一般为/usr/local/lib/python</p></li><li class="lvl-2"><p>如果上述查找均未能找到匹配的模块名，查找失败，模块不可用。</p></li></ul><p>模块的搜索路径存储在system模块的sys.path变量中，可以通过输出此列表来查看全部的上述搜索路径。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> sys import path<br><span class="hljs-attribute">i</span>=0<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> path:<br>    <span class="hljs-built_in">print</span>(j,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; \t&quot;</span>)<br>    i+=1<br>    <span class="hljs-keyword">if</span> <span class="hljs-attribute">i</span>==5:<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-attribute">i</span>=0<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># D:\pycharmwork D:\pycharmwork D:\python\python311.zip D:\python\DLLs D:\python\Lib</span><br><span class="hljs-comment"># D:\python D:\pycharmwork\venv D:\pycharmwork\venv\Lib\site-packages D:\python\Lib\site-packages</span><br></code></pre></td></tr></table></figure><h3 id="四包package"><a href="#四包package" class="header-anchor">¶</a>（四）包(Package)</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p><strong>包是模块的集合</strong>，可以理解为是<strong>模块的容器</strong>，通过包-模块的方式构建了命名的空间，避免了多模块之间的课件的命名冲突。</p><p>以文件系统类比时，包实际上就是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的模块和子包等组成的 Python 的应用环境——<strong>包是文件系统中的目录，模块是目录中的文件</strong>。</p><h4 id="2-__init__py文件"><a href="#2-__init__py文件" class="header-anchor">¶</a>2. __init__.py文件：</h4><p>对于Python3.3之前，__init__.py文件是每个包和子包必须具备的文件，用于标识该目录是一个包。即使在Python3.3之后，为了版本的兼容以及包的结构的完整，一般情况下也会在每个包或者子包上包含和配置该文件。</p><p>__init__.py文件允许是一个空文件，但一般会在此文件中执行包的初始化代码或者设置上面的__all__变量。</p><p>一般情况下，新建包时通常会自动创建__init__.py文件__来控制包的导入，如果没有请记得手动创建。</p><h4 id="3-包的导入"><a href="#3-包的导入" class="header-anchor">¶</a>3. 包的导入：</h4><h5 id="1只导入包"><a href="#1只导入包" class="header-anchor">¶</a>（1）只导入包：</h5><p><em><strong>import 包名</strong></em>，注意只导入包名相当于只执行最外层包的__init__.py文件</p><h5 id="2导入包中的模块"><a href="#2导入包中的模块" class="header-anchor">¶</a>（2）导入包中的模块：</h5><p>语法格式和上面的模块import的格式类似，但是模块名需要转变为<em><strong>包名.[子包名].模块名</strong></em>。</p><p>另外，对包内的模块使用from 包名.[子包名].模块名 import *时，一般要求对应的__init__.py文件设置__all__变量（此处不设置了，包内函数非常简单）。</p><p>导入模块时，相当于执行路径上每一个包的__init__.py文件和模块文件本身。</p><p>下面简单举例。</p><p>假设有一个包名为test_2的包，包和执行文件在同一级的同一目录内，其有两个子模块mod1、mod2和一个子包test_2_inter，子包内有一个模块mod_inter，所有的__init__.py文件为空，模块的代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#test_2/mod1.py</span><br>def mod1_fun1():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod1_fun1&quot;</span>)<br>def mod1_fun2():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod1_fun2&quot;</span>)<br>mod1_val =10<br><br><span class="hljs-comment">#test_2/mod2.py</span><br>def mod2_fun1():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod2_fun1&quot;</span>)<br>def mod2_fun2():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod2_fun2&quot;</span>)<br>mod2_val =20<br><br><span class="hljs-comment">#test_2/test_2_inter/mod_inter.py</span><br>def mod_inter_fun1():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod_inter_fun1&quot;</span>)<br>def mod_inter_fun2():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod_inter_fun2&quot;</span>)<br><span class="hljs-attribute">mod_inter_val</span>=30<br></code></pre></td></tr></table></figure><p>将每个模块分别导入，执行对应函数，有：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> test_2.mod1<br><span class="hljs-title">from</span> test_2.mod2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> test_2.test_2_inter.mod_inter<br><span class="hljs-title">test_2</span>.mod1.mod1_fun1()<br><span class="hljs-title">mod2_fun2</span>()<br><span class="hljs-title">test_2</span>.test_2_inter.mod_inter.mod_inter_fun1()<br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># mod1_fun1</span><br><span class="hljs-meta"># mod2_fun2</span><br><span class="hljs-meta"># mod_inter_fun1</span><br></code></pre></td></tr></table></figure><p>如果__init__内有内容，执行结果如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment">#test_2/__init__.py</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;导入test_2包 ing&quot;</span>)<br><br><span class="hljs-comment">#test_2/test2_2_inter/__init__.py</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;导入test_2包 ing&quot;</span>)<br><br><span class="hljs-comment">#执行文件</span><br><span class="hljs-keyword">import</span> test_2.mod1<br><span class="hljs-keyword">from</span> test_2.mod2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> test_2.test_2_inter.mod_inter<br>test_2.mod1.mod1_fun1()<br>mod2_fun2()<br>test_2.test_2_inter.mod_inter.mod_inter_fun1()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 导入test_2包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># 导入test_2包的test2_2_inter子包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># mod1_fun1</span><br><span class="hljs-comment"># mod2_fun2</span><br><span class="hljs-comment"># mod_inter_fun1</span><br></code></pre></td></tr></table></figure><p>注意，__init__文件只执行一次。</p><p>如果想要一次性全部导入，需要使用__all__变量和from 包名 import *</p><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">from</span> test_2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> test_2.test_2_inter <span class="hljs-keyword">import</span> *<br>mod1.mod1_fun1()<br>mod2.mod2_fun2()<br>mod_inter.mod_inter_fun1()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 导入test_2包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># 导入test_2包的test2_2_inter子包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># mod1_fun1</span><br><span class="hljs-comment"># mod2_fun2</span><br><span class="hljs-comment"># mod_inter_fun1</span><br></code></pre></td></tr></table></figure><p>不增加__all__变量无法使用from 包名 import *格式，必须使用包名.模块名格式。</p><h5 id="2导入包中的子模块的函数或变量"><a href="#2导入包中的子模块的函数或变量" class="header-anchor">¶</a>（2）导入包中的子模块的函数或变量：</h5><p>和上面的逻辑类似，只是导入的方式改为函数或者变量。</p><p>使用<em><strong>from 包名.[子包名].模块名 import 函数/变量</strong></em> 格式来完成。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">from</span> test_2.mod1 <span class="hljs-keyword">import</span> mod1_fun1<br><span class="hljs-keyword">from</span> test_2.mod2 <span class="hljs-keyword">import</span> mod2_val<br><span class="hljs-keyword">from</span> test_2.test_2_inter.mod_inter <span class="hljs-keyword">import</span> mod_inter_fun2<br>mod1_fun1()<br><span class="hljs-built_in">print</span>(mod2_val)<br>mod_inter_fun2()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 导入test_2包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># 导入test_2包的test2_2_inter子包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># mod1_fun1</span><br><span class="hljs-comment"># 20</span><br><span class="hljs-comment"># mod_inter_fun2</span><br></code></pre></td></tr></table></figure><h5 id="3相对路径导入包和模块"><a href="#3相对路径导入包和模块" class="header-anchor">¶</a>（3）相对路径导入包和模块：</h5><p>在查找使用包内的某个模块或者模块内的函数/类/变量时，需要使用绝对导入指定绝对路径或者使用相对导入指定相对路径，从而在包查找到匹配的模块。</p><p>注意，这两种方式都是针对包内的模块而言的，而执行文件查找包名时，使用的是前面模块的查询顺序。也就是说，先通过内置模块-&gt;当前目录-&gt;环境变量目录-&gt;默认目录查找到包名，再通过相对或者绝对路径查找到指定的包内模块。这两者不要混为一谈。</p><ul class="lvl-0"><li class="lvl-2"><p>绝对导入：</p><p>是默认的导入方式，因为它更常见，并且它有相对导入的所有功能。</p><p>绝对导入的出发目录是项目的根目录，需要写明从根目录到要导入模块的完整路径——项目的根目录就是绝对路径。</p><p>绝对路径要求必须从最顶层的目录开始为每个包或者模块提供完整详细的导入路径。</p><p>绝对导入的缺点是：包名一旦改变，导入的语句也需要发生改变；导入的路径可能十分冗长复杂。</p><p>绝对导入就是我们上面所使用的方式，这里不再介绍，这里只讲述相对导入和相对路径</p></li><li class="lvl-2"><p>相对导入：</p><p>首先要明确，相对导入只能是包内的模块使用的，用于导入包内的其他模块，且只能作为模块文件使用相对导入，外部的执行文件是不会使用相对导入的。</p><p>相对导入的出发目录是当前目录，需要给出相对路径，从当前目录出发查找模块。</p><p>相对路径是指待导入模块与当前执行文件的相对位置，用一个&quot;.&quot;来代替当前文件的所在目录。</p><p>from后有一个&quot;.&quot;时，&quot;.&quot;表示可以访问同级目录下的包或者模块；有两个&quot;.&quot;时，可以访问上一级目录的包或者模块。</p><p>相对导入的优势是代码中不会出现包的名称，不需要修改代码，同时多数情况下能够简化路径的长度。</p><p>例如，在上面例子中的子模块test_2/test_2_inter中的mod_inter.py文件内，使用相对路径导入test_2/mod1模块并使用其函数，再由外部函数调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#mod_inter.py</span><br><span class="hljs-keyword">from</span> ..mod1 <span class="hljs-keyword">import</span> mod1_fun1<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mod_inter_fun1</span>():<br>    mod1_fun1()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod_inter_fun1&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mod_inter_fun2</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;mod_inter_fun2&quot;</span>)<br>mod_inter_val=<span class="hljs-number">30</span><br><br><span class="hljs-comment">#执行文件：</span><br><span class="hljs-keyword">from</span> test_2.test_2_inter.mod_inter <span class="hljs-keyword">import</span> mod_inter_fun1<br>mod_inter_fun1()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 导入test_2包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># 导入test_2包的test2_2_inter子包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># mod1_fun1</span><br><span class="hljs-comment"># mod_inter_fun1</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-import的运行和查看导入模块"><a href="#5-import的运行和查看导入模块" class="header-anchor">¶</a>5. import的运行和查看导入模块：</h4><p>执行import命令时，首先检查导入模块是否在已有模块中，有的话此import命令无效，直接跳过。</p><p>这能够防止模块之间相互引用的无限循环。</p><p>随后，在sys.modules中搜索名为os的模块，如果其缓存存在，将缓存映射内容返回；不存在，继续搜索内置模块，os是预先安装的，所以一般情况下此时就能查找到对应结果；如果依旧没有，就在sys.path列表定义的路径中继续搜索。</p><p>搜索成功后，在本地作用域和命名空间内初始化相应的模块对象。</p><p>可以使用sys内置模块查看已导入的模块，可以得到sys.modules对象，该对象是一个字典，键是模块名，值是文件路径。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> test_2.test_2_inter.mod_inter import mod_inter_fun1<br>import sys<br><span class="hljs-attribute">j</span>=0<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> sys.modules:<br>   <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;\t&quot;</span>)<br>   j+=1<br>   <span class="hljs-keyword">if</span> <span class="hljs-attribute">j</span>==5:<br>       <span class="hljs-built_in">print</span>()<br>       <span class="hljs-attribute">j</span>=0<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 导入test_2包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># 导入test_2包的test2_2_inter子包ing</span><br><span class="hljs-comment"># 导入完成</span><br><span class="hljs-comment"># sysbuiltins_frozen_importlib_imp_thread</span><br><span class="hljs-comment"># _warnings_weakrefwinreg_iomarshal</span><br><span class="hljs-comment"># nt_frozen_importlib_externaltimezipimport_codecs</span><br><span class="hljs-comment"># codecsencodings.aliasesencodingsencodings.utf_8_signal</span><br><span class="hljs-comment"># _abcabcio__main___stat</span><br><span class="hljs-comment"># stat_collections_abcgenericpath_winapintpath</span><br><span class="hljs-comment"># os.pathos_sitebuiltins_codecs_cn_multibytecodec</span><br><span class="hljs-comment"># encodings.gbkitertoolskeyword_operatoroperator</span><br><span class="hljs-comment"># reprlib_collectionscollectionstypes_functools</span><br><span class="hljs-comment"># functoolsimportlib._bootstrapimportlib._bootstrap_externalwarningsimportlib</span><br><span class="hljs-comment"># importlib.machineryimportlib._abcposixpathenum_sre</span><br><span class="hljs-comment"># re._constantsre._parserre._casefixre._compilercopyreg</span><br><span class="hljs-comment"># refnmatcherrnourlliburllib.parse</span><br><span class="hljs-comment"># pathlibzlib_compression_bz2bz2</span><br><span class="hljs-comment"># _lzmalzmashutilmath_bisect</span><br><span class="hljs-comment"># bisect_random_sha512random_weakrefset</span><br><span class="hljs-comment"># weakreftempfilecontextlibcollections.abc_typing</span><br><span class="hljs-comment"># typing.iotyping.retypingimportlib.resources.abcimportlib.resources._adapters</span><br><span class="hljs-comment"># importlib.resources._commonimportlib.resources._legacyimportlib.resourcesimportlib.abcimportlib.util</span><br><span class="hljs-comment"># _virtualenv_distutils_hackmpl_toolkitssitetest_2</span><br><span class="hljs-comment"># test_2.test_2_intertest_2.mod1test_2.test_2_inter.mod_inter</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“python进阶——模块化(一)命名空间和作用域”</title>
    <link href="/xiaohei07.github.io/2023/07/15/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%B8%80)%E5%91%BD%E5%90%8D%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <url>/xiaohei07.github.io/2023/07/15/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E6%A8%A1%E5%9D%97%E5%8C%96(%E4%B8%80)%E5%91%BD%E5%90%8D%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>本文的核心内容是命名空间、作用域、模块、包。</p><h3 id="一前言"><a href="#一前言" class="header-anchor">¶</a>（一）前言</h3><h4 id="1-概述"><a href="#1-概述" class="header-anchor">¶</a>1. 概述</h4><p>为了便于开发和维护代码，有逻辑地阻止和处理代码段，经常需要把大量的工程代码通过模块化的方式将其分解成小的子任务和子模块。</p><p>之前提及的函数，之后要说明的类，都是模块化编程的一种，但是如果这些都堆在一个文件中，往往会导致文件过大，难以阅读，理解和维护，所以，需要提供更好的方式进行模块化编程。</p><p>Python中提供了模块(Module)，包(Package)来完成这些工作。</p><p>为了更好地在划分这些层次时命名不出现错误，保证访问的变量不出现问题，Python引入了命名空间阻止命名冲突，引入了作用域规定变量的访问范围。</p><h4 id="2-优点"><a href="#2-优点" class="header-anchor">¶</a>2. 优点：</h4><ul class="lvl-0"><li class="lvl-2"><p>简化编程，对于一个大工程的众多内容，可以有效聚焦工作重点，处理项目的核心问题。</p></li><li class="lvl-2"><p>便于维护，在产生问题时便于排查问题的来源，解决错误。</p></li><li class="lvl-2"><p>容易理解，相关代码均在一个模块或包中，前后密切相关，使整个工程的组织清晰有条理，而且这种模块式的存储方式很多时候可以隐藏代码细节，简化程序逻辑。</p></li><li class="lvl-2"><p>复用性高，可以将一个模块或包多次导入和调用，对于已经完成的功能不必重新编写，而且便于个性化拓展功能而不影响原来的代码——在Python特别是可以使用大量的第三方依赖库。</p></li><li class="lvl-2"><p>避免冲突，模块和包均具备独立的命名空间，也就是即使两个模块或者包之间有相同名字的函数/类/变量等，也不会在彼此之间产生冲突，命名是独立的。</p></li></ul><h3 id="二命名空间和作用域"><a href="#二命名空间和作用域" class="header-anchor">¶</a>（二）命名空间和作用域：</h3><h4 id="1-命名"><a href="#1-命名" class="header-anchor">¶</a>1. 命名：</h4><p>在Python中一切皆对象，所以，对引用的对象赋予一个称谓就是命名。</p><p>命名包括对变量，对函数，对类等的命名，必须遵守一定的规范。</p><p>此处不介绍命名的基本原则和一般的规范，如有需要可以自行查阅。</p><h4 id="2-命名空间"><a href="#2-命名空间" class="header-anchor">¶</a>2. 命名空间：</h4><h5 id="1概念"><a href="#1概念" class="header-anchor">¶</a>（1）概念：</h5><p>命名空间是从名称到对象的映射，需要引用的对象名称需要在命名空间中寻找。</p><p>命名空间是真实存在的，不是抽象的概念，而且需要通过的一定的技术实现和管理——在Python中，命名空间是通过Python中的字典实现的，命名空间实际上是一个存储名称-对象的键值对字典dirc——本质上，名称（标识符）和对象（本质上是内存区域）是一对一的映射，名称是访问的依据，对象是存储的内容。</p><p>命名空间避免了项目处理时命名可能的同名冲突，同一个命名空间内不允许重名，而不同的命名空间是独立的，允许不同命名空间的变量重名，不会产生任何影响，也因此，可以同时存在多个命名空间。</p><h5 id="2分类"><a href="#2分类" class="header-anchor">¶</a>（2）分类：</h5><p>命名空间与作用域是一一对应的，这也成为了命名空间分类的依据。</p><p>命名空间在Python中被分为三类：</p><ul class="lvl-0"><li class="lvl-2"><p>内置命名空间：存储的是Python语言的内置名称，包括各种异常名称以及内置函数，如len()、type()或者类型转换函数等等，在任何位置均可访问。</p><p>可以通过导入bulitins库，利用dir函数获得全部内置命名空间的名称，全部的内置命名如下（不分析每个名字的具体内容了......）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import builtins<br>builtin_names = dir(builtins)<br><span class="hljs-attribute">i</span>=0<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> builtin_names:<br>    <span class="hljs-built_in">print</span>(name,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br>    i+=1<br>    <span class="hljs-keyword">if</span> <span class="hljs-attribute">i</span>==10:<br>        <span class="hljs-built_in">print</span>()<br>        <span class="hljs-attribute">i</span>=0<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># ArithmeticError AssertionError AttributeError BaseException BaseExceptionGroup BlockingIOError BrokenPipeError BufferError BytesWarning ChildProcessError </span><br><span class="hljs-comment"># ConnectionAbortedError ConnectionError ConnectionRefusedError ConnectionResetError DeprecationWarning EOFError Ellipsis EncodingWarning EnvironmentError Exception </span><br><span class="hljs-comment"># ExceptionGroup False FileExistsError FileNotFoundError FloatingPointError FutureWarning GeneratorExit IOError ImportError ImportWarning </span><br><span class="hljs-comment"># IndentationError IndexError InterruptedError IsADirectoryError KeyError KeyboardInterrupt LookupError MemoryError ModuleNotFoundError NameError </span><br><span class="hljs-comment"># None NotADirectoryError NotImplemented NotImplementedError OSError OverflowError PendingDeprecationWarning PermissionError ProcessLookupError RecursionError </span><br><span class="hljs-comment"># ReferenceError ResourceWarning RuntimeError RuntimeWarning StopAsyncIteration StopIteration SyntaxError SyntaxWarning SystemError SystemExit </span><br><span class="hljs-comment"># TabError TimeoutError True TypeError UnboundLocalError UnicodeDecodeError UnicodeEncodeError UnicodeError UnicodeTranslateError UnicodeWarning </span><br><span class="hljs-comment"># UserWarning ValueError Warning WindowsError ZeroDivisionError __build_class__ __debug__ __doc__ __import__ __loader__ </span><br><span class="hljs-comment"># __name__ __package__ __spec__ abs aiter all anext any ascii bin </span><br><span class="hljs-comment"># bool breakpoint bytearray bytes callable chr classmethod compile complex copyright </span><br><span class="hljs-comment"># credits delattr dict dir divmod enumerate eval exec exit filter </span><br><span class="hljs-comment"># float format frozenset getattr globals hasattr hash help hex id </span><br><span class="hljs-comment"># input int isinstance issubclass iter len license list locals map </span><br><span class="hljs-comment"># max memoryview min next object oct open ord pow print </span><br><span class="hljs-comment"># property quit range repr reversed round set setattr slice sorted </span><br><span class="hljs-comment"># staticmethod str sum super tuple type vars zip </span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>全局命名空间：是在模块中定义的名称，在加载模块时被创建，记录模块的变量，包括了函数、类、其他导入模块、模块级的变量和常量，在当前模块内均可访问。</p><p>当处于全局作用域中时，由于和命名空间的一对一关系，可以使用locals()函数获得全局命名空间的名称。</p><p>也可以直接用globals()在任意位置获得全局命名空间。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean">i=<span class="hljs-number">0</span><br>global_names = list(globals().items()) #或者 locals().items()<br>for name <span class="hljs-keyword">in</span> global_names:<br>    print(name,end=<span class="hljs-string">&quot; &quot;</span>)<br>    i+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> i==<span class="hljs-number">3</span>:<br>        print()<br>        i=<span class="hljs-number">0</span><br>#运行结果：<br># (<span class="hljs-string">&#x27;__name__&#x27;</span>, <span class="hljs-string">&#x27;__main__&#x27;</span>) (<span class="hljs-string">&#x27;__doc__&#x27;</span>, None) (<span class="hljs-string">&#x27;__package__&#x27;</span>, None)<br># (<span class="hljs-string">&#x27;__loader__&#x27;</span>, &lt;_frozen_importlib_external.SourceFileLoader object at <span class="hljs-number">0x000001ED1BD45610</span>&gt;) (<span class="hljs-string">&#x27;__spec__&#x27;</span>, None) (<span class="hljs-string">&#x27;__annotations__&#x27;</span>, &#123;&#125;)<br># (<span class="hljs-string">&#x27;__builtins__&#x27;</span>, &lt;<span class="hljs-keyword">module</span> <span class="hljs-string">&#x27;builtins&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;) (<span class="hljs-string">&#x27;__file__&#x27;</span>, <span class="hljs-string">&#x27;D:\\pycharmwork\\blog_use.py&#x27;</span>) (<span class="hljs-string">&#x27;__cached__&#x27;</span>, None)<br># (<span class="hljs-string">&#x27;sys&#x27;</span>, &lt;<span class="hljs-keyword">module</span> <span class="hljs-string">&#x27;sys&#x27;</span> (built-<span class="hljs-keyword">in</span>)&gt;) (<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>局部命名空间：是函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量，（即使函数在类中也是如此）只能在函数代码块内访问。</p><p>只有在函数作用域中使用locals()函数可以获得局部命名空间。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>:<br>    i = <span class="hljs-number">0</span><br>    j=<span class="hljs-number">1</span><br>    k=<span class="hljs-string">&quot;abc&quot;</span><br>    print(locals())<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br># 运行结果：<br># &#123;<span class="hljs-string">&#x27;i&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;j&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;k&#x27;</span>: <span class="hljs-string">&#x27;abc&#x27;</span>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="3生存周期"><a href="#3生存周期" class="header-anchor">¶</a>（3）生存周期：</h5><p>指命名空间从被创建到被销毁的时间。</p><p>不同类型命名空间的生存周期不同，其创建和销毁的时间也不同，本质上，<strong>命名空间的生存周期取决于对象的作用域</strong>，命名空间的是为了对象而存在的，一旦对象执行完成，命名空间的声明周期就结束了。</p><ul class="lvl-0"><li class="lvl-2"><p>内置命名空间：和Python解释器的作用域绑定，因此在Python解释器启动时创建，在解释器退出时销毁。</p></li><li class="lvl-2"><p>全局命名空间：和模块的作用域绑定，因此在解释器加载模块时创建，在模块被移除/解释器退出时销毁。</p></li><li class="lvl-2"><p>局部命名空间：和函数的作用域绑定，因此要考虑函数是否在类中。</p><ul class="lvl-2"><li class="lvl-4">在类中：解释器执行类定义语句时创建，类的命名空间被销毁或者类被移除时销毁。</li><li class="lvl-4">不在类中：解释器调用函数时创建，调用结束/抛出异常时销毁。</li></ul></li></ul><h5 id="4查找名称的顺序"><a href="#4查找名称的顺序" class="header-anchor">¶</a>（4）查找名称的顺序</h5><p>因为需要在命名空间中查找，所以实际的查找顺序就是命名空间的查找顺序。</p><p>在Python中，查找顺序为局部命名空间—&gt;全局命名空间—&gt;内置命名空间，如果三者均未发现，放弃查找并引发NameError异常。</p><h4 id="3-作用域"><a href="#3-作用域" class="header-anchor">¶</a>3. 作用域：</h4><h5 id="1概念"><a href="#1概念" class="header-anchor">¶</a>（1）概念：</h5><p>和命名空间不同的是，作用域实际上是一个虚拟概念，没有实际对象，作用域的核心是变量的访问范围和规则。</p><p>作用域规定了Python解释器如何查找变量，确定执行代码对变量的访问权限——访问权限和访问顺序决定了程序访问的变量是否有效以及该赋何值。</p><p>因为python基础详细说明了全局和局部变量，这里不再介绍，可以结合之前的<a href="https://07xiaohei.com/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%80)/#%E5%85%A8%E5%B1%80%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">python基础——函数(一) - ZZHの个人博客 (07xiaohei.com)</a>了解其原理。</p><h5 id="2分类"><a href="#2分类" class="header-anchor">¶</a>（2）分类：</h5><ul class="lvl-0"><li class="lvl-2"><p>局部作用域Local，简写为L：</p><p>是最内层的作用域，对应了函数部分，函数的参数和函数内定义的变量、对象均属于局部作用域。</p></li><li class="lvl-2"><p>嵌套作用域Enclosing，简写为E：</p><p>也可以理解为外部作用域，外部是针对多层函数定义的。</p><p>对应了嵌套函数的作用范围，包括了非局部和非全局的变量，这一作用域主要是为了实现闭包。</p><p>对于函数A，假如有内部的嵌套函数B，如果在函数B中访问A的局部变量，则此时函数B不是直接使用，而是在函数B中创建一个__closure__属性，该属性用于保存被函数B访问的A中的局部变量，而此时__closure__属性内的变量的作用域均为嵌套作用域的变量。</p><p>可以结合<a href="https://07xiaohei.com/2023/07/12/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%89)/">python基础——函数(三) - ZZHの个人博客 (07xiaohei.com)</a>中的装饰器部分进行更进一步的了解。</p><p>了解以上内容后，可以重点解释一下闭包的主要逻辑：</p><p>闭包的主要目的是，<strong>不要在返回内函数时将内函数要使用的外函数的临时对象销毁</strong>，为了这一目的使用闭包，定义新的嵌套作用域，当函数结束返回内函数时，外函数了解到内函数被返回，所以将自己要被内函数使用的临时对象中通过嵌套作用域绑定到了内函数上，防止其销毁后破坏内函数执行功能。通过这种方式，我们将内函数赋给一个新变量后，通过新变量调用内函数时，仍旧能够使用外函数的临时变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():<br>    a = <span class="hljs-number">1</span><br>    b = <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">locals</span>())<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inter</span>():<br>        c=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">locals</span>())<br>        <span class="hljs-keyword">return</span> a + c<br>    <span class="hljs-keyword">return</span> inter<br>temp_fun =outer()<br><span class="hljs-built_in">print</span>(temp_fun())<br><span class="hljs-comment"># # 运行结果：</span><br><span class="hljs-comment"># &#123;&#x27;b&#x27;: 1, &#x27;a&#x27;: 1&#125;</span><br><span class="hljs-comment"># &#123;&#x27;c&#x27;: 1, &#x27;a&#x27;: 1&#125;</span><br><span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><p>可以看到，执行temp_fun()时，outer()函数的临时变量b因为不需要被内函数inter()使用，所以在外函数执行结束后被销毁了，而a被绑定到了内函数中，内函数的作用域中多出了a变量及其值，a的作用域即为嵌套作用域，c的作用域是局部作用域。</p><p>如果不返回内函数对象，实际上也会发生此过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():<br>    a = <span class="hljs-number">1</span><br>    b = <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">locals</span>())<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inter</span>():<br>        c=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">locals</span>())<br>        <span class="hljs-keyword">return</span> a + c<br>    inter()<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>temp_fun =outer()<br><span class="hljs-built_in">print</span>(temp_fun)<br><span class="hljs-comment"># # 运行结果：</span><br><span class="hljs-comment"># &#123;&#x27;b&#x27;: 1, &#x27;a&#x27;: 1&#125;</span><br><span class="hljs-comment"># &#123;&#x27;c&#x27;: 1, &#x27;a&#x27;: 1&#125;</span><br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><p>另外，如果外函数的参数是传入的，且值不同，则每次调用不同参数的对应内函数id是不同的，也就是创建了两个函数对象，参数相同则是一个函数对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params">a</span>):<br>    b = <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(a),<span class="hljs-built_in">id</span>(b))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inter</span>():<br>        c=<span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(c))<br>        <span class="hljs-keyword">return</span> a + c<br>    <span class="hljs-keyword">return</span> inter<br>temp_fun1 =outer(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(temp_fun1()))<br>temp_fun2 =outer(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(temp_fun2()))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 140729683866472 140729683866408</span><br><span class="hljs-comment"># 140729683866408</span><br><span class="hljs-comment"># 140729683866504</span><br><span class="hljs-comment"># 140729683866504 140729683866408</span><br><span class="hljs-comment"># 140729683866408</span><br><span class="hljs-comment"># 140729683866536</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>全局作用域Global，简写为G：</p><p>范围是当前模块的任何位置，模块中的顶层位置所导入的其他模块、定义的全局变量、函数和类都属于全局作用域。</p></li><li class="lvl-2"><p>内置作用域Built-in，简写为B：</p><p>范围是所有模块的任何位置，所有内置命名空间的名称均属于内置做哟结构域，也是最外层的作用域。</p></li></ul><h5 id="3访问权限"><a href="#3访问权限" class="header-anchor">¶</a>（3）访问权限：</h5><ul class="lvl-0"><li class="lvl-2"><p>在内层作用域能访问该层及外层所有作用域的变量。</p></li><li class="lvl-2"><p>外层作用域不能访问其内层的作用域的变量。</p></li><li class="lvl-2"><p>除了内置作用域，其他作用域不能访问另一个同层级级别的作用域的变量。</p></li></ul><h5 id="4查找规则"><a href="#4查找规则" class="header-anchor">¶</a>（4）查找规则：</h5><p>和命名空间的顺序是相同的，但是多了一级嵌套作用域。</p><p>具体的查找顺序为LEGB——即局部作用域—&gt;嵌套作用域—&gt;全局作用域—&gt;内置作用域，均不存在抛出NameError的异常。</p><p>注意没有E作用域时可以直接跳过。</p><h4 id="4-作用域和命名空间的详细关系"><a href="#4-作用域和命名空间的详细关系" class="header-anchor">¶</a>4. 作用域和命名空间的详细关系：</h4><p>作用域是建立在命名空间上的虚拟概念，变量实际存储在命名空间内，由作用域决定变量的可访问范围。</p><p>命名空间的创建对应作用域的形成，二者是一对一的关系。</p><p>变量的定义需要在逻辑上加入到当前的最内层作用域范围，物理上保存到当前对应的命名空间内。</p><p>Python中，命名空间及作用域的创建是由模块、类、函数和列表推导完成的，其他的代码块均不会创建。</p><p>此处多为概念关系，另外此处逻辑其实也和其他语言的定义十分类似，可以根据自己的理解尝试编写代码并判断自己的理解是否正确，个人就不举例了。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——高级特性(二)迭代、迭代器</title>
    <link href="/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%BA%8C)%E8%BF%AD%E4%BB%A3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%BA%8C)%E8%BF%AD%E4%BB%A3%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="三迭代"><a href="#三迭代" class="header-anchor">¶</a>（三）迭代</h3><h4 id="1-概述"><a href="#1-概述" class="header-anchor">¶</a>1. 概述：</h4><p>迭代是重复运行某个代码块的能力，在此处，特指使用for...in循环遍历某个可迭代对象的行为。</p><p>和其他使用下标完成迭代的语言不通，Python使用for...in循环完成迭代，这样做的好处是一些可以迭代的对象在没有下标的情况下也能够完成迭代——无论可迭代对象是否有序均可以完成迭代操作。</p><p>注意，迭代是取出元素本身而不是元素的索引。</p><h4 id="2-实例"><a href="#2-实例" class="header-anchor">¶</a>2. 实例：</h4><p>因为迭代本质上是用for循环的完成的，for循环的详细语法和内容请参考<a href="https://07xiaohei.com/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF/">python基础——循环</a>，这里只举例说明Python中可迭代对象的循环。</p><h5 id="1list迭代"><a href="#1list迭代" class="header-anchor">¶</a>（1）list迭代：</h5><ul class="lvl-0"><li class="lvl-2"><p>基本迭代：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [0,1,2,3,4,5,6]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 0 1 2 3 4 5 6 </span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>enumerate()函数迭代：</p><p>在迭代时，有时需要拿到索引，这时需要使用enumerate()函数。</p><p>enumerate()函数用于将一个可迭代对象组合为一个索引序列，同时列出其元素和元素下标。</p><p>语法格式：<em><strong>enumerate(sequence, [start=0])</strong></em></p><p>sequence是迭代对象，start是下标起始位置的索引值，默认第一个元素开始，返回一个enumerate对象（本质上是列表+元组）。</p><p>enumerate()函数可以用于其他类型，后面会举例。</p><p>例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">list_use = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list_use):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list_use):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;,&quot;</span>+j)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(list_use):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(i[<span class="hljs-number">0</span>])+<span class="hljs-string">&quot;,&quot;</span>+i[<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># (0, &#x27;a&#x27;)</span><br><span class="hljs-comment"># (1, &#x27;b&#x27;)</span><br><span class="hljs-comment"># (2, &#x27;c&#x27;)</span><br><span class="hljs-comment"># (3, &#x27;d&#x27;)</span><br><span class="hljs-comment"># (4, &#x27;e&#x27;)</span><br><span class="hljs-comment"># (5, &#x27;f&#x27;)</span><br><span class="hljs-comment"># 0,a</span><br><span class="hljs-comment"># 1,b</span><br><span class="hljs-comment"># 2,c</span><br><span class="hljs-comment"># 3,d</span><br><span class="hljs-comment"># 4,e</span><br><span class="hljs-comment"># 5,f</span><br><span class="hljs-comment"># 0,a</span><br><span class="hljs-comment"># 1,b</span><br><span class="hljs-comment"># 2,c</span><br><span class="hljs-comment"># 3,d</span><br><span class="hljs-comment"># 4,e</span><br><span class="hljs-comment"># 5,f</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>多个可迭代对象合并迭代：</p><p>此处需要使用zip()函数合并可迭代对象。</p><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表对象。</p><p>返回的列表需要增加list()进行强制类型转化，其长度以最短的一个可迭代对象为准。</p><p>语法格式：<em><strong>zip([iterable, ...])</strong></em>，iterable是可迭代对象。</p><p>例子如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">list_score</span>=[<span class="hljs-number">100</span>,<span class="hljs-number">80</span>,<span class="hljs-number">90</span>,<span class="hljs-number">95</span>,<span class="hljs-number">85</span>]<br><span class="hljs-attribute">list_name</span>=[<span class="hljs-string">&quot;jacklove&quot;</span>,<span class="hljs-string">&quot;rookie&quot;</span>,<span class="hljs-string">&quot;xiaotian&quot;</span>,<span class="hljs-string">&quot;wayward&quot;</span>,<span class="hljs-string">&quot;Mark&quot;</span>]<br><span class="hljs-attribute">for</span> i in zip(list_score,list_name):<br>    <span class="hljs-attribute">print</span>(i)<br><span class="hljs-attribute">for</span> i,j in zip(list_score,list_name):<br>    <span class="hljs-attribute">print</span>(str(i)+<span class="hljs-string">&quot;,&quot;</span>+j)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># (100, &#x27;jacklove&#x27;)</span><br><span class="hljs-comment"># (80, &#x27;rookie&#x27;)</span><br><span class="hljs-comment"># (90, &#x27;xiaotian&#x27;)</span><br><span class="hljs-comment"># (95, &#x27;wayward&#x27;)</span><br><span class="hljs-comment"># (85, &#x27;Mark&#x27;)</span><br><span class="hljs-comment"># 100,jacklove</span><br><span class="hljs-comment"># 80,rookie</span><br><span class="hljs-comment"># 90,xiaotian</span><br><span class="hljs-comment"># 95,wayward</span><br><span class="hljs-comment"># 85,Mark</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2tuple迭代"><a href="#2tuple迭代" class="header-anchor">¶</a>（2）tuple迭代：</h5><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs clean">tuple_use = (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br>for i <span class="hljs-keyword">in</span> tuple_use:<br>    print(i,end=<span class="hljs-string">&quot; &quot;</span>)<br># 运行结果：<br># <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><br>tuple_use = (<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;f&#x27;</span>)<br>for i <span class="hljs-keyword">in</span> enumerate(tuple_use):<br>    print(i)<br>for i,j <span class="hljs-keyword">in</span> enumerate(tuple_use):<br>    print(str(i)+<span class="hljs-string">&quot;,&quot;</span>+j)<br>for i <span class="hljs-keyword">in</span> enumerate(tuple_use):<br>    print(str(i[<span class="hljs-number">0</span>])+<span class="hljs-string">&quot;,&quot;</span>+i[<span class="hljs-number">1</span>])<br># # 运行结果：<br># # (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;a&#x27;</span>)<br># # (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>)<br># # (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br># # (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>)<br># # (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>)<br># # (<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;f&#x27;</span>)<br># # <span class="hljs-number">0</span>,a<br># # <span class="hljs-number">1</span>,b<br># # <span class="hljs-number">2</span>,c<br># # <span class="hljs-number">3</span>,d<br># # <span class="hljs-number">4</span>,e<br># # <span class="hljs-number">5</span>,f<br># # <span class="hljs-number">0</span>,a<br># # <span class="hljs-number">1</span>,b<br># # <span class="hljs-number">2</span>,c<br># # <span class="hljs-number">3</span>,d<br># # <span class="hljs-number">4</span>,e<br># # <span class="hljs-number">5</span>,f<br></code></pre></td></tr></table></figure><h5 id="3字符串迭代"><a href="#3字符串迭代" class="header-anchor">¶</a>（3）字符串迭代：</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs routeros">str_use = <span class="hljs-string">&quot;0123456&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> str_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 0 1 2 3 4 5 6</span><br><br>str_use = <span class="hljs-string">&quot;abcdef&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> enumerate(str_use):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i,j <span class="hljs-keyword">in</span> enumerate(str_use):<br>    <span class="hljs-built_in">print</span>(str(i)+<span class="hljs-string">&quot;,&quot;</span>+j)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> enumerate(str_use):<br>    <span class="hljs-built_in">print</span>(str(i[0])+<span class="hljs-string">&quot;,&quot;</span>+i[1])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># (0, &#x27;a&#x27;)</span><br><span class="hljs-comment"># (1, &#x27;b&#x27;)</span><br><span class="hljs-comment"># (2, &#x27;c&#x27;)</span><br><span class="hljs-comment"># (3, &#x27;d&#x27;)</span><br><span class="hljs-comment"># (4, &#x27;e&#x27;)</span><br><span class="hljs-comment"># (5, &#x27;f&#x27;)</span><br><span class="hljs-comment"># 0,a</span><br><span class="hljs-comment"># 1,b</span><br><span class="hljs-comment"># 2,c</span><br><span class="hljs-comment"># 3,d</span><br><span class="hljs-comment"># 4,e</span><br><span class="hljs-comment"># 5,f</span><br><span class="hljs-comment"># 0,a</span><br><span class="hljs-comment"># 1,b</span><br><span class="hljs-comment"># 2,c</span><br><span class="hljs-comment"># 3,d</span><br><span class="hljs-comment"># 4,e</span><br><span class="hljs-comment"># 5,f</span><br></code></pre></td></tr></table></figure><h5 id="4dict迭代"><a href="#4dict迭代" class="header-anchor">¶</a>（4）dict迭代：</h5><p>dict的迭代可以是对key迭代，对value迭代，或者两者一起迭代，这些都被视为可迭代对象。</p><p>迭代key是默认迭代，也可以指定迭代dict的keys：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dirc_use = &#123;1:<span class="hljs-string">&#x27;a&#x27;</span>,2:<span class="hljs-string">&#x27;b&#x27;</span>,3:<span class="hljs-string">&#x27;c&#x27;</span>,4:<span class="hljs-string">&#x27;d&#x27;</span>,5:<span class="hljs-string">&#x27;e&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dirc_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dirc_use.keys():<br>    <span class="hljs-built_in">print</span>(i, <span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 1 2 3 4 5</span><br><span class="hljs-comment"># 1 2 3 4 5</span><br></code></pre></td></tr></table></figure><p>迭代values需要指定dirc的values：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dirc_use = &#123;1:<span class="hljs-string">&#x27;a&#x27;</span>,2:<span class="hljs-string">&#x27;b&#x27;</span>,3:<span class="hljs-string">&#x27;c&#x27;</span>,4:<span class="hljs-string">&#x27;d&#x27;</span>,5:<span class="hljs-string">&#x27;e&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dirc_use.values():<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># a b c d e </span><br></code></pre></td></tr></table></figure><p>迭代两者需要指定dirc的items完成迭代：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autoit">dirc_use = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">2</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">4</span>:<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-number">5</span>:<span class="hljs-string">&#x27;e&#x27;</span>&#125;<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dirc_use.items():<br>    print(i,end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># (1, <span class="hljs-string">&#x27;a&#x27;</span>) (2, <span class="hljs-string">&#x27;b&#x27;</span>) (3, <span class="hljs-string">&#x27;c&#x27;</span>) (4, <span class="hljs-string">&#x27;d&#x27;</span>) (5, <span class="hljs-string">&#x27;e&#x27;</span>) </span><br></code></pre></td></tr></table></figure><h3 id="四迭代器"><a href="#四迭代器" class="header-anchor">¶</a>（四）迭代器</h3><h4 id="1-容器"><a href="#1-容器" class="header-anchor">¶</a>1. 容器</h4><h5 id="1概述"><a href="#1概述" class="header-anchor">¶</a>（1）概述：</h5><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个迭代获取。</p><p>容器的最大特性是能够判断一个元素是否在这个容器内，一般使用in和not in来判断元素是否包含在容器中。</p><p>常用的list、tuple、dict、set、string都属于容器对象。</p><h5 id="2底层逻辑"><a href="#2底层逻辑" class="header-anchor">¶</a>（2）底层逻辑：</h5><p>容器能够使用in或not in判断是因为其实现了__contiains__方法，自定义容器时必须实现该方法（此处不详细阐述），所以，判断是否为容器，主要是判断其是否实现了__contiains__方法。</p><h4 id="2-可迭代对象iterable"><a href="#2-可迭代对象iterable" class="header-anchor">¶</a>2. 可迭代对象iterable：</h4><p>可迭代对象的逻辑和容器类似，需要根据其是否实现了__iter__方法来判断是否是可迭代对象。</p><p>即使__iter__方法没有具体实现，也符合对可迭代对象的定义，只是不能真的被迭代。</p><p>在表现上，所有可以用for循环遍历的对象都是可迭代对象，这样的对象能够迭代出容器的所有数据。</p><p>可迭代对象用__iter__方法能够返回一个迭代器，这个迭代器指向了可迭代对象的某个元素，更多的迭代器信息后文回继续介绍。</p><p>可迭代对象赋予了容器获得其中每一个元素的能力，但要注意有些容器并不是可迭代的。</p><h4 id="3-迭代器iterator"><a href="#3-迭代器iterator" class="header-anchor">¶</a>3. 迭代器iterator：</h4><p>当了解了容器和可迭代对象之后，就可以进一步了解迭代器了。</p><h5 id="1概念"><a href="#1概念" class="header-anchor">¶</a>（1）概念：</h5><p>迭代器的定义：一个对象同时实现了__iter__和__next__方法，该对象为迭代器。实现的这两个方法也被称为迭代器协议。</p><p>从中可以看出，<strong>迭代器一定是可迭代对象</strong>，因为其已经实现了__iter__方法。</p><p>如果只实现了一个方法，不足以作为迭代器使用。</p><h5 id="2特征"><a href="#2特征" class="header-anchor">¶</a>（2）特征：</h5><p>迭代器是一个带状态的对象，可以通过iter方法从可迭代对象处获得，通过next方法不断迭代，从而遍历所有元素，一旦没有可迭代元素，抛出StopIteration异常。</p><p>迭代器是从可迭代对象的第一个元素开始访问的，因此每次iter方法返回的迭代器指向元素都是唯一确定的，由于迭代器的next方法是返回下一个元素，因此迭代器只能往前不会后退，也因此迭代器是不能重复使用的，如果需要从头开始遍历，需要利用iter方法获得一个新的迭代器。</p><p>但是要注意，对于文件之类的可迭代对象，即使多次调用iter方法，实际上返回的每一个迭代器对应的文件指针所指向的<strong>内存地址是相同的</strong>，因为iter方法实际返回的正是可迭起对象本身，这是为了打开文件避免文件指针的跳转，同时保证每次打开只需要一次遍历获得文件内容，不需要多次遍历，除非多次打开。</p><p>for循环迭代的核心逻辑就是用iter方式获得可迭代对象的迭代器，反复使用next方法，直到捕获到Stopiteration异常，退出循环。</p><p>另外，通常使用的tuple、list、set等内置数据结构都是可迭代对象，而不是迭代器，迭代器是利用另外一个类实现的，也就是说，这些内置数据结构自身实现了iter方法，由另一个类实现了两个方法，从而将自身的<strong>迭代细节</strong>交给了另一个类实现。</p><h5 id="3为什么要用迭代器而不是直接通过可迭代对象遍历"><a href="#3为什么要用迭代器而不是直接通过可迭代对象遍历" class="header-anchor">¶</a>（3）为什么要用迭代器而不是直接通过可迭代对象遍历：</h5><p>迭代器能够延迟计算，节省内存空间，完成更广义的存储。</p><p>构建迭代器时不是把所有元素一次性加载到内存，而是通过延迟计算的方式返回元素，也就是只会在需要的时候计算下一个元素并返回，不使用时不会存储，这样将会使得使用的存储空间差距巨大，甚至完成一些不可能的存储工作。比如利用迭代器可以完成逻辑上的全部自然数存储，在需要时迭代到需要的数据使用next方法获得，用有限的空间完成了无限的存储（当然无限只是理论上的）。</p><h5 id="4isinstance方法"><a href="#4isinstance方法" class="header-anchor">¶</a>（4）isinstance方法：</h5><p>使用isinstance()可以快速判断一个对象是否为迭代器或者可迭代对象。</p><p>语法格式：<em><strong>isinstance(object, classinfo)</strong></em></p><p>object是对象，classinfo是基本类型/直接类名/间接类名或者它们组成的元素。</p><p>如果对象类型和classinfo对应类型相同返回True，否则返回False。</p><p>使用该方法需要导入模块collections.abc</p><h5 id="5实例"><a href="#5实例" class="header-anchor">¶</a>（5）实例：</h5><p>首先判断一下各种基本类型是否是迭代器或者可迭代对象：</p><p>迭代器和可迭代对象需要导入模块collections.abc</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> collections.abc import *<br><span class="hljs-built_in">print</span>(isinstance(1, Iterable))<br><span class="hljs-comment">#False</span><br><span class="hljs-built_in">print</span>(isinstance(2.3, Iterable))<br><span class="hljs-comment">#False</span><br>list_judge =[1,2,3,4,5]<br>tuple_judge =(1, 2, 3,4,5)<br>set_judge =&#123;1,2,3,4,5&#125;<br>str_judge =<span class="hljs-string">&quot;12345&quot;</span><br>dirc_judge=&#123;1:<span class="hljs-string">&#x27;a&#x27;</span>,2:<span class="hljs-string">&#x27;b&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(isinstance(list_judge, Iterable))<br><span class="hljs-comment">#True</span><br><span class="hljs-built_in">print</span>(isinstance(list_judge, Iterator))<br><span class="hljs-comment">#False</span><br><span class="hljs-built_in">print</span>(isinstance(tuple_judge, Iterable))<br><span class="hljs-comment">#True</span><br><span class="hljs-built_in">print</span>(isinstance(tuple_judge, Iterator))<br><span class="hljs-comment">#False</span><br><span class="hljs-built_in">print</span>(isinstance(set_judge, Iterable))<br><span class="hljs-comment">#True</span><br><span class="hljs-built_in">print</span>(isinstance(set_judge, Iterator))<br><span class="hljs-comment">#False</span><br><span class="hljs-built_in">print</span>(isinstance(str_judge, Iterable))<br><span class="hljs-comment">#True</span><br><span class="hljs-built_in">print</span>(isinstance(str_judge, Iterator))<br><span class="hljs-comment">#False</span><br><span class="hljs-built_in">print</span>(isinstance(dirc_judge, Iterable))<br><span class="hljs-comment">#True</span><br><span class="hljs-built_in">print</span>(isinstance(dirc_judge, Iterator))<br><span class="hljs-comment">#False</span><br></code></pre></td></tr></table></figure><p>可以看到，字符串、元组、集合、字典和列表都是可迭代对象不是迭代器。</p><p>下面开始简单使用迭代器：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [1,2,3,4,5]<br>iter_use1 = list_use.__iter__()<br>iter_use2 = iter(list_use)<br><span class="hljs-built_in">print</span>(id(iter_use1))<br><span class="hljs-built_in">print</span>(id(iter_use2))<br><span class="hljs-built_in">print</span>(iter_use1)<br><span class="hljs-built_in">print</span>(iter_use2)<br><span class="hljs-built_in">print</span>(iter_use1.__next__())<br><span class="hljs-built_in">print</span>(iter_use1.__next__())<br><span class="hljs-built_in">print</span>(next(iter_use1))<br><span class="hljs-built_in">print</span>(next(iter_use1))<br><span class="hljs-built_in">print</span>(next(iter_use1))<br><span class="hljs-built_in">print</span>(next(iter_use1))<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 2224, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(next(iter_use1))</span><br><span class="hljs-comment">#           ^^^^^^^^^^^^^^^</span><br><span class="hljs-comment"># StopIteration</span><br><span class="hljs-comment"># 2370164320256</span><br><span class="hljs-comment"># 2370164321504</span><br><span class="hljs-comment"># &lt;list_iterator object at 0x00000227D8CD6800&gt;</span><br><span class="hljs-comment"># &lt;list_iterator object at 0x00000227D8CD6CE0&gt;</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><p>下面开始使用迭代器配合for循环使用：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dict_use = &#123;1:<span class="hljs-string">&#x27;a&#x27;</span>,2:<span class="hljs-string">&#x27;b&#x27;</span>,3:<span class="hljs-string">&#x27;c&#x27;</span>,4:<span class="hljs-string">&#x27;d&#x27;</span>,5:<span class="hljs-string">&#x27;e&#x27;</span>&#125;<br><span class="hljs-attribute">iter_use</span>=iter(dict_use)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iter_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-attribute">iter_use</span>=iter(dict_use.values())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iter_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-attribute">iter_use</span>=iter(dict_use.items())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iter_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 1 2 3 4 5 </span><br><span class="hljs-comment"># a b c d e </span><br><span class="hljs-comment"># (1, &#x27;a&#x27;) (2, &#x27;b&#x27;) (3, &#x27;c&#x27;) (4, &#x27;d&#x27;) (5, &#x27;e&#x27;) </span><br></code></pre></td></tr></table></figure><p>下面使用迭代器，next函数配合while循环使用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">str_use =<span class="hljs-string">&quot;abcdefg&quot;</span><br>iter_use =iter(str_use)<br><span class="hljs-keyword">while</span> True:<br>    try:<br>        print(<span class="hljs-keyword">next</span>(iter_use),end=<span class="hljs-string">&quot; &quot;</span>)<br>    except StopIteration:<br>        print()<br>        print(<span class="hljs-string">&quot;error,exit&quot;</span>)<br>        sys.<span class="hljs-keyword">exit</span>()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># a b c d e f g</span><br><span class="hljs-comment"># error,exit</span><br></code></pre></td></tr></table></figure><p>直接使用for循环遍历，实际上也是用迭代器完成的，只是被隐藏了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [1,2,3,4,5]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 1 2 3 4 5</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——高级特性(三)列表生成式、生成器</title>
    <link href="/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%B8%89)%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%B8%89)%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E3%80%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="五列表生成式"><a href="#五列表生成式" class="header-anchor">¶</a>（五）列表生成式</h3><h4 id="1-概述"><a href="#1-概述" class="header-anchor">¶</a>1. 概述：</h4><p>列表生成式是Python中内置的创建列表的方法。</p><p>列表生成式基于可迭代对象创建，相较于for循环和if循环，创建快捷（基于C语言实现），代码简介，更具可读性。</p><p>但要注意列表生成式对于简单的任务处理更具优势，如果情况复杂，生成难度可能会很高；而且列表生成式会一次性生成全部列表元素，对于大型列表，会导致内存被大量占用。</p><p>列表生成式是Python的高级特性体现之一。</p><h4 id="2-语法格式"><a href="#2-语法格式" class="header-anchor">¶</a>2. 语法格式：</h4><p><em><strong>[expression for item in iterable if conditional]</strong></em></p><p>expression：expression对应生成式列表的元素，是生成后需要保存的内容，expression通常利用for循环内的变量来计算表示，expression除了使用range循环外，不可省略。</p><p>注意：for循环前面的if...else语句是算入表达式之中的，因此for循环前面的if条件语句必须有else来保证能够取到元素。</p><p>for循环：语法对应基本的for循环，项item对应了可迭代对象iterable的每一个元素。</p><p>允许使用range循环直接表示，可以进行for循环的迭代嵌套创建新的对应关系作为生成式的元素，循环的item可以使用多个变量。</p><p>if条件语句：用于判断循环的每个元素是否符合生成的要求标准，用于筛选循环的元素，因此不能在后面的if判断中使用else，否则失去了筛选的作用。</p><h4 id="3-例子"><a href="#3-例子" class="header-anchor">¶</a>3. 例子：</h4><ul class="lvl-0"><li class="lvl-2"><p>首先是没有if语句时的列表生成式：</p><ul class="lvl-2"><li class="lvl-4">直接使用range迭代快速构建1-10的列表，需要进行list类型转化：</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = list(range(1,11))<br><span class="hljs-built_in">print</span>(list_use,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></code></pre></td></tr></table></figure><p>生成一个n*n为元素的1-10的列表：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(1,11)]<br><span class="hljs-built_in">print</span>(list_use,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] </span><br></code></pre></td></tr></table></figure><p>根据给定列表字符串集生成每个字符串的长度：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;cde&quot;</span>,<span class="hljs-string">&quot;fghi&quot;</span>,<span class="hljs-string">&quot;jklmn&quot;</span>]<br>list_use2=[len(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> list_use]<br><span class="hljs-built_in">print</span>(list_use2,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>带有if语句时的列表生成式：</p><p>生成30以内的偶数列表：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(1,31) <span class="hljs-keyword">if</span> x%<span class="hljs-attribute">2</span>==0]<br><span class="hljs-built_in">print</span>(list_use,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30]</span><br></code></pre></td></tr></table></figure><p>生成指定字符串中长度大于3的字符串并全部大写：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">list_use = [<span class="hljs-string">&quot;ab&quot;</span>,<span class="hljs-string">&quot;cde&quot;</span>,<span class="hljs-string">&quot;fghi&quot;</span>,<span class="hljs-string">&quot;jklmn&quot;</span>]<br>list_use2=[<span class="hljs-variable language_">x</span>.upper() <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span> in list_use <span class="hljs-keyword">if</span> len(<span class="hljs-variable language_">x</span>)&gt;<span class="hljs-number">3</span>]<br>print(list_use2,<span class="hljs-keyword">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br># 运行结果：<br># [<span class="hljs-string">&#x27;FGHI&#x27;</span>, <span class="hljs-string">&#x27;JKLMN&#x27;</span>] <br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>多个for循环嵌套的列表生成式：</p><p>全排列的生成：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs prolog">list_use1=[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>list_use2=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>list_use=[i+j for i in list_use1 for j in list_use2]<br>print(list_use,end=<span class="hljs-string">&quot; &quot;</span>)<br># 运行结果：<br># [<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span>, <span class="hljs-string">&#x27;a3&#x27;</span>, <span class="hljs-string">&#x27;b1&#x27;</span>, <span class="hljs-string">&#x27;b2&#x27;</span>, <span class="hljs-string">&#x27;b3&#x27;</span>, <span class="hljs-string">&#x27;c1&#x27;</span>, <span class="hljs-string">&#x27;c2&#x27;</span>, <span class="hljs-string">&#x27;c3&#x27;</span>] <br><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>for循环使用多个变量的列表生成式：</p><p>经常使用的是把dict的键值对按某种逻辑组合成列表的一个元素：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml">dict_use=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>&#125;<br>list_use=[<span class="hljs-variable language_">x</span>+str(<span class="hljs-variable language_">y</span>) <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span> in dict_use.items()]<br>print(list_use,<span class="hljs-keyword">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br># 运行结果：<br># [<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;b2&#x27;</span>, <span class="hljs-string">&#x27;c3&#x27;</span>, <span class="hljs-string">&#x27;d4&#x27;</span>] <br></code></pre></td></tr></table></figure><p>也可以直接对list的内部元组进行组合：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs prolog">list_use1=[(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>),(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>),(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)]<br>list_use=[i+j for i,j in list_use1]<br>print(list_use,end=<span class="hljs-string">&quot; &quot;</span>)<br># 运行结果：<br># [<span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;b2&#x27;</span>, <span class="hljs-string">&#x27;3c&#x27;</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="六生成器"><a href="#六生成器" class="header-anchor">¶</a>（六）生成器</h3><p>对于列表生成式，虽然其运行效率高，代码简洁，但是其一次性生成整个列表，内存消耗代价大，因此，为了节约内存，我们可以使用生成器生成列表。</p><p>当然，生成器也可以用于生成其他类型。</p><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>生成器(generator)是一种返回一个值的迭代器，每次从该迭代器取下一个值。</p><p>生成器实际上是一种高级迭代器，因此也是可迭代对象，可以使得需要返回一系列元素的函数所需的代码更加的简单和高效，当然也因此只能遍历一次。</p><p>生成器通过某种算法，在循环中能够不断计算处下一次需要生成的元素，而不需要创建完整的生成列表，以此来节省空间。</p><p>注意，生成器实际上保存的是算法，调用next方法时能够就能够计算出下一个元素的值。</p><p>一旦计算到最后一个元素，再次调用next方法，就会抛出StopIteration错误。</p><p>生成器有两种表示：生成器表达式和生成器函数。</p><h4 id="2-生成器表达式"><a href="#2-生成器表达式" class="header-anchor">¶</a>2. 生成器表达式：</h4><p>生成器表达式也被称为隐式生成器，语法与推导式基本相同，但要用圆括号来创建生成器，也就是将其[]换成()。</p><p>生成器表达式会产生新的生成器对象并返回，不会构建出一个列表进行返回，所以直接输出生成器不会输出对应的结果。</p><p>另外，生成器表达式禁止使用yield和yield from表达式（后文会讲）。</p><p>例子如下：</p><p>将上方例子的[]直接更换为()即可获得生成器，然后使用时直接用next函数或者遍历即可</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros">generator_use =(x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(1,5))<br><span class="hljs-built_in">print</span>(generator_use)<br><span class="hljs-built_in">print</span>(generator_use.__next__(),<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(generator_use.__next__(),<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(generator_use.__next__(),<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(generator_use.__next__(),<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-built_in">print</span>(generator_use.__next__(),<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 2330, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(generator_use.__next__(),end=&quot; &quot;)</span><br><span class="hljs-comment">#           ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="hljs-comment"># StopIteration</span><br><span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000016F5D849150&gt;</span><br><span class="hljs-comment"># 1 4 9 16</span><br><br>generator_use =(x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(1,5))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 1 4 9 16</span><br></code></pre></td></tr></table></figure><p>判断其是否可迭代及其类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">isinstance</span>((x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)),Iterable))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>((x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))))<br><span class="hljs-comment">#运行结果如下：</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># &lt;class &#x27;generator&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>嵌套for等语法同样可以用于生成器：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use1=[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>]<br>list_use2=[<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>]<br>generator_use=(i+j <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list_use1 <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> list_use2)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># a1 a2 a3 b1 b2 b3 c1 c2 c3 </span><br><br>dict_use=&#123;<span class="hljs-string">&#x27;a&#x27;</span>:1,<span class="hljs-string">&#x27;b&#x27;</span>:2,<span class="hljs-string">&#x27;c&#x27;</span>:3,<span class="hljs-string">&#x27;d&#x27;</span>:4&#125;<br>generator_use=(x+str(y) <span class="hljs-keyword">for</span> x,y <span class="hljs-keyword">in</span> dict_use.items())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator_use:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># a1 b2 c3 d4 </span><br></code></pre></td></tr></table></figure><h4 id="3-生成器函数"><a href="#3-生成器函数" class="header-anchor">¶</a>3. 生成器函数：</h4><p>生成器函数类似一般函数，但是额外增加了yield关键字，此时函数返回的是一个生成器对象。</p><p>生成器函数和一般函数的区别在于，一般函数的执行流程是顺序执行，当遇到return语句或者执行到最后一行语句时才会返回，而对于生成器函数，遇到yield语句会暂停函数的执行并返回此时的中间结果；一般函数的调用是用函数名显式调用，而生成器函数的调用必须显式或者隐式的使用next语句调用，同时恢复到上一次的yield语句处再往下继续执行。</p><p>也就是说，生成器函数能够利用yield语句暂停函数的执行并返回中间元素的对应生成器，并通过next方法恢复函数中断现场，并从暂停的语句处开始继续执行，直到没有yield语句可以运行，此时会引发StopIteration异常。</p><p>**yield语句：**语法格式同return语句，只替换关键字。</p><p>yield语句负责产生一个返回值并返回，返回后生成器函数会在yield语句处保存函数的内部状态，并挂起函数，直到再次调用，从上一次yield的地方继续执行，沿用上一轮的函数内部变量的状态。</p><p>注意，return语句对生成器函数返回值不会产生任何影响，函数返回值仍为生成器对象。如果没有return语句的话，注意函数结束时返回的是StopIteration异常，如果有return语句，函数会立刻停止运行并返回StopIteration异常，而return的返回值只作为异常的说明，而不是函数的返回值。</p><p>可以直接显式调用close()来手动关闭生成器函数。</p><p>可以用send()向生成器传入外部的值，但注意不能在启动生成器函数时传入。用一个变量接收send的值。</p><p>接收语法为：<em><strong>receive变量名 = yield value</strong></em>，这里send的信息会被赋给receive变量名。</p><p>send执行时会运行函数，所以如果需要send信息请注意增加yield语句或者修改外部循环。</p><p>生成器函数常用于使用生成器的流数据缓冲区。</p><p>例子如下：</p><p>简单的生成器函数，用next方法显式返回12345序列：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def get_1to5():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;启动生成器函数&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,6):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成一个新的值中......&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成成功&quot;</span>)<br>        yield i<br><span class="hljs-attribute">generator_use</span>=get_1to5()<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 2387, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(generator_use.__next__())</span><br><span class="hljs-comment">#           ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="hljs-comment"># StopIteration</span><br><span class="hljs-comment"># 启动生成器函数</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><p>for循环返回：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def get_1to5():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;启动生成器函数&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,6):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成一个新的值中......&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成成功&quot;</span>)<br>        yield i<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> get_1to5():<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 启动生成器函数</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><p>return对结果的影响：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def get_1to5():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;启动生成器函数&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,6):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成一个新的值中......&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成成功&quot;</span>)<br>        yield i<br>        return <span class="hljs-string">&quot;错误源于完成了函数&quot;</span><br>t =get_1to5()<br><span class="hljs-built_in">print</span>(t.__next__())<br><span class="hljs-built_in">print</span>(t.__next__())<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 启动生成器函数</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 2446, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(t.__next__())</span><br><span class="hljs-comment">#           ^^^^^^^^^^^^</span><br><span class="hljs-comment"># StopIteration: 错误源于完成了函数</span><br></code></pre></td></tr></table></figure><p>close显式停止函数运行：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def get_1to5():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;启动生成器函数&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,6):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成一个新的值中......&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成成功&quot;</span>)<br>        yield i<br>generator_use = get_1to5()<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br>generator_use.close()<br><span class="hljs-built_in">print</span>(generator_use.__next__())<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 启动生成器函数</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># Traceback (most recent call last):</span><br><span class="hljs-comment">#   File &quot;D:\pycharmwork\blog_use.py&quot;, line 2468, in &lt;module&gt;</span><br><span class="hljs-comment">#     print(generator_use.__next__())</span><br><span class="hljs-comment">#           ^^^^^^^^^^^^^^^^^^^^^^^^</span><br><span class="hljs-comment"># StopIteration</span><br><br>def get_1to5():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;启动生成器函数&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,6):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成一个新的值中......&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;生成成功&quot;</span>)<br>        yield i<br>generator_use = get_1to5()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> generator_use:<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span> i == 3:<br>        generator_use.close()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 启动生成器函数</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 生成一个新的值中......</span><br><span class="hljs-comment"># 生成成功</span><br><span class="hljs-comment"># 3</span><br><br></code></pre></td></tr></table></figure><p>send发送信息和receive接收信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_1to5</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>):<br>        val =<span class="hljs-keyword">yield</span> i<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;接收信息&quot;</span>+<span class="hljs-built_in">str</span>(val))<br><br>generator_use = get_1to5()<br>i = generator_use.__next__()<br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    i = generator_use.send(i*i)<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">break</span><br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 接收信息1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 接收信息4</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 接收信息9</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 接收信息16</span><br><span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><p>最后用生成器函数设计一个杨辉三角：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">Triangle</span>():<br>    result=[<span class="hljs-number">1</span>]<br>    result_next = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">yield</span> result<br>        result = result_next<br>        result_next=[<span class="hljs-number">1</span>]+ [result_next[i]+result_next[i+<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(result_next)-<span class="hljs-number">1</span>)]+[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> Triangle():<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">len</span>(i)==<span class="hljs-number">10</span>):<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——类(一)面向对象、类和实例</title>
    <link href="/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%B8%80)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B/"/>
    <url>/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%B8%80)%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一面向对象"><a href="#一面向对象" class="header-anchor">¶</a>（一）面向对象</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="header-anchor">¶</a>1. 基本概念：</h4><p>面向对象编程——Object Oriented Programming（OOP），是一种程序的设计思想，以对象作为程序的基本单元，在对象中封装数据和操作数据的函数。</p><p>和把程序作为一系列函数命令集合运行的面向过程不同，面向对象把函数继续分解为子函数，简化程序设计、降低系统复杂度。</p><p>对于众多的子函数，面向对象的程序设计把计算机程序视为一组对象的集合，不同的对象具有不同的属性和功能，这些子函数就被用在不同的对象之中。进而，程序的执行就是对象之间处理交互信息、完成自身功能的过程。</p><h4 id="2-使用技术"><a href="#2-使用技术" class="header-anchor">¶</a>2. 使用技术：</h4><p>下面简要说明面向对象的常用技术（后面会详细介绍）：</p><ul class="lvl-0"><li class="lvl-2"><p><strong>类</strong>：用于描述具有相同的属性和方法的对象的集合，定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</p><p>类把数据和功能绑定在了一起，创建新类就是创建新的对象类型，从而以类为蓝图创建该类型的新的实例，也就是对象。</p></li><li class="lvl-2"><p>**实例化：**创建一个类的实例，类的具体对象，实例支持维持自身状态的属性以及修改自身状态的方法。</p></li><li class="lvl-2"><p>**对象：**通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</p></li><li class="lvl-2"><p>**方法：**在类中定义的函数，每个对象都能够使用。</p><p>类似于c++中的成员函数</p></li><li class="lvl-2"><p>**类变量：**类变量是一个类的所有不同对象/实例共享的变量，在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外，且通常不作为实例变量使用。</p><p>类似于c++中的静态变量，只有一份。</p></li><li class="lvl-2"><p>**实例变量：**类声明时的属性用变量表示，此类变量称为实例变量，实例变量就是一个用self修饰的变量。</p><p>实例变量可以用于区分不同的实例，因此，实例变量每个实例都各自拥有，相互独立。</p><p>类似于c++中的非静态数据成员</p></li><li class="lvl-2"><p>**数据成员：**类变量或者实例变量用于处理类及其实例对象的相关的数据。</p><p>和c++中的数据成员概念类似。</p></li><li class="lvl-2"><p>**局部变量：**只定义在方法中的变量，只作用于当前实例的类。</p></li><li class="lvl-2"><p>**继承：**即一个派生类继承基类的成员和方法。继承允许多级，例如A是B的基类，B仍可以是C的基类，此时A实际上也可以算是C的基类，继承可以形成由树组成的森林。</p></li><li class="lvl-2"><p>**方法重写：**如果从基类继承的方法不能满足派生类的需求，可以对其进行改写，这个过程叫方法的覆盖，也称为方法的重写。</p></li></ul><h4 id="3-python的面向对象"><a href="#3-python的面向对象" class="header-anchor">¶</a>3. Python的面向对象：</h4><p>Python是一门面向对象的语言，这也是设计Python语言的初衷。</p><p>Python中提供了类机制，可以定义类，而且Python的类提供了面向对象编程的所有基本功能和标准特性：类的继承机制支持多个基类，派生类可以覆盖基类中的方法，类的方法可以调用基类中的同名方法，对象可以包含任意数量和类型的数据。</p><p>类机制也支持Python的动态特性：在运行时创建，创建后可以修改。</p><p>和其他编程语言相比，Python 的类只使用了很少的新语法和语义。</p><ul class="lvl-0"><li class="lvl-2"><p>如果了解c++类的概念，这里为了防止混淆进行一些说明（不了解的可以跳过）：</p><p>Python中的类成员通常为公有的(public)，成员函数默认均为虚函数(virtual)。</p><p>Python的方法函数在声明时有一个显式的参数代表本对象，在调用时隐式提供，类似this指针。</p><p>和c++不同，Python中内置类型可以用作基类以供用户扩展。</p><p>和c++相同，算术运算符、下标等具有特殊语法的内置运算符可以为类实例而重新定义（运算符重载）。</p></li></ul><p>下面正式介绍Python的类。</p><h3 id="二python中的类和实例"><a href="#二python中的类和实例" class="header-anchor">¶</a>（二）Python中的类和实例</h3><p>面向对象最重要的概念就是类和实例，所以，Python中首先必须要知道的一点：**类是创建对象的模版，对象是类的实例。**类本身不占据内存空间，实例才会占据内存空间。</p><h4 id="1-python的类定义和实例化"><a href="#1-python的类定义和实例化" class="header-anchor">¶</a>1. Python的类定义和实例化：</h4><h5 id="1简单定义"><a href="#1简单定义" class="header-anchor">¶</a>（1）简单定义：</h5><p>Python中，类通过class关键字来定义，简单的类的语法格式为：</p><p><em><strong>class ClassName[(object)]:</strong></em><em><strong>&lt;statement-1&gt;</strong></em><em><strong>.</strong></em> <em><strong>.</strong></em> <em><strong>.</strong></em><em><strong>&lt;statement-N&gt;</strong></em></p><p>ClassName是类名，类名的命名一般情况要求是名词，使用首字母大写。</p><p>object是继承的类名，如果没有则一律使用object代替，当然对于这种情况也可以不加()来表示继承关系。更详细的内容后文介绍</p><p>&lt;statement-i&gt;是定义/声明语句，后文介绍。</p><p>与函数定义一样，类定义必须先执行才能生效。</p><p>进入类定义后会创建新的局部命名空间和局部作用域，对局部变量的赋值和处理也都是在此命名空间之内。</p><p>下面简单定义一个没有属性和方法的类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">My_class:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">pass</span></span><br></code></pre></td></tr></table></figure><h5 id="2类对象"><a href="#2类对象" class="header-anchor">¶</a>（2）类对象：</h5><p>在正常离开类定义后，会创建一个类对象。</p><p>类对象支持两种操作：属性引用和实例化。</p><ul class="lvl-0"><li class="lvl-2"><p>属性引用使用Python中的标准属性引用语法：<a href="http://obj.name">obj.name</a>，obj是对象，name是属性名。</p><p>类对象创建时存在于类命名空间中的全部名称均为有效的属性名，包括数据属性和方法。</p><p>可以通过属性名对类属性进行赋值来修改其值。</p><p>属性引用后文介绍例子。</p></li><li class="lvl-2"><p>实例化和Python中的函数调用类似，可以将类对象视为一个不带参数的函数，该函数的返回值就是类的一个实例，以此方式来完成类的实例化。</p><p>实例化操作创建类的新实例，将此实例后的对象分配给某个变量，此时的对象是一个空对象。</p><p>如果想要自定义实例化对象，使其带有一定的初始状态，需要使用类定义的特殊方法__init__()，后文会详细介绍。</p><p>类实例化后才可以使用其属性和方法——其访问方式是通过上面的属性引用完成的。</p></li></ul><p>简单的类对象实例化如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">My_class</span>(<span class="hljs-symbol">object</span>):<br>    <span class="hljs-symbol">pass</span><br><span class="hljs-symbol">my_obj</span>=<span class="hljs-symbol">My_class</span>()<br></code></pre></td></tr></table></figure><h5 id="3属性和方法"><a href="#3属性和方法" class="header-anchor">¶</a>（3）属性和方法：</h5><p>上面创建的类显然是不完整的，需要为类设置属性和方法来定义类的功能，从而完善一个类。</p><p>注意，属性是数据属性，和方法一起都是属性引用的内容。</p><ul class="lvl-0"><li class="lvl-2"><p>属性：作为数据属性，其实际是类中的变量，包括了类属性和实例属性。</p><p>属性的添加可以在类中实现，也可以对某个实例对象单独实现。</p></li><li class="lvl-2"><p>方法：实际是类中的函数，包括了类方法和实例方法。</p><p>类中的方法对应的函数和普通函数的最大区别就是，类方法必须多出一个参数，调用方法的实例对象必须作为第一个参数被传入其中，这是为了区别一个类中的多个对象，便于解释器查找是哪一个对象调用的方法。</p><p>在类方法的定义中，额外的第一个参数名称一般默认为self，随后再根据需要定义参数——self代表的是类的实例，而不是类。</p><p>而在调用时，第一个额外参数self是不能指定的，类方法会隐性传入这个参数——所以，对于类方法，至少有一个参数，而如果类方法有n个参数需要传入，实际调用参数数量为n-1。</p><p>方法定义中的类属性需要指定类名.类属性来使用，实例属性需要指定第一个参数名.实例属性名来使用。</p></li><li class="lvl-2"><p>初始属性和类的构造方法：</p><p>对于类属性，是在类中直接定义的，但是对于实例属性，由于其对每个实例来说是不同的，又需要统一名称，所以，实例属性在类中的添加一般不是创建一个个实例后一个个指定的，而是利用类的构造方法完成添加的，类的构造方法允许所有实例的相同实例属性使用相同的实例属性名。</p><p>类的构造方法是一个特殊方法，名为__init__，该方法在类实例化时会自动调用。</p><p>__init__方法除了self参数外可以增加任何数量的参数，这些参数被称为初始化参数，会作为值被赋给在该方法中定义的实例属性，当然也可以直接为实例属性指定值。</p><p>__init__方法和c<ins>中的构造函数十分相似，但不像c</ins>的构造函数，它不一定是必要的。</p></li><li class="lvl-2"><p>类属性的定义：</p><p>类属性在类中直接按局部变量的定义处理即可，且对于定义后的类方法，可以直接使用类属性。</p><p>类属性因为其共享性，允许不通过实例进行访问，直接通过类名访问。</p><p>类属性除了用户定义的属性以外，实际上还有一部分的内置类属性，这些属性是解释器在新建类时自动创建的，用于保证类能够正常运行，上面的__init__也是内置类属性（这里是指方法名）。</p><p>下面列举几个常见的属性：</p><table><thead><tr><th>部分常用专有属性</th><th>说明</th><th>触发方式</th></tr></thead><tbody><tr><td>__init__</td><td>构造初始化函数</td><td>创建实例后,赋值时使用,在__new__后</td></tr><tr><td>__new__</td><td>生成实例所需属性</td><td>创建实例时</td></tr><tr><td>__class__</td><td>实例所在的类</td><td>实例.__class__</td></tr><tr><td>__str__</td><td>实例字符串表示,可读性</td><td>print(类实例),如没实现，使用repr结果</td></tr><tr><td>__repr__</td><td>实例字符串表示,准确性</td><td>类实例 回车 或者 print(repr(类实例))</td></tr><tr><td>__del__</td><td>析构</td><td>del删除实例</td></tr><tr><td>__dict__</td><td>实例属性和值的键值对</td><td>vars(实例.__dict__)</td></tr><tr><td>__doc__</td><td>类文档,子类不继承</td><td>help(类或实例)</td></tr></tbody></table><p>另外注意，<strong>实例属性访问优先级比类属性高</strong>，可以用实例属性屏蔽掉类属性；<strong>实例无法直接用赋值的方法修改类属性</strong>，因此这实际上是给实例添加了一个同名的新实例属性。</p></li></ul><h4 id="2-类定义及实例化和使用的例子"><a href="#2-类定义及实例化和使用的例子" class="header-anchor">¶</a>2. 类定义及实例化和使用的例子：</h4><p>首先，定义一个People类，其类属性为人数个数，其初始实例属性包括姓名、年龄、身高、体重、性别，为某些实例对象单独定义血型属性；People类的方法包括输出个人信息（不包括血型）、计算BMI、判断是否成年、输出当前人数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>:<br>    <span class="hljs-comment"># 类属性变量，共享</span><br>    count = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 类的初始化函数，第一个参数是self，其他参数用于接收信息，不传入可以有默认参数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,n=<span class="hljs-literal">None</span>,a=<span class="hljs-number">0</span>,h=<span class="hljs-number">0</span>,w=<span class="hljs-number">0</span>,s=<span class="hljs-string">&quot;男&quot;</span></span>):<br>        <span class="hljs-comment">#类属性变量count+1，表示此人被创建</span><br>        <span class="hljs-comment">#需要使用People来说名变量是属于这个类的，没有就相当于局部变量</span><br>        People.count+=<span class="hljs-number">1</span><br><br>        <span class="hljs-comment">#这五个均为实例属性变量</span><br>        <span class="hljs-comment">#需要使用self来说明变量是属于这个对象的，没有相当于局部变量</span><br>        <span class="hljs-variable language_">self</span>.name=n<br>        <span class="hljs-variable language_">self</span>.age=a<br>        <span class="hljs-variable language_">self</span>.height=h<br>        <span class="hljs-variable language_">self</span>.weight=w<br>        <span class="hljs-variable language_">self</span>.sex=s<br><br>    <span class="hljs-comment"># 类方法，用于输出个人信息，虽然有一个参数，实际调用不需要传入参数，因为已经有一个隐式传入的参数了</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_information</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;个人信息为：&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;姓名：&quot;</span>,<span class="hljs-variable language_">self</span>.name)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;年龄：&quot;</span>,<span class="hljs-variable language_">self</span>.age)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;身高：&quot;</span>,<span class="hljs-variable language_">self</span>.height)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;体重：&quot;</span>,<span class="hljs-variable language_">self</span>.weight)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;性别：&quot;</span>,<span class="hljs-variable language_">self</span>.sex)<br>    <span class="hljs-comment"># 类方法，获得BMI</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_BMI</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.weight/((<span class="hljs-variable language_">self</span>.height/<span class="hljs-number">100</span>)*(<span class="hljs-variable language_">self</span>.height/<span class="hljs-number">100</span>))<br><br>    <span class="hljs-comment"># 类方法，判断是否成年</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">judge_adult</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.age&gt;=<span class="hljs-number">18</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已成年&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未成年&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br><br>    <span class="hljs-comment"># 类方法，输出当前创建的人数数量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_count</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前实际人数为：&quot;</span>,<span class="hljs-variable language_">self</span>.age)<br></code></pre></td></tr></table></figure><p>下面通过几个例子来展示具体的运行逻辑：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Bob </span>= People()           <span class="hljs-comment"># 使用默认参数完成Bob的实例化</span><br><span class="hljs-keyword">Bob.print_information() </span> <span class="hljs-comment"># 通过Bob调用方法，输出对应个人信息</span><br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 个人信息为：</span><br><span class="hljs-comment"># 姓名： None</span><br><span class="hljs-comment"># 年龄： 0</span><br><span class="hljs-comment"># 身高： 0</span><br><span class="hljs-comment"># 体重： 0</span><br><span class="hljs-comment"># 性别： 男</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs axapta">Tom = People(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">175</span>,<span class="hljs-number">62</span>,<span class="hljs-string">&quot;男&quot;</span>) <span class="hljs-meta">#实例化对象Tom，姓名为Tom，20岁，175身高，62kg，性别男</span><br>Tom.print_information()  <span class="hljs-meta"># 输出Tom的个人信息</span><br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Tom的BMI为：&quot;</span>,Tom.get_BMI()) <span class="hljs-meta">#输出Tom的BMI</span><br><span class="hljs-keyword">if</span> Tom.judge_adult():    <span class="hljs-meta"># 如果Tom是成年人</span><br>    Tom.blood_type=<span class="hljs-string">&quot;A&quot;</span>   <span class="hljs-meta"># 将Tom的血型加入实例变量中，值为A型血</span><br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;Tom的血型为：&quot;</span>,Tom.blood_type) <span class="hljs-meta"># 输出血型的实例变量值</span><br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># 个人信息为：</span><br><span class="hljs-meta"># 姓名： Tom</span><br><span class="hljs-meta"># 年龄： 20</span><br><span class="hljs-meta"># 身高： 175</span><br><span class="hljs-meta"># 体重： 62</span><br><span class="hljs-meta"># 性别： 男</span><br><span class="hljs-meta"># Tom的BMI为： 20.244897959183675</span><br><span class="hljs-meta"># 已成年</span><br><span class="hljs-meta"># Tom的血型为： A</span><br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta">Jim =People(<span class="hljs-string">&quot;Jim&quot;</span>,<span class="hljs-number">16</span>,<span class="hljs-number">166</span>,<span class="hljs-number">45</span>,<span class="hljs-string">&quot;女&quot;</span>)  <span class="hljs-meta">#实例化对象Jim，姓名为Jim，16岁，166身高，45kg，性别女</span><br><span class="hljs-keyword">print</span>(Jim.<span class="hljs-keyword">count</span>)  <span class="hljs-meta">#通过实例Jim输出类属性count的值，应为3</span><br>Jim.<span class="hljs-keyword">count</span>=<span class="hljs-number">4</span>       <span class="hljs-meta">#通过实例Jim修改类属性count的值，实际上是创建了实例属性count覆盖了类属性</span><br><span class="hljs-keyword">print</span>(id(Jim.<span class="hljs-keyword">count</span>))  <span class="hljs-meta">#输出Jim实例属性的id</span><br><span class="hljs-keyword">print</span>(Jim.<span class="hljs-keyword">count</span>)      <span class="hljs-meta">#输出Jim实例属性的值，应为4</span><br><span class="hljs-keyword">print</span>(id(Tom.<span class="hljs-keyword">count</span>))  <span class="hljs-meta">#输出Tom类属性的id，应和上面的id不同</span><br><span class="hljs-keyword">print</span>(Tom.<span class="hljs-keyword">count</span>)      <span class="hljs-meta">#输出Tom类属性的值，应为3</span><br><span class="hljs-keyword">print</span>(id(People.<span class="hljs-keyword">count</span>)) <span class="hljs-meta">#输出People类属性的id，不通过对象访问，应和Tom输出类属性的id相同</span><br><span class="hljs-keyword">print</span>(People.<span class="hljs-keyword">count</span>)     <span class="hljs-meta">#输出People类属性的值，应为3</span><br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># 3</span><br><span class="hljs-meta"># 140727492866952</span><br><span class="hljs-meta"># 4</span><br><span class="hljs-meta"># 140727492866920</span><br><span class="hljs-meta"># 3</span><br><span class="hljs-meta"># 140727492866920</span><br><span class="hljs-meta"># 3</span><br></code></pre></td></tr></table></figure><h4 id="3-一切皆对象"><a href="#3-一切皆对象" class="header-anchor">¶</a>3. 一切皆对象：</h4><p>当学习了类的基本内容之后，可以发现，不管是之前的数据、函数，还是现在的类，全都都是对象，Python中的一切皆为对象，都可以用type函数判断类型，用dir函数查看其属性和方法，用help查看其帮助文档。</p><p>对于变量，Python允许对实例变量绑定任何数据，也就是说，两个不同的实例变量，虽然都是同一个类的不同实例，但拥有的变量名称都可能不同。</p><p>不同的变量名，可以绑定到一个对象上，通过任何一个变量修改对象，会影响到所有指向该对象的所有变量。</p><p>具体的例子，请结合<a href="https://07xiaohei.com/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%BA%8C)/">python基础——函数(二) - ZZHの个人博客 (07xiaohei.com)</a>中的参数传递理解。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——类(二)访问限制、继承</title>
    <link href="/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%BA%8C)%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E3%80%81%E7%BB%A7%E6%89%BF/"/>
    <url>/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E7%B1%BB(%E4%BA%8C)%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6%E3%80%81%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="三类的访问限制"><a href="#三类的访问限制" class="header-anchor">¶</a>（三）类的访问限制</h3><h4 id="1-原因"><a href="#1-原因" class="header-anchor">¶</a>1. 原因：</h4><p>Python中，当正常使用类实例时，外部代码可以通过直接调用实例变量的方法操作数据，从而隐藏内部的复杂逻辑——但有些时候，不希望外部代码自由修改某些属性时，需要为其设置访问权限，阻止外部代码的访问。</p><h4 id="2-概念"><a href="#2-概念" class="header-anchor">¶</a>2. 概念：</h4><p>Python中，属性权限的控制是通过属性名来实现的。</p><p>当属性名是由双下划线（__）开头但不是以双下划线（__）结尾，该属性就无法被外部访问。（如果是也以双下划线结尾的话就是特殊属性了，一般是内置类属性，不建议自己定义时使用）</p><p>如果以单下划线（_）开头，实际上是不能阻止外部代码访问的，但是一般情况下约定外部代码不应该访问这样的变量。（继承中会详细讲解）</p><ul class="lvl-0"><li class="lvl-2"><p>如果已经学习c++，可以理解为，一般的属性是public的成员，双下划线开头的是private成员，单下划线开头的是protected成员，不过可以被外部访问，但通过约定变成了protected的形式。</p></li></ul><p>如果想要使用或者修改这些属性，请在类中定义相关的方法，用方法包装好，这样有利于通过方法检查属性的类型和值是否合理，避免传入无效参数。</p><h4 id="3-深入理解"><a href="#3-深入理解" class="header-anchor">¶</a>3. 深入理解：</h4><p>实际上，以双下划线开头的属性不是一定就不能从外部访问——本质上，Python解释器是把双下划线开头的属性从__属性名解释成为了_类名__属性名的格式（这不一定正确，因为不同版本的解释器可能解释的结果是不同的），如果直接指定这种格式，也可以绕过限制实现访问。</p><p>但按一般要求，强烈不建议这样做，这样做破坏了访问限制本身的约束。</p><p>如果直接在实例中采用__属性名格式赋值的话，实际上，是创建了一个新的变量和对象，和类内部的双下划线开头的属性是不同的。</p><p>根本上，<strong>从语法层面，Python的私有成员和访问限制是不彻底的，Python没有提供完善的机制阻止访问私有成员和公共成员</strong>。</p><p>另外，方法也可以通过加双下划线的方式定义为私有方法，此时方法只能在类内部使用，外部调用同样要用_类名__属性名的形式。</p><h4 id="4-例子"><a href="#4-例子" class="header-anchor">¶</a>4. 例子：</h4><p>首先定义一个私有成员，实现获得修改方法：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-symbol">test:</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>        <span class="hljs-variable language_">self</span>.__inter_test=<span class="hljs-number">10</span>      <span class="hljs-comment">#设置私有成员初始值为10</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_inter_test</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):     <span class="hljs-comment">#负责返回私有成员值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.__inter_test<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_inter_test</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,val</span>): <span class="hljs-comment">#负责修改私有成员值</span><br>        <span class="hljs-variable language_">self</span>.__inter_test=val<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">True</span><br>test_exmp= test()                 <span class="hljs-comment">#实例化，此时是不能直接访问私有成员的</span><br>print(test_exmp.get_inter_test()) <span class="hljs-comment">#通过方法获得私有成员，应为10</span><br>test_exmp.set_inter_test(<span class="hljs-number">20</span>)      <span class="hljs-comment">#通过方法修改私有成员为20</span><br>print(test_exmp.get_inter_test()) <span class="hljs-comment">#通过方法获得私有成员，应为20</span><br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># 20</span><br></code></pre></td></tr></table></figure><p>尝试直接用__属性名修改私有成员：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">test_exmp= <span class="hljs-built_in">test</span>()<br>test_exmp.__inter_test=30         <span class="hljs-comment">#实际上是创建了一个新的属性</span><br><span class="hljs-built_in">print</span>(test_exmp.get_inter_test()) <span class="hljs-comment">#输出的是私有成员</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(test_exmp.get_inter_test())) <span class="hljs-comment">#对应10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(test_exmp.__inter_test))     <span class="hljs-comment">#对应30</span><br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># 140734138938440</span><br><span class="hljs-comment"># 140734138939080</span><br></code></pre></td></tr></table></figure><p>用上面的Python的解释器内部格式输出和修改私有成员：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">test_exmp= test()<br><span class="hljs-built_in">print</span>(test_exmp.get_inter_test())<br>test_exmp.<span class="hljs-attribute">_test__inter_test</span>=20<br><span class="hljs-built_in">print</span>(test_exmp.get_inter_test())<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># 20</span><br></code></pre></td></tr></table></figure><p>可以看到，私有成员被外部代码修改了，说明了访问权限不是绝对的。</p><h3 id="四继承"><a href="#四继承" class="header-anchor">¶</a>（四）继承</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>类的最重要一点就是需要支持继承。</p><p>继承是类和类之间的一种关系，继承是代码重用的最重要的方式之一。</p><p>在实现某个新类，可以通过继承完成——继承中有两类对象，基类和派生类，派生类可以从基类中继承其属性和方法，所以，创建的新类也就是派生类，方法、属性的原所有者也就是基类。</p><p>基类和派生类也可以称为父类和子类。</p><p>派生类除了继承的属性和方法外，还可以覆盖、添加功能——前者是公有的属性和功能，后者是自己特有的属性和功能。</p><p>Python支持多级继承，派生类仍然可以作为另一个类的基类使用；也支持多继承，即一个派生类由多个基类派生。</p><p>对于派生类的一个实例，其也是基类的一个实例；而对于基类的一个实例，其不是派生类的实例——所以，我们说派生类和基类是&quot;is&quot;的关系，可以用isintance判断。</p><p>这里演示一下简单的例子：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">father:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">pass</span></span><br><span class="hljs-symbol">class</span> <span class="hljs-symbol">son</span>(<span class="hljs-symbol">father</span>):<br>    <span class="hljs-symbol">pass</span><br><span class="hljs-symbol">f</span>=<span class="hljs-symbol">father</span>()<br><span class="hljs-symbol">s</span>=<span class="hljs-symbol">son</span>()<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">isinstance</span>(<span class="hljs-symbol">f,<span class="hljs-symbol">father</span></span>))<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">isinstance</span>(<span class="hljs-symbol">f,<span class="hljs-symbol">son</span></span>))<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">isinstance</span>(<span class="hljs-symbol">s,<span class="hljs-symbol">father</span></span>))<br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">isinstance</span>(<span class="hljs-symbol">s,<span class="hljs-symbol">son</span></span>))<br># 运行结果：<br># <span class="hljs-symbol">True</span><br># <span class="hljs-symbol">False</span><br># <span class="hljs-symbol">True</span><br># <span class="hljs-symbol">True</span><br></code></pre></td></tr></table></figure><h4 id="2-语法格式"><a href="#2-语法格式" class="header-anchor">¶</a>2. 语法格式：</h4><p><em><strong>class DerivedClassName(BaseClassName1, BaseClassName1, ...,BaseClassNameN):</strong></em><em><strong>&lt;statement-1&gt;</strong></em><strong>. . .</strong><em><strong>&lt;statement-N&gt;</strong></em></p><p>DerivedClassName是派生类类名，BaseClassNameN对应了每一个被继承的基类类名，内部类语句不变。</p><p>BaseClassName一般情况下必须与派生类定义在一个命名空间内。</p><p>基类类名可以用某些表达式代替，比如<em><strong>modname.BaseClassName</strong></em>，使用某个模块中的类作为基类，这时允许BaseClassNameN与派生类不在一个作用域内。</p><p>例如可以定义如下派生类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father1</span>:<br>    <span class="hljs-type">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father2</span>:<br>    <span class="hljs-type">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father3</span>:<br>    <span class="hljs-type">pass</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>(father1,father2,father3):<br>    pass<br>s =son()<br>print(s.__class__.__bases__)<br># 运行结果：<br># (&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father1&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father2&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father3&#x27;</span>&gt;)<br></code></pre></td></tr></table></figure><h4 id="3-分类"><a href="#3-分类" class="header-anchor">¶</a>3. 分类：</h4><ul class="lvl-0"><li class="lvl-2"><p>单继承：</p><p>最普通的继承，单独继承一个父类，获得其全部的属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init father work&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.init_f_val1=<span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.init_f_val2=<span class="hljs-string">&quot;classfather&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_father</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;print_father:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init_f_val1:&quot;</span>,<span class="hljs-variable language_">self</span>.init_f_val1)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init_f_val2:&quot;</span>,<span class="hljs-variable language_">self</span>.init_f_val2)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>(<span class="hljs-title class_ inherited__">father</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init son work&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.init_s_val1=<span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.init_s_val2=<span class="hljs-string">&quot;classson&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_son</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.print_father()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;print son:&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init_s_val1:&quot;</span>, <span class="hljs-variable language_">self</span>.init_s_val1)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;init_s_val2:&quot;</span>, <span class="hljs-variable language_">self</span>.init_s_val2)<br>s =son()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># s.print_son()</span><br><span class="hljs-comment"># init father work</span><br><span class="hljs-comment"># init son work</span><br><span class="hljs-comment"># print_father:</span><br><span class="hljs-comment"># init_f_val1: 1</span><br><span class="hljs-comment"># init_f_val2: classfather</span><br><span class="hljs-comment"># print son:</span><br><span class="hljs-comment"># init_s_val1: 2</span><br><span class="hljs-comment"># init_s_val2: classson</span><br></code></pre></td></tr></table></figure><p>上面使用的super稍微解释。</p></li><li class="lvl-2"><p>多重继承和多层继承：</p><p>多重继承是对多个类的继承，也就是一个类同时拥有多个基类。</p><p>多层继承是类的继承不只是两级的，派生类可以作为新的基类被继承，从而形成多个层次的继承，派生类本身的属性和方法以及通过继承得来的属性和方法都会继承给下一层派生类。</p><p>多继承和多层继承可以统称为多继承。</p><p>python支持的多继承是有限的，对于一个类继承多个父类时，优先继承第一个类的属性和方法——也就是按照优先顺位完成继承过程。</p><p>不支持对已经有继承关系的多个类先继承其基类，再继承其派生类，这会导致继承顺序的混乱而报错。</p><p>实际上，复杂的继承需要考虑选择同名方法的问题，python3.x版本使用的是<strong>MRO——方法搜索顺序</strong>，而python2.x版本使用的是深度优先继承方式。</p><p>方法搜索顺序的具体原理较复杂，这里不详细讲述，但可以直接利用**内置属性__mro__**来查看类的继承顺序，</p><p>**__mro__**属性的查看需要通过类名来进行。</p><p>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># <span class="hljs-function"><span class="hljs-keyword">fun</span>+类名每个类独有，fun1除了最终的派生类每个类都有，fun2ABC三个类有</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">funA</span>(self):<br>        print(<span class="hljs-string">&quot;funA&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;funa&quot;</span>)<br>    def fun2(self):<br>        print(<span class="hljs-string">&quot;funa&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>(A):<br>    def funB(self):<br>        print(<span class="hljs-string">&quot;funB&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;funb&quot;</span>)<br>    def fun2(self):<br>        print(<span class="hljs-string">&quot;funb&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>(A):<br>    def funC(self):<br>        print(<span class="hljs-string">&quot;funC&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;func&quot;</span>)<br>    def fun2(self):<br>        print(<span class="hljs-string">&quot;func&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>(B,C):<br>    def funD(self):<br>        print(<span class="hljs-string">&quot;funD&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;fund&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span>(B,A):<br>    def funE(self):<br>        print(<span class="hljs-string">&quot;funE&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;fune&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>(D,E):<br>    def funF(self):<br>        print(<span class="hljs-string">&quot;funF&quot;</span>)<br>f=F()<br>print(F.__mro__)<br>f.funF()<br>f.funA()<br>f.funE()<br>f.<span class="hljs-keyword">fun</span>()<br>f.fun2()<br># 运行结果：<br># (&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.F&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.D&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.E&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.B&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.C&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.A&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br># funF<br># funA<br># funE<br># fund<br># funb<br></code></pre></td></tr></table></figure><p>可以看到，方法搜索搜索顺序为FDEBCA。</p><p>对于funF，由于自己独有，直接选择自己的方法；对于funA，只有类A有， 则选择A的方法；对于funE，同理要选择E的方法；而对于fun，由于除了最终的派生类每个类都有，按方法搜索顺序搜索到了D，使用D的方法；对于只有ABC有的fun2，由于搜索顺序中第一个是B，所以选择B的方法运行。</p><p>另外，对于派生类没有__init__函数时，会从第一个查询到的有__init__函数的基类中继承，并发生默认调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father1</span>:<br>    i = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;father1 __init__&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father2</span>:<br>    ii = <span class="hljs-number">2</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;father2 __init__&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>(father1,father2):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">printson</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i:&quot;</span>,<span class="hljs-variable language_">self</span>.i)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;i:&quot;</span>,<span class="hljs-variable language_">self</span>.ii)<br>s = son()<br>s.printson()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># father1 __init__</span><br><span class="hljs-comment"># i: 1</span><br><span class="hljs-comment"># i: 2</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-super函数"><a href="#4-super函数" class="header-anchor">¶</a>4. super函数：</h4><h5 id="1概念"><a href="#1概念" class="header-anchor">¶</a>（1）概念：</h5><p>super()方法用于调用多继承中某基类的一个方法，super()方法的查找顺序遵循上面提到的方法搜索顺序，也就是按__mro__属性的顺序发生继承。</p><p>和直接使用基类类名调用方法不同，super()方法调用方法能够保证每个基类最多只被调用一次，前者在多继承可能会发生一个基类的构造函数被调用多次的情况，这对__init__方法的执行效果很好。</p><p>super()在多层继承的中间某个层次的类中使用，也会按最终派生类的__mro__属性的顺序进行继承，因此会发生一些看似&quot;不合理&quot;的现象。</p><p>多个super()方法的反复调用会按照__mro__属性的顺序调用，直到遇到object类时停止。</p><p>对于单继承，super()方法和单继承调用基类方法的效果是相同的。</p><h5 id="2语法"><a href="#2语法" class="header-anchor">¶</a>（2）语法：</h5><p><em><strong>super(type[, object-or-type]).funcname()</strong></em>（python2.x唯一格式）和<em><strong>super().funcname()</strong></em>（python3.x独有格式）</p><p>其中，type是类名，[]内是对象或者类名，一般指定self，funcname是被调用基类的方法名,_（）_内是形参列表。</p><p>返回一个代理的super对象，对其的方法调用会导致方法搜索的发生，进而实际调用搜索到的第一个方法。</p><h5 id="3例子"><a href="#3例子" class="header-anchor">¶</a>（3）例子：</h5><p>当对多层继承除了最开始的基类以外的所有派生类使用super().__init__方法时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father1</span>:<br>    <span class="hljs-type">f1</span> = 1<br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;father1 __init__&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;father1 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father2</span>:<br>    <span class="hljs-type">f2</span> = 2<br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;father2 __init__&quot;</span>)<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;father2 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span>(father2):<br>    s1=<span class="hljs-number">3</span><br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;son1 __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;son1 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span>(father1,father2):<br>    s2=<span class="hljs-number">4</span><br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;son2 __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;son2 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandson</span>(son1,son2):<br>    gs=<span class="hljs-number">5</span><br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;grandson __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        <span class="hljs-keyword">super</span>().<span class="hljs-keyword">fun</span>()<br>gson=grandson()<br>print(grandson.__mro__)<br>gson.<span class="hljs-keyword">fun</span>()<br>print()<br>s =son2()<br># 运行结果：<br># grandson __init__<br># son1 __init__<br># son2 __init__<br># father1 __init__<br># (&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.grandson&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.son1&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.son2&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father1&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father2&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br># son1 <span class="hljs-function"><span class="hljs-keyword">fun</span></span><br><br># son2 __init__<br># father1 __init__<br></code></pre></td></tr></table></figure><p>这里可以看到，两个对象创建时都没有执行father2的__init__方法，实际上很简单，因为从对象出发的__mro__属性决定了super()方法的搜索顺序，比如son1处执行了super().__init__，那么就会按__mro__属性内的顺序搜索下一个，也是就son2的__init__方法，son2进而搜索的是father1，而接下来没有了super()方法，所以停止搜索，执行完成全部遇到__init__方法。</p><p>如果想要保证每个都被执行，只需要对father1和father2也使用super().__init__方法即可，这样就会继续搜索，保证了每个基类的__init__方法都被执行且只执行一次，此时的停止是因为遇到了object类。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">father1</span>:<br>    <span class="hljs-type">f1</span> = 1<br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;father1 __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;father1 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">father2</span>:<br>    <span class="hljs-type">f2</span> = 2<br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;father2 __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;father2 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son1</span>(father2):<br>    s1=<span class="hljs-number">3</span><br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;son1 __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;son1 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son2</span>(father1,father2):<br>    s2=<span class="hljs-number">4</span><br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;son2 __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        print(<span class="hljs-string">&quot;son2 fun&quot;</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">grandson</span>(son1,son2):<br>    gs=<span class="hljs-number">5</span><br>    def __init__(self):<br>        print(<span class="hljs-string">&quot;grandson __init__&quot;</span>)<br>        <span class="hljs-keyword">super</span>().__init__()<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(self)</span></span>:<br>        <span class="hljs-keyword">super</span>().<span class="hljs-keyword">fun</span>()<br>gson=grandson()<br>print(grandson.__mro__)<br>gson.<span class="hljs-keyword">fun</span>()<br>print()<br>s =son2()<br># 运行结果：<br># grandson __init__<br># son1 __init__<br># son2 __init__<br># father1 __init__<br># father2 __init__<br># (&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.grandson&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.son1&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.son2&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father1&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;__main__.father2&#x27;</span>&gt;, &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;object&#x27;</span>&gt;)<br># son1 <span class="hljs-function"><span class="hljs-keyword">fun</span></span><br># <br># son2 __init__<br># father1 __init__<br># father2 __init__<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——高级特性(一)切片</title>
    <link href="/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%B8%80)%E5%88%87%E7%89%87/"/>
    <url>/xiaohei07.github.io/2023/07/13/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7(%E4%B8%80)%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述</h3><p>在编程过程中，Python提供了很多高级特性，用于精简代码，提高运行速度或者节省空间。</p><p>该系列将会介绍切片，迭代，迭代器，列表生成式和生成器。</p><p>装饰器实际上也算是高级特性的一部分，但为了文章的连贯，写在了<a href="https://07xiaohei.com/2023/07/12/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%89)/">python基础——函数(三)</a>中，如希望更多了解装饰器，请移步此博客。</p><h3 id="二切片"><a href="#二切片" class="header-anchor">¶</a>（二）切片</h3><h4 id="1-概述"><a href="#1-概述" class="header-anchor">¶</a>1. 概述：</h4><p>Python中对序列性对象的一种高级索引方法，可以取出序列中的一个范围对应的元素，且范围不一定连续，长度和频率不一定固定。</p><p>切片不会改变原值，返回的结果类型和切片对象的类型是一致的，可以理解为其返回的是切片对象的子序列——字符串切片返回字符串，列表切片返回列表。</p><p>切片实际上是一种浅拷贝，其生成的子序列是对原版的拷贝。</p><h4 id="2-基本索引"><a href="#2-基本索引" class="header-anchor">¶</a>2. 基本索引：</h4><p>Python中的序列性对象有两种索引方式——正索引和负索引。</p><p>以索引序列list_use为例，index为索引下标，list_use[index]表示对应元素，我们有：</p><table><thead><tr><th style="text-align:center">list_use元素</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td style="text-align:center">正索引index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr><tr><td style="text-align:center">负索引index</td><td>-10</td><td>-9</td><td>-8</td><td>-7</td><td>-6</td><td>-5</td><td>-4</td><td>-3</td><td>-2</td><td>-1</td></tr></tbody></table><p>正索引从0开始，0对应首元素；负索引从-1开始，-1对应末元素。</p><p>正负索引共同构成了Python索引的有效范围，基本索引中如果索引超出了有效范围会报错。</p><h4 id="3-切片操作"><a href="#3-切片操作" class="header-anchor">¶</a>3. 切片操作：</h4><h5 id="1语法格式"><a href="#1语法格式" class="header-anchor">¶</a>（1）语法格式：</h5><p><em><strong>object[start_index : end_index : step]</strong></em></p><p>完整的切片表达式如上，会包括三个参数，参数之间用&quot;:&quot;分割。</p><ul class="lvl-0"><li class="lvl-2"><p>step：先介绍step是为了理解后面两个索引的缺省情况。</p><p>step是指切片的步长，可正可负，绝对值代表步长大小，正负性代表了步长的方向——正步长表示从左向右取值，负步长表示从右往左取值。</p><p>step可以缺省，默认值为1，表示逐个元素取值，不会跳过任何一个元素。</p></li><li class="lvl-2"><p>start_index：表示起始索引，起始索引被包括到了切片子序列中。</p><p>起始索引可以缺省，表示从被切片对象的某一端开始，如果步长为正，表示从最左端开始，如果为负，则从最右端开始。</p></li><li class="lvl-2"><p>end_index：表示终止索引，终止索引不会包括到切片子序列中。</p></li></ul><p>终止索引可以缺省，表示从被切片对象的某一端开始，如果步长为正，表示从最右端开始，如果为负，则从最左端开始。</p><p><strong>截断</strong>：在切片中，start_index和end_index允许绝对值大于被切片序列的长度，也就是超过索引的有效范围。此时不会发生报错，而是发生截断——所有的超出部分被自动忽略，只选取有效部分进行切片。</p><p>三个参数的组合必须正确：当start_index对应位置在end_index对应位置左侧时step应&gt;0；当start_index对应位置在end_index对应位置右侧时step应&lt;0，使用正索引还是负索引均可以，是否存在截断均可以，但必须符合上面的要求。</p><h5 id="2举例"><a href="#2举例" class="header-anchor">¶</a>（2）举例：</h5><ul class="lvl-0"><li class="lvl-2"><p>切单一值：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = [0,1,2,3,4,5,6,7,8,9]<br><span class="hljs-built_in">print</span>(a[0])<br><span class="hljs-built_in">print</span>(a[9])<br><span class="hljs-built_in">print</span>(a[5])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 0</span><br><span class="hljs-comment"># 9</span><br><span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>切完整对象：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = [0,1,2,3,4,5,6,7,8,9]<br><span class="hljs-built_in">print</span>(a[0:10])<br><span class="hljs-built_in">print</span>(a[:])<br><span class="hljs-built_in">print</span>(a[0:])<br><span class="hljs-built_in">print</span>(a[-1::-1])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&gt;0，end_index&gt;0，step&gt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>:<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">2</span>:<span class="hljs-number">8</span>:<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">1</span>:<span class="hljs-number">19</span>:<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">5</span>:<span class="hljs-number">233</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 3, 4, 5, 6]</span><br><span class="hljs-comment"># [2, 4, 6]</span><br><span class="hljs-comment"># [1, 4, 7]</span><br><span class="hljs-comment"># [5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&gt;0，end_index&gt;0，step&lt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">7</span>:<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">8</span>:<span class="hljs-number">2</span>:-<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">19</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">233</span>:<span class="hljs-number">5</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [7, 6, 5, 4, 3]</span><br><span class="hljs-comment"># [8, 6, 4]</span><br><span class="hljs-comment"># [9, 6, 3]</span><br><span class="hljs-comment"># [9, 8, 7, 6]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&lt;0，end_index&lt;0，step&gt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">7</span>:-<span class="hljs-number">2</span>:<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">8</span>:-<span class="hljs-number">2</span>:<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">19</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">233</span>:-<span class="hljs-number">5</span>:<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [3, 4, 5, 6, 7]</span><br><span class="hljs-comment"># [2, 4, 6]</span><br><span class="hljs-comment"># [0, 3, 6]</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&lt;0，end_index&lt;0，step&lt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">2</span>:-<span class="hljs-number">7</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">2</span>:-<span class="hljs-number">8</span>:-<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">1</span>:-<span class="hljs-number">19</span>:-<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">5</span>:-<span class="hljs-number">233</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [8, 7, 6, 5, 4]</span><br><span class="hljs-comment"># [8, 6, 4]</span><br><span class="hljs-comment"># [9, 6, 3, 0]</span><br><span class="hljs-comment"># [5, 4, 3, 2, 1, 0]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&gt;0，end_index&lt;0，step&gt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">2</span>:-<span class="hljs-number">2</span>:<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">4</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">3</span>:-<span class="hljs-number">3</span>:<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">0</span>:-<span class="hljs-number">5</span>:<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 3, 4, 5, 6, 7]</span><br><span class="hljs-comment"># [4, 6, 8]</span><br><span class="hljs-comment"># [3, 6]</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&gt;0，end_index&lt;0，step&lt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">8</span>:-<span class="hljs-number">8</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">6</span>:-<span class="hljs-number">9</span>:-<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">123</span>:-<span class="hljs-number">7</span>:-<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">6</span>:-<span class="hljs-number">15</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [8, 7, 6, 5, 4, 3]</span><br><span class="hljs-comment"># [6, 4, 2]</span><br><span class="hljs-comment"># [9, 6]</span><br><span class="hljs-comment"># [6, 5, 4, 3, 2, 1, 0]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&lt;0，end_index&gt;0，step&gt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">2</span>:<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">4</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">3</span>:<span class="hljs-number">3</span>:-<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">1</span>:<span class="hljs-number">5</span>:-<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [8, 7, 6, 5, 4, 3]</span><br><span class="hljs-comment"># [6, 4, 2]</span><br><span class="hljs-comment"># [7, 4]</span><br><span class="hljs-comment"># [9, 8, 7, 6]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>start_index&lt;0，end_index&gt;0，step&lt;0：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [0,1,2,3,4,5,6,7,8,9]</span><br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">8</span>:<span class="hljs-number">8</span>:<span class="hljs-number">1</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">6</span>:<span class="hljs-number">9</span>:<span class="hljs-number">2</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">7</span>:<span class="hljs-number">7</span>:<span class="hljs-number">3</span>])<br><span class="hljs-attribute">print</span>(a[-<span class="hljs-number">9</span>:<span class="hljs-number">5</span>:<span class="hljs-number">1</span>])<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 3, 4, 5, 6, 7]</span><br><span class="hljs-comment"># [4, 6, 8]</span><br><span class="hljs-comment"># [3, 6]</span><br><span class="hljs-comment"># [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>缺省：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = [0,1,2,3,4,5,6,7,8,9]<br><span class="hljs-built_in">print</span>(a[::])<br><span class="hljs-built_in">print</span>(a[5::])<br><span class="hljs-built_in">print</span>(a[-5::])<br><span class="hljs-built_in">print</span>(a[:4:])<br><span class="hljs-built_in">print</span>(a[:-6:])<br><span class="hljs-built_in">print</span>(a[::2])<br><span class="hljs-built_in">print</span>(a[::-2])<br><span class="hljs-built_in">print</span>(a[3::2])<br><span class="hljs-built_in">print</span>(a[-7::1])<br><span class="hljs-built_in">print</span>(a[7::-2])<br><span class="hljs-built_in">print</span>(a[-3::-1])<br><span class="hljs-built_in">print</span>(a[:7:2])<br><span class="hljs-built_in">print</span>(a[:-3:1])<br><span class="hljs-built_in">print</span>(a[:-7:-2])<br><span class="hljs-built_in">print</span>(a[:3:-1])<br><br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [0, 1, 2, 3]</span><br><span class="hljs-comment"># [0, 1, 2, 3]</span><br><span class="hljs-comment"># [0, 2, 4, 6, 8]</span><br><span class="hljs-comment"># [9, 7, 5, 3, 1]</span><br><span class="hljs-comment"># [3, 5, 7, 9]</span><br><span class="hljs-comment"># [3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [7, 5, 3, 1]</span><br><span class="hljs-comment"># [7, 6, 5, 4, 3, 2, 1, 0]</span><br><span class="hljs-comment"># [0, 2, 4, 6]</span><br><span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6]</span><br><span class="hljs-comment"># [9, 7, 5]</span><br><span class="hljs-comment"># [9, 8, 7, 6, 5, 4]</span><br></code></pre></td></tr></table></figure><p>切片除了用于列表，还可以用于其他序列对象，此处不再举例。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python进阶——函数(三)</title>
    <link href="/xiaohei07.github.io/2023/07/12/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%89)/"/>
    <url>/xiaohei07.github.io/2023/07/12/python%E8%BF%9B%E9%98%B6%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h3 id="四函数式编程"><a href="#四函数式编程" class="header-anchor">¶</a>（四）函数式编程</h3><p>Python是面向对象的程序设计语言，也是面向过程的程序语言,同时也支持函数式编程。</p><p>Pyhon标准库functools 提供了若干关于函数的函数，提供了Haskell和Standard ML中的函数式程序设计工具。</p><p>Python中的函数与其他数据类型处于平等地位，因此函数可以赋值给变量，可以作为参数传入其他函数，存储在其他数据结构中，或者作为函数的返回值。</p><h4 id="1-作为对象的函数"><a href="#1-作为对象的函数" class="header-anchor">¶</a>1. 作为对象的函数：</h4><p>函数在Python中是作为对象存在的，故函数对象可以赋值给变量，然后调用该变量。</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">def</span> <span class="hljs-function"><span class="hljs-title">printself</span>():</span><br><span class="hljs-function">    <span class="hljs-title">print</span>(<span class="hljs-string">&quot;123321&quot;</span>)</span><br><span class="hljs-variable">copyfun</span> = <span class="hljs-variable">printself</span><br><span class="hljs-function"><span class="hljs-title">copyfun</span>()</span><br></code></pre></td></tr></table></figure><p>数据结构内的函数：函数作为对象，也可以存储数据结构内部。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun1</span>():<br>    print(<span class="hljs-string">&quot;fun1&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun2</span>():<br>    print(<span class="hljs-string">&quot;fun2&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun3</span>():<br>    print(<span class="hljs-string">&quot;fun3&quot;</span>)<br>map_fun = &#123;<span class="hljs-number">1</span><span class="hljs-symbol">:fun1</span>,<span class="hljs-number">2</span><span class="hljs-symbol">:fun2</span>,<span class="hljs-number">3</span><span class="hljs-symbol">:fun3</span>&#125;<br>map_fun[<span class="hljs-number">2</span>]()<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># fun2</span><br></code></pre></td></tr></table></figure><p>函数作为参数和返回值：函数可以作为其他函数的参数和返回值，接受函数作为输入或返回函数的函数叫做高阶函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use</span>(<span class="hljs-params">fun,list_use</span>):<br>    <span class="hljs-keyword">return</span> fun(list_use)<br><span class="hljs-built_in">print</span>(fun_use(<span class="hljs-built_in">max</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3.4</span>,<span class="hljs-number">7.2</span>]))<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># 7.2</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">return</span> a+b<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">return</span> a-b<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_high</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x==<span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> add<br>    <span class="hljs-keyword">elif</span> x==<span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> sub<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>fun_use = fun_high(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(fun_use(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br>fun_use = fun_high(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(fun_use(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><p>函数名实际上也是变量，可以让函数名指向其他对象，但是这样会导致原有的函数无法使用。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def <span class="hljs-built_in">add</span>(<span class="hljs-keyword">a</span>,b):<br>    <span class="hljs-literal">return</span> <span class="hljs-keyword">a</span>+b<br><span class="hljs-built_in">add</span> =<span class="hljs-number">10</span><br>print(<span class="hljs-built_in">add</span>)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 10</span><br></code></pre></td></tr></table></figure><p>嵌套函数、Lambda表达式也是函数式编程的一部分，详见之前的博客，下面介绍更进一步的内容。</p><h4 id="2-map-filter-和-reduce"><a href="#2-map-filter-和-reduce" class="header-anchor">¶</a>2. Map、Filter 和 Reduce:</h4><h5 id="1-map函数"><a href="#1-map函数" class="header-anchor">¶</a>(1) map函数：</h5><p>map 函数的功能是对可迭代对象中的每个元素都调用指定的函数，并返回一个map对象的iterator迭代器（可以转化为list对象）。</p><p>语法格式：<em><strong>map(function, iterable)</strong></em></p><p>function参数表示传入的函数，可以是内置函数、自定义函数或者 lambda 匿名函数，iterable表示可迭代对象，可以是列表、元组等，允许一到多个。</p><p>一般用于对某个集合对象的全部值执行某个特定操作。</p><p>map() 函数由 C 语言实现，执行效率高。</p><p>例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">list_use = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>list_new = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x:x*<span class="hljs-number">2</span>, list_use))<br><span class="hljs-built_in">print</span>(list_new)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 4, 6, 8, 10, 12, 14, 16, 18]</span><br></code></pre></td></tr></table></figure><h5 id="2-fiter函数"><a href="#2-fiter函数" class="header-anchor">¶</a>(2) fiter函数：</h5><p>filter函数的功能是对传入的可迭代对象中的每个元素，都进行函数判断，并返回True或者False，最后将返回 True 的元素组成一个新的可遍历的集合对象，返回其迭代器。</p><p>语法格式：<em><strong>filter(function, iterable)</strong></em></p><p>function参数表示传入的函数，可以是内置函数、自定义函数或者 lambda 匿名函数，iterable表示可迭代对象，可以是列表、元组等，允许一到多个。</p><p>一般用于筛除可迭代对象的不想要的项。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">list_use = [1,2,3,4,5,6,7,8,9]<br>list_new = list(filter(lambda x:x%<span class="hljs-attribute">2</span>==0, list_use))<br><span class="hljs-built_in">print</span>(list_new)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><h5 id="3redeuce函数"><a href="#3redeuce函数" class="header-anchor">¶</a>（3）redeuce函数：</h5><p>reduce() 函数通常用来对一个集合做一些累积操作。</p><p>语法格式：<em><strong>reduce(function, iterable)</strong></em></p><p>function规定必须传入一个包含 2 个参数的函数；iterable 表示可迭代对象，可以是列表、元组等，允许一到多个。</p><p>reduce() 函数在Python 3.x 中已经从内置函数中被移除，在functools模块使用 ，需要导入functools模块。</p><p>reduce 函数一般用于总结或者概述数据集。</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">import</span> functools<br>list_use = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>list_new = functools.<span class="hljs-keyword">reduce</span>(lambda x,y:x+y, list_use)<br><span class="hljs-keyword">print</span>(list_new)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 25</span><br></code></pre></td></tr></table></figure><h4 id="3-函数装饰器"><a href="#3-函数装饰器" class="header-anchor">¶</a>3. 函数装饰器：</h4><h5 id="1闭包"><a href="#1闭包" class="header-anchor">¶</a>（1）闭包：</h5><p>是指在函数中嵌套其他函数时引用外部函数变量，即在一个内部函数中，对外部作用域的变量进行引用，内部函数即为闭包。</p><p>一般情况下，内部函数是外部函数的返回值。</p><p>闭包无法修改外部函数的局部变量。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_new</span>(<span class="hljs-params">b</span>):<br>        <span class="hljs-keyword">return</span> a+b<br>    <span class="hljs-keyword">return</span> add_new<br><span class="hljs-built_in">print</span>(add_two(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><h5 id="2装饰器"><a href="#2装饰器" class="header-anchor">¶</a>（2）装饰器：</h5><p>是闭包的一个应用，能够使得代码更简短。</p><p>装饰器是用于拓展原函数功能的一种函数，不需要修改原函数的内容和调用。</p><p>装饰器常用于授权、日志等行为。</p><p>语法格式：</p><p><strong>def 装饰器函数名(唯一形参):</strong></p><p>​<strong>函数体</strong></p><p><strong>@装饰器函数名</strong></p><p><strong>def 被装饰的函数名(形参列表):</strong></p><p>​<strong>函数体</strong></p><p>使用时直接调用被装饰的函数名即可。</p><p>装饰器函数的形参需要一个函数作为参数传入，同时需要在内部代码块执行该函数，以保证被装饰函数的正确执行。</p><p>传参时和带参数时需要装饰器函数嵌套函数，后面进行介绍。</p><p>Python内置了3种函数装饰器，分别是＠staticmethod、＠classmethod 和@property，我们也可以自己定义函数装饰器。</p><p><strong>装饰器完成的内容：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>将被装饰的函数作为参数传给装饰器函数（后面-&gt;前面）。</p></li><li class="lvl-2"><p>将被装饰的函数的返回值替换成装饰器函数的返回值（前面-&gt;后面）。</p></li></ul><p>实际上，就是把装饰器函数的功能按一定逻辑顺序加入到被装饰的函数当中，使得原函数不需要修改。</p><p>因此，不用@函数也可以完成装饰器的功能，只是相对而言阅读比较困难。</p><p>例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def use_decorator_fun(used_for_decorator_fun):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之前执行&quot;</span>)<br>    used_for_decorator_fun()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之后执行&quot;</span>)<br>    return <span class="hljs-literal">True</span><br>@use_decorator_fun<br>def used_for_decorator_fun():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行正常功能中&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,11,2):<br>        <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n执行完毕&quot;</span>)<br><br>result = used_for_decorator_fun<br><span class="hljs-keyword">if</span> result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行成功&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之前执行</span><br><span class="hljs-comment"># 执行正常功能中</span><br><span class="hljs-comment"># 1,3,5,7,9,</span><br><span class="hljs-comment"># 执行完毕</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之后执行</span><br><span class="hljs-comment"># 执行成功</span><br><br></code></pre></td></tr></table></figure><p>如果不用@，可以是以下形式来表示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def use_decorator_fun(used_for_decorator_fun):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之前执行&quot;</span>)<br>    used_for_decorator_fun()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之后执行&quot;</span>)<br>    return <span class="hljs-literal">True</span><br>def used_for_decorator_fun():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行正常功能中&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,11,2):<br>        <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n执行完毕&quot;</span>)<br>used_for_decorator_fun =use_decorator_fun(used_for_decorator_fun)<br>result = used_for_decorator_fun<br><span class="hljs-keyword">if</span> result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行成功&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之前执行</span><br><span class="hljs-comment"># 执行正常功能中</span><br><span class="hljs-comment"># 1,3,5,7,9,</span><br><span class="hljs-comment"># 执行完毕</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之后执行</span><br><span class="hljs-comment"># 执行成功</span><br></code></pre></td></tr></table></figure><p>可以看到，@use_decorator_fun只是换成了used_for_decorator_fun =use_decorator_fun(used_for_decorator_fun)，不过此句的位置换到了两个函数定义之后。</p><p>这就是装饰器的实质。</p><h5 id="3装饰器传参"><a href="#3装饰器传参" class="header-anchor">¶</a>（3）装饰器传参：</h5><p>被装饰的函数带有参数时，需要对装饰器函数进行处理，以便前者为后者传递参数。</p><p>此时，需要为装饰器函数增加一个嵌套函数，嵌套的内部函数带有形参列表，如果其接收参数数量确定可以直接指定好形参列表数量，但多数时候参数数量是不固定的，此时使用前文已讲述的过的两个参数*args和**kwargs来完成接收任意数量参数的要求。</p><p>例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_add</span>(<span class="hljs-params">fun_use</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_add_fact</span>(<span class="hljs-params">a</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之前执行&quot;</span>)<br>        fun_use(a)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之后执行&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> fun_use_add_fact<br><span class="hljs-meta">@fun_use_add</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行正常功能中&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,a,<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n执行完毕&quot;</span>)<br>result = fun_use(<span class="hljs-number">11</span>)<br><span class="hljs-keyword">if</span> result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行成功&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之前执行</span><br><span class="hljs-comment"># 执行正常功能中</span><br><span class="hljs-comment"># 1,3,5,7,9,</span><br><span class="hljs-comment"># 执行完毕</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之后执行</span><br><span class="hljs-comment"># 执行成功</span><br></code></pre></td></tr></table></figure><p>此时完成了一个参数的传递，如果参数不固定，可以改为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_add</span>(<span class="hljs-params">fun_use</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_add_fact</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之前执行&quot;</span>)<br>        fun_use(*args,**kwargs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之后执行&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">return</span> fun_use_add_fact<br><span class="hljs-meta">@fun_use_add</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行正常功能中&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,a,<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n执行完毕&quot;</span>)<br>result = fun_use(<span class="hljs-number">11</span>)<br><span class="hljs-keyword">if</span> result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行成功&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之前执行</span><br><span class="hljs-comment"># 执行正常功能中</span><br><span class="hljs-comment"># 1,3,5,7,9,</span><br><span class="hljs-comment"># 执行完毕</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之后执行</span><br><span class="hljs-comment"># 执行成功</span><br></code></pre></td></tr></table></figure><h5 id="4带参数的装饰器"><a href="#4带参数的装饰器" class="header-anchor">¶</a>（4）带参数的装饰器：</h5><p>装饰器除了接收原函数任意类型和数量的参数，还可以接收自己定义的参数。</p><p>此时，需要在装饰器函数外部额外嵌套一层函数，该层负责接收自己定义的参数，内部代码块的对应return也要添加。</p><p>同时，在@处需要在函数名后增加要传入的实参，注意，此处必须传入对应参数。</p><p>例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_parameter</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_add</span>(<span class="hljs-params">fun_use</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use_add_fact</span>(<span class="hljs-params">*args,**kwargs</span>):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之前执行&quot;</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,a+<span class="hljs-number">1</span>):<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第&quot;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&quot;次执行函数功能,函数功能序号为&quot;</span>+<span class="hljs-built_in">str</span>(b))<br>                fun_use(*args,**kwargs)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;添加新功能的位置，在被装饰的函数执行之后执行&quot;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">return</span> fun_use_add_fact<br>    <span class="hljs-keyword">return</span> fun_use_add<br><span class="hljs-meta">@fun_use_parameter(<span class="hljs-params"><span class="hljs-number">2</span>,<span class="hljs-number">5</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fun_use</span>(<span class="hljs-params">a</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行正常功能中&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,a,<span class="hljs-number">2</span>):<br>        <span class="hljs-built_in">print</span>(i,end=<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n执行完毕&quot;</span>)<br>result = fun_use(<span class="hljs-number">11</span>)<br><span class="hljs-keyword">if</span> result:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行成功&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之前执行</span><br><span class="hljs-comment"># 第1次执行函数功能,函数功能序号为5</span><br><span class="hljs-comment"># 执行正常功能中</span><br><span class="hljs-comment"># 1,3,5,7,9,</span><br><span class="hljs-comment"># 执行完毕</span><br><span class="hljs-comment"># 第2次执行函数功能,函数功能序号为5</span><br><span class="hljs-comment"># 执行正常功能中</span><br><span class="hljs-comment"># 1,3,5,7,9,</span><br><span class="hljs-comment"># 执行完毕</span><br><span class="hljs-comment"># 添加新功能的位置，在被装饰的函数执行之后执行</span><br><span class="hljs-comment"># 执行成功</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——函数(二)</title>
    <link href="/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%BA%8C)/"/>
    <url>/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="三函数调用"><a href="#三函数调用" class="header-anchor">¶</a>（三）函数调用</h3><h4 id="1-基本内容"><a href="#1-基本内容" class="header-anchor">¶</a>1. 基本内容：</h4><p>定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p><p>Python中需要显式说明函数的调用，并为其指定参数（如需要参数）完成函数功能。</p><p>函数的调用可以是直接调用，可以是通过另一个函数调用来执行，也可以直接用Python提示符执行。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def caixukun():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;小黑子露出鸡脚了&quot;</span>)<br><br>def usefun():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;usefun&quot;</span>,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;,&quot;</span>)<br>    caixukun()<br><br>usefun()<br>caixukun()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># usefun,小黑子露出鸡脚了</span><br><span class="hljs-comment"># 小黑子露出鸡脚了</span><br></code></pre></td></tr></table></figure><h4 id="2-内置函数"><a href="#2-内置函数" class="header-anchor">¶</a>2. 内置函数：</h4><p>Python中提供了众多的内置函数，这些函数不需要我们定义，可以直接调用。</p><p>一旦我们定义了与内置函数名相同的函数名，就会覆盖内置函数，但因为一般内置函数会有参数检查，所以不建议直接覆盖定义。</p><p>具体的内置函数种类众多，数量巨大，这里不一一讲述，详细函数根据需要查询使用即可。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hsp">result = <span class="hljs-keyword">input</span>(<span class="hljs-string">&quot;请输入内容:&quot;</span>)<br><span class="hljs-keyword">print</span>(result)<br>def <span class="hljs-keyword">input</span>():<br>    <span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;input变为print，输出了1&quot;</span>)<br><span class="hljs-keyword">input</span>()<br><span class="hljs-meta"># 运行结果:</span><br><span class="hljs-meta"># 请输入内容:<span class="hljs-number">10</span></span><br><span class="hljs-meta"># <span class="hljs-number">10</span></span><br><span class="hljs-meta"># input变为print，输出了<span class="hljs-number">1</span></span><br></code></pre></td></tr></table></figure><h4 id="3-参数传递"><a href="#3-参数传递" class="header-anchor">¶</a>3. 参数传递：</h4><p>在调用函数时，通常会传递参数，函数内部的代码保持不变，针对不同的参数处理不同的数据。</p><p><strong>形参和实参</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p>形参是定义函数时的参数变量，Python中没有类型，主要是为了代码块的使用和确定参数数量。</p></li><li class="lvl-2"><p>实参是调用函数时使用的实际参数变量。</p></li><li class="lvl-2"><p>参数传递实际就是<strong>把实参的引用传递给形参，使用实参的值来执行函数体的过程。</strong></p></li></ul><p>Python中，类型属于对象，变量是没有类型的——变量是一个对象的引用（或者说是指针），因此函数中的参数没有类型，在传递时必须考虑传递的参数类型是否能够符合要求，不会引发错误。</p><h5 id="1可更改和不可更改对象"><a href="#1可更改和不可更改对象" class="header-anchor">¶</a>（1）可更改和不可更改对象：</h5><p>详见之前的博客——<a href="https://07xiaohei.com/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%80)%E7%AE%80%E4%BB%8B/">python基础——数据类型（一）简介 - ZZHの个人博客 (07xiaohei.com)</a></p><p>了解了这个之后，就可以说明参数传递的底层实现了。</p><p>从结果上看，Python的参数传递中，可变类型的参数传递类似于c<ins>的引用传递，被传递的实参对象在函数中修改时<strong>会影响</strong>到外部的对象；而不可变类型的参数传递类似于c</ins>的值传递，被传递的实参对象在函数中进行任何修改<strong>不会影响</strong>到外部的对象，因为实际上传递时<strong>实参对象是被复制了一份进入了函数</strong>，原对象不会受到其影响。</p><p>而实际上，Python的参数传递是<strong>赋值传递，即对象的引用传递</strong>，由于Python的所有数据类型都是对象，所以参数传递实际上是复制出新的变量，让新的变量和原变量指向一个相同的对象。</p><p>——换言之，Python里的参数传递，外部的变量和函数的变量指向的是一个具体的对象，不是一个具体的内存地址。因此对象可变时，改变对象，所有指向这个对象的变量都会改变，表现为引用传递；而对象不可变时，赋值等操作实际是创建了一个新的对象并让函数的变量指向新的对象，这样无论如何修改自然不会影响到外部变量指向的对象，此时表现为了值传递。</p><p>下面通过几个例子来加深理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">addn</span>(<span class="hljs-params">nn,k</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(nn))<br>    nn = nn+k<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(nn))<br>    <span class="hljs-built_in">print</span>(nn)<br>n = <span class="hljs-number">3</span><br>addn(n,<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(n))<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 140709379830632</span><br><span class="hljs-comment"># 140709379830792</span><br><span class="hljs-comment"># 8</span><br><span class="hljs-comment"># 140709379830632</span><br><span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><p>从上面可以看出，外部变量n和函数传递变量nn指向的对象开始是相同的，都是id为140709379830632的对象，而进行了赋值操作后，nn指向的对象发生了改变，对应了140709379830792，和原来不同，所以其对象值的改变不会影响到外部变量n，因此表现为了值传递。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def addn(n,k):<br>    <span class="hljs-built_in">print</span>(id(n))<br>    <span class="hljs-built_in">print</span>(id(n[0]))<br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-built_in">print</span>()<br>    n[0] = n[0]+k<br>    <span class="hljs-built_in">print</span>(id(n))<br>    <span class="hljs-built_in">print</span>(id(n[0]))<br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-built_in">print</span>()<br>n= [1,2,3,4]<br><span class="hljs-built_in">print</span>(id(n))<br><span class="hljs-built_in">print</span>(id(n[0]))<br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-built_in">print</span>()<br>addn(n,5)<br><span class="hljs-built_in">print</span>(id(n))<br><span class="hljs-built_in">print</span>(id(n[0]))<br><span class="hljs-built_in">print</span>(n)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 2740557338880</span><br><span class="hljs-comment"># 140709379830568</span><br><span class="hljs-comment"># [1, 2, 3, 4]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2740557338880</span><br><span class="hljs-comment"># 140709379830568</span><br><span class="hljs-comment"># [1, 2, 3, 4]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2740557338880</span><br><span class="hljs-comment"># 140709379830728</span><br><span class="hljs-comment"># [6, 2, 3, 4]</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 2740557338880</span><br><span class="hljs-comment"># 140709379830728</span><br><span class="hljs-comment"># [6, 2, 3, 4]</span><br></code></pre></td></tr></table></figure><p>这里就可以明显的看出实际的变化了。</p><p>首先，n变量指向了一个列表对象，id为2740557338880，此时n[0]也指向了一个number对象，id为140709379830568，输出为1,2,3,4</p><p>然后传入函数，生成函数变量n，这个n和外部变量n的指向全部都是相同的对象，说明了传递的底层逻辑。</p><p>再进行赋值操作，n[0]指向的对象发生了改变，id变为了140709379830728，但是注意，n的指向没有发生改变，所以内外的变量n访问n[0]指向对象时都是赋值之后的n[0]，表现为了引用传递，内外的输出均变为6,2,3,4——其实质，就是因为列表可变，而number不可变导致的。</p><p>综上，如果想要通过函数来改变某个变量的值，可以直接将可变数据类型当作参数传入，直接进行修改，也可以针对不可变数据类型，创建一个新对象，来保存修改后的值，然后将其返回给原变量完成修改。</p><p>一般建议使用第二种方式，因为其简明易懂，不易出错。</p><h5 id="2参数类型"><a href="#2参数类型" class="header-anchor">¶</a>（2）参数类型：</h5><ul class="lvl-0"><li class="lvl-2"><p>位置参数：必须以在被调用函数中的定义的准确顺序来传递。</p><p>当不含默认参数时，传入函数的参数数量必须和声明时的参数数量相一致。</p><p>是最普通的传递方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_three</span>(<span class="hljs-params">a,b,c</span>):<br>    <span class="hljs-keyword">return</span> a+b+c<br><span class="hljs-built_in">print</span>(add_three(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>关键字参数（命名参数）：和函数调用密切相关，函数调用使用关键字参数来确定传入参数值。</p><p>关键字参数允许函数调用的参数顺序和声明的不一致，由解释器用参数名来匹配参数值。</p><p>调用的形参列表格式：<em><strong>参数名k1=实参值1，参数名k2=实参值2，......，参数名kn=实参值n</strong></em></p><p>关键字参数必须在位置参数的后面，否则解释器不能识别结果。</p><p>了解即可，一般不常用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def add_three(a,b,c):<br>    return a+b<span class="hljs-number">*2</span>+c<span class="hljs-number">*3</span><br><span class="hljs-built_in">print</span>(add_three(<span class="hljs-attribute">c</span>=1,a=2,b=3))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 11 （2+3*2+1*3）</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>默认值参数：为一个参数指定默认值，如果没有给该参数传值，则按默认值传入处理。</p><p>具有默认值的参数也叫做缺省参数。</p><p>缺省参数应当在参数列表的末尾。也就是默认参数必须在所有位置参数的后面设定，否则解释器不能准确识别对应结果。</p><p>调用时，允许参数数量在所有位置参数数量和全部参数数量之间，赋值从左到右逐个进行，剩余则使用默认参数。</p><p>注意：默认值只会执行一次，当默认值为可变对象时，要注意多次调用可能会出现每次结果保留了上次调用结果的可能性。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def add_two_three(a,b,<span class="hljs-attribute">c</span>=0):<br>    return a+b+c<br><span class="hljs-built_in">print</span>(add_two_three(1,2))<br><span class="hljs-built_in">print</span>(add_two_three(3,4,5))<br>def app(<span class="hljs-attribute">i</span>=0,list_use = [] ):<br>    list_use.append(i)<br>    <span class="hljs-built_in">print</span>(list_use)<br>app()<br>app(1)<br>app(2)<br>app(3)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 12</span><br><span class="hljs-comment"># [0]</span><br><span class="hljs-comment"># [0, 1]</span><br><span class="hljs-comment"># [0, 1, 2]</span><br><span class="hljs-comment"># [0, 1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>默认参数可以和关键字参数一起使用：</p><p>关键字参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要。这也包括非可选参数。不能对同一个参数多次赋值。</p></li><li class="lvl-2"><p>不定长参数（多值参数）：函数处理参数个数不能确定时使用，对于参数个数可能超过声明时个数需要声明多值参数将多出的参数打包处理。</p><p>Python的多值参数有两种：</p><ul class="lvl-2"><li class="lvl-4"><p>接收元组的参数包：参数名前加一个*，一般用*args表示。</p></li><li class="lvl-4"><p>接收字典的参数包：参数名前加两个**，一般用**kwargs表示。</p></li></ul><p>形参列表的格式为：<em><strong>([formal_args,] *var_args_tuple ): / ([formal_args,] **var_kwargs_dict):</strong></em></p><p>增加的*和**就是解包的表现。</p><p>解包参数列表：当参数在列表或者元组中，又需要为单独的位置参数的函数提供参数时，通过对其解包完成参数传递。</p><p>对于元组，每个元素作为一个参数传递，按顺序进行；对于字典，参数名作为键，参数传入值作为值，形成键值对完成传递。</p><p><strong>强制命名参数</strong>：如果有其他参数被定义到了多值参数的后面，称为强制命名参数，调用时必须显式使用关键字参数传递值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">def</span> add_many(*args):<br>    <span class="hljs-attribute">print</span>(args)<br>    <span class="hljs-attribute">count</span>=<span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in args:<br>        <span class="hljs-attribute">count</span> =count+i<br>    <span class="hljs-attribute">print</span>(count)<br><span class="hljs-attribute">add_many</span>(<span class="hljs-number">1</span>)<br><span class="hljs-attribute">add_many</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><span class="hljs-attribute">add_many</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-attribute">add_many</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)<br><span class="hljs-attribute">tuple_temp</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>)<br><span class="hljs-attribute">add_many</span>(*tuple_temp)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># (1,)</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># (1, 2)</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># (1, 2, 3)</span><br><span class="hljs-comment"># 6</span><br><span class="hljs-comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="hljs-comment"># 45</span><br><span class="hljs-comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9)</span><br><span class="hljs-comment"># 45</span><br><span class="hljs-attribute">def</span> add_many(**kwargs):<br>    <span class="hljs-attribute">count</span>=<span class="hljs-number">0</span><br>    <span class="hljs-attribute">for</span> i in kwargs.values():<br>        <span class="hljs-attribute">count</span> = count+int(i)<br>    <span class="hljs-attribute">print</span>(count)<br>    <span class="hljs-attribute">print</span>(kwargs)<br><span class="hljs-attribute">temp</span> =&#123;&#x27;a&#x27;:&#x27;<span class="hljs-number">1</span>&#x27;,&#x27;b&#x27;:&#x27;<span class="hljs-number">2</span>&#x27;,&#x27;c&#x27;:&#x27;<span class="hljs-number">3</span>&#x27;&#125;<br><span class="hljs-attribute">add_many</span>(**temp)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 6</span><br><span class="hljs-comment"># &#123;&#x27;a&#x27;: &#x27;1&#x27;, &#x27;b&#x27;: &#x27;2&#x27;, &#x27;c&#x27;: &#x27;3&#x27;&#125;</span><br><br><span class="hljs-attribute">def</span> add_three(a,b,c):<br>    <span class="hljs-attribute">return</span> a+b*<span class="hljs-number">2</span>+c*<span class="hljs-number">3</span><br><span class="hljs-attribute">list_temp</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-attribute">print</span>(add_three(*list_temp))<br><span class="hljs-attribute">dict_temp</span>=&#123;&#x27;b&#x27;:<span class="hljs-number">1</span>,&#x27;a&#x27;:<span class="hljs-number">2</span>,&#x27;c&#x27;:<span class="hljs-number">3</span>&#125;<br><span class="hljs-attribute">print</span>(add_three(**dict_temp))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 14</span><br><span class="hljs-comment"># 13</span><br><br><span class="hljs-attribute">def</span> add_more_solid(*args,solid):<br>    <span class="hljs-attribute">count</span>=solid<br>    <span class="hljs-attribute">for</span> i in args:<br>        <span class="hljs-attribute">count</span> =count + i<br>    <span class="hljs-attribute">print</span>(count)<br><span class="hljs-attribute">tuple_temp</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br><span class="hljs-attribute">add_more_solid</span>(*tuple_temp,solid =<span class="hljs-number">10</span>)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 25</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4内嵌函数"><a href="#4内嵌函数" class="header-anchor">¶</a>4.内嵌函数：</h4><p>在一个函数内创建另一个函数，通常还需要在其中调用，一旦脱离函数，创建的函数也不能够再使用了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_three</span>(<span class="hljs-params">a,b,c</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two</span>(<span class="hljs-params">x,y</span>):<br>        <span class="hljs-built_in">print</span>(x+y)<br>        <span class="hljs-keyword">return</span> x+y<br>    <span class="hljs-keyword">return</span> add_two(a,b)+c<br><span class="hljs-built_in">print</span>(add_three(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 6</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——函数(一)</title>
    <link href="/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%80)/"/>
    <url>/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述</h3><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段，能提高应用的模块性，和代码的重复利用率。</p><h4 id="1-基本概念"><a href="#1-基本概念" class="header-anchor">¶</a>1. 基本概念：</h4><p>函数用于在程序中分离不同的任务，主要目的是代码的复用，也就是同一块代码的执行特定功能的重复使用，定义和使用函数是Python程序设计的重要组成部分。</p><p>函数允许自己调用自己，此过程称为递归调用。</p><h4 id="2-函数功能"><a href="#2-函数功能" class="header-anchor">¶</a>2. 函数功能：</h4><ul class="lvl-0"><li class="lvl-2"><p>实现特定功能：通过函数完成特定功能的设计，可以实现各种复杂算法。</p></li><li class="lvl-2"><p>结构化程序设计：通过把程序分割为不同的功能模块可以实现自顶向下的结构化设计。</p></li><li class="lvl-2"><p>减少程序的复杂度：简化程序的结构，提高程序的可阅读性。</p></li><li class="lvl-2"><p>实现代码复用：一次定义多次调用,实现代码的可重用性。</p></li><li class="lvl-2"><p>提高代码的质量：实现分割后子任务的代码相对简单，易于开发、调试、修改和维护。</p></li><li class="lvl-2"><p>协作开发：在将大型项目分割成不同的子任务后，团队多人可以分工合作，同时进行协作开发。</p></li></ul><h4 id="3-函数分类"><a href="#3-函数分类" class="header-anchor">¶</a>3. 函数分类：</h4><ul class="lvl-0"><li class="lvl-2"><p>内置函数：Python语言的内置函数，在程序中可以直接使用，是一些常用的函数。</p></li><li class="lvl-2"><p>标准库函数：Python语言中有一些标准库，是特定功能/程序的集合，通过import导入标准库后可以使用标准库的函数简化程序实现。</p></li><li class="lvl-2"><p>第三方库函数：Python语言中的社区开发的其他库，由用户开发，功能繁多，可以根据需要下载、安装、导入再使用其定义的函数。</p></li><li class="lvl-2"><p>用户自定义的函数，如何利用Python语言定义、使用自己的函数。</p></li></ul><p>下面分别说明函数的定义、调用和函数式编程。</p><h3 id="二定义"><a href="#二定义" class="header-anchor">¶</a>（二）定义</h3><h4 id="1-格式及语法"><a href="#1-格式及语法" class="header-anchor">¶</a>1. 格式及语法：</h4><p><em><strong>def functionname( parameters ):</strong></em></p><p>​<em><strong>&quot;函数_文档字符串&quot;</strong></em></p><p>​<em><strong>function_suite</strong></em></p><p>​<em><strong>return [expression]</strong></em></p><ul class="lvl-0"><li class="lvl-2"><p>def：定义函数的关键词，必须包含。</p></li><li class="lvl-2"><p>functionname：函数标识符，也就是函数名，是我们调用函数时的使用依据。</p></li><li class="lvl-2"><p>(parameters)：形参列表，在**”()“<strong>内定义函数需要使用的参数，多个参数用</strong>”,“<strong>分割，允许使用空形参列表定义函数，但是不能省略</strong>“()”<strong>和后面的</strong>”:“**</p><p>形参列表用于接收调用传入的各种参数，形参数量和使用/传入类型必须一一匹配，但注意形参列表中是不需要说明参数类型的，主要是使用时进行检查</p></li><li class="lvl-2"><p>&quot;函数_文档字符串&quot;：函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。</p><p>现在不建议直接使用此格式，用注释即可完成说明。</p><p>如果要使用，可以通过调用Python的help()内置函数或者_doc_属性来查看某个函数的使用说明文档</p></li><li class="lvl-2"><p>function_suite：执行语句代码块，利用传入的函数和内部的代码完成函数要执行的功能，是函数的主体，允许没有此代码块。</p><p>函数的执行会引入一个用于函数局部变量的新符号表，此局部符号表存储了所有新定义的变量和传入的参数变量，而如果是变量引用，会首先在最内层的局部符号表中查找，然后是外层函数的局部符号表，再然后是全局符号表，最后是内置名称的符号表。</p><p>在函数被调用时，实际参数(实参)会被引入被调用函数的本地符号表中——<strong>实参是通过按值调用传递的，值是对象引用而不是对象的值)</strong>。</p><p>函数调用另一个函数，会为其创建一个新的本地符号表，新局部符号表被视为内部的符号表。</p><p>实质：变量作用域从内向外递归查找。</p><p>重命名机制：函数定义会把函数名也引入到符号表中，其类型为用户定义函数类型，此值因此可以<strong>分配给一个新的名称，新名称即可作为函数使用</strong>。</p></li><li class="lvl-2"><p>return [expression]：返回值，函数执行命令的处理结果被返回，如果不需要返回值可以不写return，但是实际上还是有函数默认返回值None。</p><p>一般情况下需要设置指定返回值，返回值可以返回多个对象，对象间用”,“进行分割，当为多个返回类型时，返回类型被视为一个元组，因此其返回值的保存需要按照元组的赋值来进行。</p></li></ul><h4 id="2-定义的四个基本类型"><a href="#2-定义的四个基本类型" class="header-anchor">¶</a>2. 定义的四个基本类型：</h4><h5 id="1无参数无返回值通常是执行一些固定的内容"><a href="#1无参数无返回值通常是执行一些固定的内容" class="header-anchor">¶</a>（1）无参数无返回值，通常是执行一些固定的内容。</h5><p>例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def my_print_defalut():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你干嘛，哎呦~&quot;</span>)<br>def my_sleep_onetime():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;运行中&quot;</span>)<br>    <span class="hljs-attribute">i</span>=0<br>    <span class="hljs-keyword">while</span> i&lt;100000000:<br>        <span class="hljs-attribute">i</span>=i+1<br>my_sleep_onetime()<br>my_print_defalut()<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 运行中</span><br><span class="hljs-comment"># 你干嘛，哎呦~</span><br></code></pre></td></tr></table></figure><h5 id="2无参数有返回值用于获得一些需要的固定内容"><a href="#2无参数有返回值用于获得一些需要的固定内容" class="header-anchor">¶</a>（2）无参数有返回值，用于获得一些需要的固定内容：</h5><p>多个return语句也只会返回第一个执行的return结果</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_input_number</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;请只输入数字&quot;</span>)<br>    temp = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">if</span> temp.isdigit():<br>        <span class="hljs-keyword">return</span> temp<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>result = my_input_number()<br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 请只输入数字</span><br><span class="hljs-comment"># abc</span><br><span class="hljs-comment"># None</span><br><span class="hljs-comment"># 请只输入数字</span><br><span class="hljs-comment"># 1234</span><br><span class="hljs-comment"># 1234</span><br></code></pre></td></tr></table></figure><h5 id="3有参数无返回值可以用于参数的输出或者参数的一些操作等等"><a href="#3有参数无返回值可以用于参数的输出或者参数的一些操作等等" class="header-anchor">¶</a>（3）有参数无返回值，可以用于参数的输出或者参数的一些操作等等。</h5><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_twonum</span>(<span class="hljs-params">a,b</span>):<br>    c = a + b<br>    <span class="hljs-built_in">print</span>(a+b)<br>add_twonum(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_str_index3</span>(<span class="hljs-params"><span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>[<span class="hljs-number">2</span>])<br>get_str_index3(<span class="hljs-string">&quot;abcd&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 5</span><br><span class="hljs-comment"># c</span><br></code></pre></td></tr></table></figure><h5 id="4有参数有返回值最常用"><a href="#4有参数有返回值最常用" class="header-anchor">¶</a>（4）有参数有返回值，最常用。</h5><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_abs</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">0</span>:<br>        n=-n<br>    <span class="hljs-keyword">return</span> n<br><span class="hljs-built_in">print</span>(get_abs(-<span class="hljs-number">2</span>))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">abs_to_num</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> n,-n<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-built_in">print</span>(abs_to_num(<span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(abs_to_num(-<span class="hljs-number">3</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># (3, -3)</span><br><span class="hljs-comment"># None</span><br></code></pre></td></tr></table></figure><h4 id="3-全局和局部变量"><a href="#3-全局和局部变量" class="header-anchor">¶</a>3. 全局和局部变量：</h4><p>变量声明的位置不同,其可以被访问的范围也不同。变量的可被访问范围称为变量的作用域。变量按其作用域大致可以分为全局变量、局部变量和类成员变量。</p><h5 id="1全局变量"><a href="#1全局变量" class="header-anchor">¶</a>（1）全局变量：</h5><p>在函数和类定义之外声明的变量称为全局变量，其作用域只在定义的模块之内，从其定义的位置开始，直到模块结束的位置。</p><p>单个模块的变量可以通过import引入访问。</p><p>不同引入模块都可以使用全局变量，多语句对其的修改可能会导致全局变量的管理混乱，降低模块之间的通用性和可读性，应当尽量避免使用去全局变量反复修改，而是作为常量使用。</p><h5 id="2局部变量"><a href="#2局部变量" class="header-anchor">¶</a>（2）局部变量：</h5><p>在函数中定义的变量和参数变量都是局部变量，作用域范围只在函数体内，一旦脱离作用域，不允许被使用。</p><p>全局代码不能用局部变量，不同函数之间的局部变量也不可以互相使用。</p><p>重名的局部变量会覆盖全局变量。</p><h5 id="3global语句和nonlocal语句"><a href="#3global语句和nonlocal语句" class="header-anchor">¶</a>（3）global语句和nonlocal语句：</h5><p>如果想要在函数中直接使用全局变量，需要在函数内对变量增加global声明，此时是显式说明不使用局部变量，而是使用全局变量。</p><p>同样的，对于多个函数的嵌套，可以用nonlocal完成相对应的功能。</p><p>例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">n = <span class="hljs-number">10</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_use</span>(<span class="hljs-params">a</span>):<br>    i=<span class="hljs-number">5</span><br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-built_in">print</span>(i+a)<br>    <span class="hljs-built_in">print</span>(n+a)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_use_2</span>(<span class="hljs-params">b</span>):<br>        j=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">nonlocal</span> i<br>        <span class="hljs-built_in">print</span>(j+b)<br>        <span class="hljs-built_in">print</span>(i+b)<br>    add_use_2(a)<br>add_use(<span class="hljs-number">20</span>)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 25</span><br><span class="hljs-comment"># 30</span><br><span class="hljs-comment"># 21</span><br><span class="hljs-comment"># 25</span><br></code></pre></td></tr></table></figure><h4 id="4-进阶匿名函数"><a href="#4-进阶匿名函数" class="header-anchor">¶</a>4. 进阶：匿名函数</h4><p>python 使用 <strong>lambda 来创建匿名函数</strong>。（lambda是一个关键字）</p><p>匿名是指不适用def的标准形式来定义函数。</p><p>匿名函数可以省略定义函数的过程，主要目的是精简代码，减少函数命名，便于理解代码和避免只用一次的函数被定义而增大工作量。</p><h5 id="1语法"><a href="#1语法" class="header-anchor">¶</a>（1）语法：</h5><p>lambda函数的语法只包含一个语句：</p><p><em><strong>&lt;variable&gt;=lambda [arg1 [,arg2,.....argn]]:expression</strong></em></p><p>实际上，等价于：</p><p><em><strong>&lt;变量&gt;=lambda 参数列表：return [表达式] 变量</strong></em></p><p>variable表示对lambda的封装，也就是实际上让这个变量作为了一个函数名，很多时候可以省略，省略时就是真正的匿名函数。</p><p>arg1,2......n表示的是参数，对应参数列表，expression则是表达式，对应的是返回值的表达式变量。</p><h5 id="2说明"><a href="#2说明" class="header-anchor">¶</a>（2）说明：</h5><ul class="lvl-0"><li class="lvl-2"><p>lambda返回的是函数对象（构建的是一个函数对象），所以需要定义一个变量去接收</p></li><li class="lvl-2"><p>lambda 只是一个表达式，函数体比 def 简单很多。</p></li><li class="lvl-2"><p>lambda的主体是一个表达式，而不是一个代码块，所以仅仅能在lambda表达式中封装有限的逻辑</p></li><li class="lvl-2"><p>lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数</p></li></ul><h5 id="3例子"><a href="#3例子" class="header-anchor">¶</a>（3）例子：</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> = lambda x,y:x*y</span><br>fun2 =lambda x:len(x)<br>print(<span class="hljs-string">&quot;add result:&quot;</span>,(lambda a, b:a+b)(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>))<br>print(<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)</span></span>)<br>print(fun2(<span class="hljs-string">&quot;我的心总是不安&quot;</span>))<br>#运行结果：<br># add result: <span class="hljs-number">3</span><br># <span class="hljs-number">12</span><br># <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——循环</title>
    <link href="/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF/"/>
    <url>/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="一循环语句"><a href="#一循环语句" class="header-anchor">¶</a>（一）循环语句</h3><p>程序在一般情况下是按顺序执行的，而循环语句允许我们执行一个代码块多次。</p><p>Python中的循环允许嵌套。</p><h3 id="二循环结构类型"><a href="#二循环结构类型" class="header-anchor">¶</a>（二）循环结构类型</h3><p>Python中提供了以下两种基础循环结构，注意，Python中没有do-while循环：</p><ul class="lvl-0"><li class="lvl-2"><p>for...in...</p></li><li class="lvl-2"><p>while</p></li></ul><h4 id="1-for循环"><a href="#1-for循环" class="header-anchor">¶</a>1. for循环：</h4><h5 id="1语句格式"><a href="#1语句格式" class="header-anchor">¶</a>（1）语句格式：</h5><p>for iterating_var in sequence:statements(s)</p><p>iterating_val就是迭代变量，可以是一个变量或者一个索引，sequence则是一个序列，也就是循环体，而statement(s)对应了一个循环语句块，对应了循环执行内容。</p><p>其逻辑为：将一个序列对应的表达式列表的第一项分配给迭代变量，然后执行循环语句块，完成后将表达式列表的下一项再分配给迭代变量，再次执行循环语句块，直到序列被完成。注意，迭代变量可以是序列的索引，利用索引和偏移量遍历序列。</p><p>简单的例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">str = <span class="hljs-string">&quot;love everyone&quot;</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> str:<br>    <span class="hljs-built_in">print</span>(char,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-built_in">print</span>()<br>list1 = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list1:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;,&quot;</span>)<br></code></pre></td></tr></table></figure><h5 id="2range"><a href="#2range" class="header-anchor">¶</a>（2）range()：</h5><p>range是一个函数，它返回的是一个可迭代对象，在for in循环中使用于创建数字序列。</p><p>函数格式：<em><strong>range(stop)<em><strong>和</strong></em>range(start, stop[, step])</strong></em></p><p>start表示计数初值，不输入默认为0，stop表示计数终值，必须指定，且不包括stop计数终值本身（因为实际上结束值表示的是下标），[,step]是指从初值到终值的步长，可以省略，默认值就是1。</p><p>参数对应：一个参数——stop；两个参数——start和stop；三个参数——start，stop和step。</p><p>注意事项：</p><ul class="lvl-0"><li class="lvl-2"><p>range()函数仅适用于整数，且所有参数都必须是整数类型。</p></li><li class="lvl-2"><p>range()函数的对应区间是左闭右开</p></li><li class="lvl-2"><p>如果初值为0，步长为1，都可以省略，但不能只省略初值不省略步长。</p></li><li class="lvl-2"><p>步长值可以为正数或负数，不得为零，初值必须能够通过步长值指向对方（不能越离越远）。</p></li><li class="lvl-2"><p>用户可以按索引访问range()中的项目。</p></li></ul><p>简单的例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(6):<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(3,8):<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(4,10,2):<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(8,4,-1):<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(8,3,-2):<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()<br>list2 = [<span class="hljs-string">&quot;鸡&quot;</span>, <span class="hljs-string">&quot;你&quot;</span>, <span class="hljs-string">&quot;太&quot;</span>, <span class="hljs-string">&quot;美&quot;</span>]<br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(list2)):<br>   <span class="hljs-built_in">print</span> (list2[index],<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="2-while循环"><a href="#2-while循环" class="header-anchor">¶</a>2. while循环：</h4><h5 id="1语句格式"><a href="#1语句格式" class="header-anchor">¶</a>（1）语句格式：</h5><p><em><strong>while condition：</strong></em><em><strong>statements(s)</strong></em></p><p>condition是判断条件，使用一个条件表达式来完成判断是否结束循环。</p><p>判断条件为假时结束循环。</p><p>while循环和for...in循环的不同之处在于while循环要先将循环变量初始化或者直接使用while True死循环，不能直接在表达式中定义变量。</p><p>简单的例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs routeros">i =0<br><span class="hljs-keyword">while</span> i&lt;=10:<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-attribute">i</span>=i+1<br><span class="hljs-keyword">while</span> i&gt;2:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;enter the while1&quot;</span>)<br><span class="hljs-keyword">while</span> i&lt;2:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;enter the while2&quot;</span>)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 0</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 5</span><br><span class="hljs-comment"># 6</span><br><span class="hljs-comment"># 7</span><br><span class="hljs-comment"># 8</span><br><span class="hljs-comment"># 9</span><br><span class="hljs-comment"># 10</span><br><span class="hljs-comment"># enter the while1</span><br><span class="hljs-comment"># enter the while1</span><br><span class="hljs-comment"># enter the while1</span><br><span class="hljs-comment"># ......</span><br><br>j = 1<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(j)<br>    <span class="hljs-attribute">j</span>=j+1<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 5</span><br><span class="hljs-comment"># ......</span><br></code></pre></td></tr></table></figure><h4 id="3-循环和else配合使用"><a href="#3-循环和else配合使用" class="header-anchor">¶</a>3. 循环和else配合使用：</h4><p>for/while可以和else组合使用。</p><p>格式：</p><p><em><strong>循环语句</strong></em></p><p><em><strong>else:</strong></em></p><p>​<em><strong>代码块</strong></em></p><p>循环语句就是普通的for和while语句，而else中的语句会在循环正常执行完（即循环不是通过break跳出而中断的）的情况下执行.</p><p>简单例子如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,3):<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;再多看一眼就会爆炸&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 再多看一眼就会爆炸</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,3):<br>    <span class="hljs-built_in">print</span>(i)<br>    break<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;再多看一眼就会爆炸&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h3 id="三breakcontinue和pass"><a href="#三breakcontinue和pass" class="header-anchor">¶</a>（三）break，continue和pass</h3><h4 id="1-break"><a href="#1-break" class="header-anchor">¶</a>1. break：</h4><p>break说明的是退出循环，执行下一命令。</p><p>对于嵌套循环，break退出的是当前代码块的循环，不会全部退出。</p><p>例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;哎呦你干嘛&quot;</span>:<br>    <span class="hljs-built_in">print</span>(i)<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attribute">i</span>==&quot;干&quot;):<br>        break<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 哎</span><br><span class="hljs-comment"># 呦</span><br><span class="hljs-comment"># 你</span><br><span class="hljs-comment"># 干</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,8):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(1,i):<br>        <span class="hljs-built_in">print</span>(j)<br>        <span class="hljs-keyword">if</span>(<span class="hljs-attribute">j</span>==3):<br>            break<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br></code></pre></td></tr></table></figure><h4 id="2-continue"><a href="#2-continue" class="header-anchor">¶</a>2. continue：</h4><p>立刻跳出本次循环，剩余语句也不执行，直接开始下一轮循环。</p><p>嵌套循环逻辑同break。</p><p>例子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;哎呦你干嘛&quot;</span>:<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attribute">i</span>==&quot;干&quot;):<br>        continue<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(1,5):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(1,i):<br>        <span class="hljs-keyword">if</span> <span class="hljs-attribute">j</span>==3:<br>            continue<br>        <span class="hljs-built_in">print</span>(j)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 哎</span><br><span class="hljs-comment"># 呦</span><br><span class="hljs-comment"># 你</span><br><span class="hljs-comment"># 嘛</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><h4 id="3-pass"><a href="#3-pass" class="header-anchor">¶</a>3. pass：</h4><p>空语句，为了保持程序结构的完整性，不做任何事情，只用于占位。</p><p>python3已经不需要必须使用空语句了，不举例子</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——条件判断</title>
    <link href="/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/"/>
    <url>/xiaohei07.github.io/2023/07/11/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="一条件判断"><a href="#一条件判断" class="header-anchor">¶</a>（一）条件判断</h3><p>根据条件的成立情况决定执行哪些代码。</p><h3 id="二if条件判断"><a href="#二if条件判断" class="header-anchor">¶</a>（二）if条件判断</h3><h4 id="1-if语句格式"><a href="#1-if语句格式" class="header-anchor">¶</a>1. if语句格式：</h4><p><strong>if 条件表达式:</strong></p><p>​<strong>if成立后执行代码块</strong></p><p><strong>elif 条件表达式:</strong></p><p>​<strong>elif成立后执行代码块</strong></p><p><strong>elif 条件表达式:</strong></p><p>​<strong>elif成立后执行代码块</strong></p><p><strong>elif 条件表达式:</strong></p><p>​<strong>elif成立后执行代码块</strong></p><p><strong>......</strong></p><p><strong>else:</strong></p><p>​<strong>else成立后执行代码块</strong></p><h4 id="2-if条件语句的限制"><a href="#2-if条件语句的限制" class="header-anchor">¶</a>2. if条件语句的限制：</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>代码块：</strong></p><p>代码块是一组代码作为的一个整体，其执行的选择是统一的（要么执行代码块，要么全部跳过），python作为解释性语言，对一个代码块不是逐个语句读取就解释的，而是读完一个代码块后统一解释一个代码块。</p><p>代码块是一种为代码分组的机制，其作用是组织代码。</p><p>代码块以缩进开始，直至代码恢复到之前的缩进级别时结束，该范围为代码块的作用域，一旦退出代码块范围就退出了作用域范围。</p><p><strong>if判断条件为真时进入代码块，为假时跳过整个代码块。</strong></p></li><li class="lvl-2"><p><strong>多条件判断：</strong></p><p>if语句中没有switch语句，因此只能使用elif作为多条件判断。</p><p>每次if语句只可能执行一个分支或者一个都不执行。</p><p>多个条件符合时，由于if语句是逐个分支判断的，所以只可能执行最上方的满足条件的分支。</p></li><li class="lvl-2"><p><strong>嵌套:</strong></p><p>将一个if语句嵌入到某个分支的代码块中即可完成嵌套。</p><p>python支持任意层次的if语句嵌套。</p></li></ul><h4 id="3-条件表达式"><a href="#3-条件表达式" class="header-anchor">¶</a>3. 条件表达式：</h4><p>可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句，形式不限。</p><p>整体作为一个布尔值被使用，是True和False的一个，判断可以等同于判断其真假。</p><h4 id="4-三目运算"><a href="#4-三目运算" class="header-anchor">¶</a>4. 三目运算：</h4><p>格式：<strong>exp1 if condition else exp2</strong>，exp1和exp2是两个表达是，condition是判断条件。</p><p>如果condition为真，执行exp1，如果为假就执行exp2</p><p>三目运算允许嵌套，嵌套内容相当于在else之后再进行一个三目运算。</p><h3 id="三条件表达式的运算符"><a href="#三条件表达式的运算符" class="header-anchor">¶</a>（三）条件表达式的运算符</h3><h4 id="1-比较运算符"><a href="#1-比较运算符" class="header-anchor">¶</a>1. 比较运算符：</h4><p>包括等于运算符==，不等于运算符!=，大于运算符＞，小于运算符＜，大于等于运算符＞=、小于等于运算符＜=六个基本运算符，另外还有is in两个特殊比较运算符</p><p>基本比较逻辑不再赘述（简单易懂），注意一下字符串的大小比较是一个个字符的比较即可。</p><p>如果想对汉字等特殊字符比较，更换编码格式即可（详见之前的博客）。</p><p>另外，注意Python允许范围比较，即用一个区间判断作为表达式。</p><ul class="lvl-0"><li class="lvl-2"><p>is比较运算符：</p><p>is是Python身份运算符，用于判断两个对象的标识符是否相等（注意，Python中一切皆对象）。</p><p>实际上，is是用于比较左右两方的对应存储位置是否相同。</p><p>注意：None对象是一个单例类的实例，具有唯一的标识号，因此判断对象是否为None时，使用：</p><p><strong>对象 is None</strong>判断其是否为None。</p><p>is的否定一般使用<strong>is not</strong>来表示，不使用not 对象 is .......来表示。</p></li><li class="lvl-2"><p>in比较运算符：</p><p>in是Python的成员检测运算符，用于判断某个元素是否属于某个序列，序列可以是各种集合，包括字符串。</p><p>元素不一定必须是单个的，可以是另一个集合构成的元素，例如可以判断一个字符串是否是另一个字符串的子串。</p></li></ul><h4 id="2-逻辑运算符"><a href="#2-逻辑运算符" class="header-anchor">¶</a>2. 逻辑运算符：</h4><p>包括与运算符<strong>and</strong>，或运算符<strong>or</strong>和非运算符<strong>not</strong>，其中运算优先级<strong>not&gt;and&gt;or</strong>，如果需要改变优先级，使用**()**来修改运算优先级。</p><ul class="lvl-0"><li class="lvl-2"><p>and（逻辑与）：</p><p>and可以对运算符两侧的表达式进行与运算，只有两侧的值均为True时，才会返回True，否则均返回False。</p><p>注意：与运算中，如果第一个表达式已经为False，则直接返回False，不会再判断第二个表达式。</p></li><li class="lvl-2"><p>or（逻辑或）：</p><p>or可以对运算符两侧的表达式进行或运算，只有两侧的值均为False时，才会返回False，否则均返回True。</p><p>注意：或运算中，如果第一个表达式已经为True，则直接返回True，不会再判断第二个表达式。</p></li><li class="lvl-2"><p>not（逻辑非）：</p><p>not可以对运算符右侧的表达式进行非运算，使其最后的布尔值取反。</p></li></ul><p>注意：对非布尔值也可以进行与或运算，Python会将其当做布尔值运算，最终会返回原值。</p><p>与运算：如果第一个值是True，返回第二个值；如果第一个值是False，直接返回第一个值。</p><p>或运算：如果第一个值是False，返回第二个值；如果第一个值是True，直接返回第一个值。</p><h3 id="四运行样例"><a href="#四运行样例" class="header-anchor">¶</a>（四）运行样例</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">value</span> = <span class="hljs-number">25</span><br><span class="hljs-attribute">while</span>(value &gt;= <span class="hljs-number">10</span>):<br>    <span class="hljs-attribute">if</span> value &gt; <span class="hljs-number">20</span> :<br>        <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;value &gt; 20&quot;</span>)<br>        <span class="hljs-attribute">value</span> = <span class="hljs-number">15</span><br>    <span class="hljs-attribute">elif</span> <span class="hljs-number">15</span> &lt;= value &lt;= <span class="hljs-number">20</span>:<br>        <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;15 &lt;= value &lt;= 20&quot;</span>)<br>        <span class="hljs-attribute">value</span> = <span class="hljs-number">10</span><br>    <span class="hljs-attribute">else</span>:<br>        <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;value &lt;15&quot;</span>)<br>        <span class="hljs-attribute">value</span> = <span class="hljs-number">5</span><br><span class="hljs-comment">#运行结果:</span><br><span class="hljs-comment"># value &gt; 20</span><br><span class="hljs-comment"># 15 &lt;= value &lt;= 20</span><br><span class="hljs-comment"># value &lt;15</span><br><br><span class="hljs-attribute">val</span> = <span class="hljs-number">7</span><br><span class="hljs-attribute">if</span> val&gt;<span class="hljs-number">5</span> and val &lt;<span class="hljs-number">8</span>:<br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;val=%d&quot;</span>%val)<br><span class="hljs-attribute">elif</span> val&gt;=<span class="hljs-number">8</span> and val&lt;<span class="hljs-number">10</span>:<br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;val &gt;=8, and val=%d&quot;</span>%val)<br><span class="hljs-attribute">else</span>:<br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;val is no in range&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># val=10:</span><br><span class="hljs-comment"># val is no in range</span><br><span class="hljs-comment"># val =8:</span><br><span class="hljs-comment"># val &gt;=8, and val=8</span><br><span class="hljs-comment"># val =7:</span><br><span class="hljs-comment"># val=7</span><br><br><span class="hljs-attribute">r1</span> = <span class="hljs-number">2</span> and <span class="hljs-number">3</span><br><span class="hljs-attribute">r2</span> = <span class="hljs-number">0</span> and <span class="hljs-number">4</span><br><span class="hljs-attribute">r3</span> = <span class="hljs-number">2</span> or <span class="hljs-number">3</span><br><span class="hljs-attribute">r4</span> = <span class="hljs-number">0</span> or <span class="hljs-number">4</span><br><span class="hljs-attribute">print</span>(r1,r2,r3,r4,sep=&#x27;\n&#x27;)<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 0</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 4</span><br><br></code></pre></td></tr></table></figure><p>更多的运行在实际中检验即可。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法——分治算法(3)</title>
    <link href="/xiaohei07.github.io/2023/04/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95(3)/"/>
    <url>/xiaohei07.github.io/2023/04/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95(3)/</url>
    
    <content type="html"><![CDATA[<!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>algorithm_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——模版(一)</title>
    <link href="/xiaohei07.github.io/2023/04/14/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%A8%A1%E7%89%88(%E4%B8%80)/"/>
    <url>/xiaohei07.github.io/2023/04/14/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%A8%A1%E7%89%88(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<p>全文仅介绍模版的基础内容，后文进行函数模版和类模版的相关实现，再介绍模版的各种特殊情况。</p><h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念：</h3><h4 id="1-泛型编程"><a href="#1-泛型编程" class="header-anchor">¶</a>1. 泛型编程：</h4><ul class="lvl-0"><li class="lvl-2"><p>泛型：在计算机程序设计领域，为了避免因数据类型的不同而重复编写大量逻辑的代码，不使用具体数据类型，而是使用一种通用类型来进行程序设计的方法，大规模减少程序代码的编写量，此为泛型。</p><p>实际上，泛型也是一种数据类型，只不过它是一种用来代替所有类型的“通用类型”。</p></li><li class="lvl-2"><p>泛型编程：是不依赖于某一具体类型而使代码具有很强适应性的编程范式。</p><p>泛型编写的代码不是真正的程序实体，只能算是一个程序实体的样板。</p><p>泛型编程通常将算法从特定的数据结构中抽象出来，成为通用的，其编程依赖于某种形式的多态。</p></li><li class="lvl-2"><p>类属：把函数或类要处理的数据类型参数化，表现为参数的多态性，称为类属。</p><p>——类属（参数化多态）：是<strong>类型</strong>参数化，使用程序可以从逻辑功能上抽象，把被处理的对象类型也作为参数传递。</p><p>用于表达逻辑结构相同，但具体数据根据元素类型不同的数据对象的通用行为。</p></li></ul><h4 id="2-模板"><a href="#2-模板" class="header-anchor">¶</a>2. 模板：</h4><p>模板是一种对类型进行参数化的工具，模板是泛型编程的基础。</p><p>C<ins>提供了模板编程的概念。c</ins>中的模板，实际上是建立一个通用函数或类，其类内部的类型和函数的形参类型不具体指定，用一个虚拟的类型来代表。使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。</p><p>模板功能非常强大，是c<ins>中代码复用的一种常见方式，是c</ins>支持参数化多态的工具，也是许多c++标准库建立的基础，如STL的各种容器库，IO Stream等等。</p><h4 id="3-两者的区别"><a href="#3-两者的区别" class="header-anchor">¶</a>3. 两者的区别：</h4><p>模板是泛型的基础，泛型是模板的推广。</p><ul class="lvl-0"><li class="lvl-2"><p>泛型的具体类型的确定是在程序运行时，而模板的实例化是在编译时确定的；</p></li><li class="lvl-2"><p>泛型无特化（自定义实现特定类型的处理），模板特化可以针对特定类型处理；</p></li><li class="lvl-2"><p>泛型无部分特化，模板有；</p></li><li class="lvl-2"><p>模板支持模板类型的形参（虽然一般不那样做）泛型不可以。</p></li></ul><h3 id="二模板的机制和格式"><a href="#二模板的机制和格式" class="header-anchor">¶</a>（二）模板的机制和格式：</h3><ul class="lvl-0"><li class="lvl-2"><p>模板的声明和定义：只能放在全局，命名空间或者类范围内进行，即不能在局部范围或者函数内部进行，比如不能在main函数中声明和定义一个模板。</p></li><li class="lvl-2"><p>工作原理：模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。</p><p>模板在没有调用之前是不会生成代码的。</p><p>由于编译器并不会直接编译模板本身，所以模板的定义通常放在头文件中。</p></li><li class="lvl-2"><p>格式：</p><p>template&lt;class 形参名1，class 形参名2，...&gt;</p><p>返回类型  函数名（参数列表）{函数体} /class 类名 { 类的内部定义 } ;</p><p>template和class是关键字，形参前的class可以用typename关键字替代，一般情况下typename和class没有什么区别。</p><p>&lt;&gt;里面的参数叫做模板形参，模板形参和函数形参很像，但是模板形参不能为空，一旦声明了模板就可以使用模板形参的形参名作为变量声明、作为返回类型或者作为传入参数，即可以使用内置类型的地方都可以使用模板形参名。</p><p>模板形参在调用该模板相关内容时根据其提供的模板实参类型来初始化模板形参，也就是说一旦编译器确定了实际的模板实参类型就可以称它实例化了模板的一个实例。</p></li><li class="lvl-2"><p>分类：分为函数模版和类模版。</p></li><li class="lvl-2"><p>模板形参作用域：和函数形参/变量类似，是普通的作用域规则。</p></li><li class="lvl-2"><p>模版实例化：</p><p>隐式实例化：在运行期间生成实例，对于某个对象/函数调用，编译器会自动使用提供的模板实参生成具体的函数或类。一般来说，编译器也会从函数的实参中推导出模板实参。（也就是实例化的内容为&lt;T&gt;）</p><p>显式实例化：在编译期间就会生成实例，对于某个对象/函数调用，明确指定T的实例化类型。（实例化的内容为&lt;int&gt;等具体类型）</p><p>问题：</p><p>在我们使用类模板时，只有当代码中使用了类模板的一个实例的名字，而且上下文环境要求必须存在类的定义时，这个类模板才被实例化。</p><ol><li class="lvl-5"><p>声明一个类模板的指针和引用，不会引起类模板的实例化，因为没有必要知道该类的定义。</p></li><li class="lvl-5"><p>定义一个类类型的对象时需要该类的定义，因此类模板会被实例化。</p></li><li class="lvl-5"><p>在使用sizeof()时，它是计算对象的大小，编译器必须根据类型将其实例化出来，所以类模板被实例化.</p></li><li class="lvl-5"><p>new表达式要求类模板被实例化。</p></li><li class="lvl-5"><p>引用类模板的成员会导致类模板被编译器实例化。</p></li><li class="lvl-5"><p>需要注意的是，类模板的成员函数本身也是一个模板。标准C++要求这样的成员函数只有在被调用或者取地址的时候，才被实例化。用来实例化成员函数的类型，就是其成员函数要调用的那个类对象的类型。</p></li></ol></li><li class="lvl-2"><p>实例化优化 ：当模板被调用时才会被编译，那么就会存在这样一种情况——相同的实例化可能出现在多个文件对象中。当两个或多个独立编译地源文件适用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</p><p>为了控制显式实例化，可以用关键字extern显式实例化声明，这表示承诺在程序的其他位置有该实例化的一个非extern声明（定义）。</p><p>由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何用此实例化版本的代码之前。</p></li></ul><h3 id="三简单函数模版和类模版的实现"><a href="#三简单函数模版和类模版的实现" class="header-anchor">¶</a>（三）简单函数模版和类模版的实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(T t1, T t2)</span> <span class="hljs-comment">//简单的模版函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (t1 &gt; t2)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (t1 == t2)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (t1 &lt; t2)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">compare</span> <span class="hljs-comment">//简单的模版类</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>T _val;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">compare</span><span class="hljs-params">(T&amp; val)</span> : _val(val) &#123;</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">compare</span><span class="hljs-params">(T&amp;&amp; val)</span> : _val(val) &#123;</span> &#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(T&amp; t)<br>&#123;<br><span class="hljs-keyword">return</span> _val == t;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——模版(三)</title>
    <link href="/xiaohei07.github.io/2023/04/14/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%A8%A1%E7%89%88(%E4%B8%89)/"/>
    <url>/xiaohei07.github.io/2023/04/14/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%A8%A1%E7%89%88(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>本文介绍模版的各种特殊情况：</p><h3 id="一非类型模板参数通常不应用于函数模版中"><a href="#一非类型模板参数通常不应用于函数模版中" class="header-anchor">¶</a>（一）非类型模板参数（通常不应用于函数模版中）：</h3><ul class="lvl-0"><li class="lvl-2"><p>模板的非类型形参是内置类型形参，模板参数不是一个类型而是一个具体的值，且值是常量表达式，因此调用非类型模板形参的实参必须是一个常量表达式（因此模板代码不能修改参数的值，也不能使用参数的地址）。</p><p>例如template&lt;class T, int a&gt; class B{}; 其中int a就是非类型的模板形参。</p><p>通常能被传入的常量表达式包括全局变量的地址或引用，全局对象的地址或引用const类型变量，sizeof的表达式的结果以及const int 整型变量。</p></li><li class="lvl-2"><p>形参只能是整型，枚举，指针和引用，如double，string等是不可以的，但是可以使用double&amp;或者string*等类型是允许的。</p></li><li class="lvl-2"><p>当一个模板被实例化时，非类型参数被一个用户提供的或者编译器推断出的值所代替。正因为模板在编译阶段编译器为我们生成一个对应的版本，所以其值应该能够编译时确定，那么他应该是一个常量或者常量表达式。</p></li><li class="lvl-2"><p>非类型模板形参的形参和实参间所允许的转换</p><ul class="lvl-2"><li class="lvl-4">允许从数组到指针，从函数到指针的转换。如：template &lt;int *a&gt; class A{}; int b[1]; A&lt;b&gt; m;即数组到指针的转换。</li><li class="lvl-4">const修饰符的转换。如：template&lt;const int *a&gt; class A{}; int b; A&lt;&amp;b&gt; m; 即从int *到const int *的转换。</li><li class="lvl-4">提升转换。如：template&lt;int a&gt; class A{}; const short b=2; A&lt;b&gt; m; 即从short到int的提升转换。</li><li class="lvl-4">整值转换。如：template&lt;unsigned int a&gt; class A{}; A&lt;3&gt; m; 即从int 到unsigned int的转换。</li><li class="lvl-4">常规转换。略。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义一个栈,用数组实现,MAXSIZE为非类型模版类参数,其类型确定</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAXSIZE&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> REALSIZE;<br><span class="hljs-comment">//这个非类型模版类参数可以在类中使用其名称</span><br>T elems[MAXSIZE];<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Stack</span>() :<span class="hljs-built_in">REALSIZE</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> REALSIZE == <span class="hljs-number">0</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">full</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> REALSIZE == MAXSIZE; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp;)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function">T&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> T&amp; <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAXSIZE&gt;<br><span class="hljs-type">void</span> Stack&lt;T, MAXSIZE&gt;::<span class="hljs-built_in">push</span>(<span class="hljs-type">const</span> T&amp; elem)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">full</span>())<br><span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::push(): full stack&quot;</span>);<br>elems[REALSIZE++] = elem;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAXSIZE&gt;<br><span class="hljs-type">void</span> Stack&lt;T, MAXSIZE&gt;::<span class="hljs-built_in">pop</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">empty</span>())<br>REALSIZE--;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>);<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAXSIZE&gt;<br>T&amp; Stack&lt;T, MAXSIZE&gt;::<span class="hljs-built_in">top</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br><span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>);<br><span class="hljs-keyword">return</span> elems[REALSIZE - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> MAXSIZE&gt;<br><span class="hljs-type">const</span> T&amp; Stack&lt;T, MAXSIZE&gt;::<span class="hljs-built_in">top</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">empty</span>())<br><span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>);<br><span class="hljs-keyword">return</span> elems[REALSIZE - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//double类型,类类型不允许作为非类型模版类参数使用</span><br><span class="hljs-comment">//template&lt;typename T, double MAXSIZE,string name&gt;</span><br><span class="hljs-comment">//class A&#123;&#125;;</span><br><br><span class="hljs-comment">//double引用类型,类指针类型允许作为非类型模版类参数使用</span><br><span class="hljs-comment">//枚举也可以，但不再演示</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-type">double</span>&amp; MAXSIZE,string*name&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> REALSIZE;<br>T elems[MAXSIZE];<br>string names;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">double</span> d):<span class="hljs-built_in">REALSIZE</span>(d) &#123; names = *name; &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">const</span> string* p&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ui&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;&#125;;<br><br><span class="hljs-type">double</span> alld = <span class="hljs-number">10.0</span>;<br><span class="hljs-type">double</span>&amp; alldd = alld;<br>string alls = <span class="hljs-string">&quot;帅&quot;</span>;<br>string* allss = &amp;alls;<br>string s[<span class="hljs-number">3</span>] = &#123; <span class="hljs-string">&quot;aaaaaa&quot;</span>,<span class="hljs-string">&quot;bbbbbb&quot;</span>,<span class="hljs-string">&quot;cccccc&quot;</span> &#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//传入常量表达式</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br>Stack&lt;<span class="hljs-type">int</span>, <span class="hljs-number">10</span>&gt; s1;<br>Stack&lt;string, i&gt; s3;<br><br><span class="hljs-comment">//sizeof也可以</span><br>Stack&lt;<span class="hljs-type">double</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">double</span>)&gt; s2;<br><br><span class="hljs-comment">//int ii = 5;</span><br><span class="hljs-comment">//Stack&lt;string, ii&gt; s4; //错误,不能传入非常量变量</span><br><br><span class="hljs-comment">//double d = 10.0;</span><br><span class="hljs-comment">//double&amp; dd = d;</span><br><span class="hljs-comment">//string s = &quot;帅&quot;;</span><br><span class="hljs-comment">//string* ss = &amp;s;</span><br><span class="hljs-comment">//A&lt;int, dd, ss&gt;;   //错误,不能传入局部变量,非常量变量</span><br><br><span class="hljs-comment">//可以使用全局引用和全局变量的局部地址传入</span><br><span class="hljs-function">A&lt;<span class="hljs-type">int</span>, alld, &amp;alls&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">//A&lt;int, alld, allss&gt;; //错误,不能传入全局指针变量</span><br><br><span class="hljs-comment">//可以传入全局数组,会将其转换为指针传入</span><br><span class="hljs-function">A&lt;<span class="hljs-type">double</span>, alld, s&gt; <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">3.14</span>)</span></span>;<br><br><span class="hljs-comment">//可以将string*提升为const string*</span><br>B&lt;<span class="hljs-type">int</span>, &amp;alls&gt; b; <br><br><span class="hljs-comment">//可以将short int提升为int</span><br><span class="hljs-type">const</span> <span class="hljs-type">short</span> bbb = <span class="hljs-number">2</span>;<br>Stack&lt;<span class="hljs-type">char</span>, bbb&gt;;<br><br><span class="hljs-comment">//可以将int提升为unsigned int</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = <span class="hljs-number">9</span>;<br>C&lt;<span class="hljs-type">int</span>, n&gt;;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二默认模板类型形参"><a href="#二默认模板类型形参" class="header-anchor">¶</a>（二）默认模板类型形参：</h3><p>在c++11新规则中，可以为类模板或者函数模版的类型形参提供默认值。</p><p>形式为：<em><strong>template&lt;class T1, class T2, ... , class Tk=默认类型 , ... , class Tn=默认类型 &gt; class 类名{ 类体 };</strong></em></p><p><em><strong>or template&lt;class T1 =默认类型 , class T2, ... , class Tk=默认类型 , ... , class Tn&gt; 返回类型 类型名(形参列表){函数体}</strong></em></p><p>类模版为多个默认模版参数声明指定默认值时，必须遵照“从右往左”的规则进行指定。</p><p>函数模版不需要遵循此规则，可以任意指定默认值。</p><p>函数模板的参数推导规则简单来说就是：能够从函数实参中推导出类型的话，那么默认模版参数就不会被使用，否则使用默认模版参数。</p><p>因此，函数模版如果需要提供默认类型，因为其形参列表是从右往左给出默认值的，所以只有其默认类型也是从右往左给出且与值的类型匹配（也就是不会出现不匹配情况）、值的个数匹配，才是有效的默认类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2 = <span class="hljs-type">int</span>, <span class="hljs-keyword">typename</span> T3=<span class="hljs-type">double</span>&gt;<br><span class="hljs-keyword">class</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>T1 Aval1;<br>T2 Aval2;<br>T3 Aval3;<br>&#125;;<br><span class="hljs-comment">//template &lt;typename T1 = int, typename T2&gt;</span><br><span class="hljs-comment">//class DefClass2 &#123;&#125;;  // 错误:模板参数的默认值没有遵循“由右往左”的规则</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//template &lt;typename T, int i = 0&gt;</span><br><span class="hljs-comment">//class DefClass3 &#123;&#125;;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//template &lt;int i = 0, typename T&gt;</span><br><span class="hljs-comment">//class DefClass4 &#123;&#125;;  // 错误:即使是非类型模版参数,模板参数的默认值也必须遵循“由右往左”的规则</span><br><br><span class="hljs-comment">//尽管可以进行下面这样的声明,但几乎不会用上这个默认类型参数,可以直接无视</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1 = <span class="hljs-type">int</span>, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">B1</span>(T1 a, T2 b) &#123;<br>cout &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;; <span class="hljs-comment">// 函数模板不用遵循“由右往左”的规则</span><br><br><span class="hljs-comment">//允许进行这样的声明,当未提供第二个参数时,自动默认b为int类型且值为0</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2= <span class="hljs-type">int</span>&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">B2</span>(T1 a, T2 b=<span class="hljs-number">0</span>) &#123;<br>cout &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;; <span class="hljs-comment">// 函数模板不用遵循“由右往左”的规则</span><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">B3</span>(T a) &#123;<br>cout &lt;&lt; i &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(i).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;;  <span class="hljs-comment">// 非类型模版参数也不用遵循“由右往左”的规则</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>A&lt;string&gt; a1;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">1.</span>Aval1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">1.</span>Aval2).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//为默认的int</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">1.</span>Aval3).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//为默认的double</span><br>A&lt;<span class="hljs-type">char</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt; a2;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">2.</span>Aval1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">2.</span>Aval2).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//unsigned int覆盖默认的int</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">2.</span>Aval3).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//为默认的double</span><br>A&lt;<span class="hljs-type">char</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>,<span class="hljs-type">float</span>&gt; a3;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">3.</span>Aval1).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">3.</span>Aval2).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//unsigned int覆盖默认的int</span><br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(a<span class="hljs-number">3.</span>Aval3).<span class="hljs-built_in">name</span>() &lt;&lt; endl; <span class="hljs-comment">//float覆盖默认的double</span><br><br><span class="hljs-built_in">B1</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4.1</span>); <span class="hljs-comment">//推导出int,double类型,和默认类型无关</span><br><span class="hljs-built_in">B1</span>(<span class="hljs-number">3.1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//推导出double,int类型,覆盖默认类型</span><br><span class="hljs-built_in">B2</span>(<span class="hljs-string">&quot;s&quot;</span>);    <span class="hljs-comment">//前者推导出const char[2],后者为默认的int且值为0</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//  class std::basic_string&lt;char, struct std::char_traits&lt;char&gt;, class std::allocator&lt;char&gt; &gt;</span><br><span class="hljs-comment">//int</span><br><span class="hljs-comment">//double</span><br><span class="hljs-comment">//char</span><br><span class="hljs-comment">//unsigned int</span><br><span class="hljs-comment">//double</span><br><span class="hljs-comment">//char</span><br><span class="hljs-comment">//unsigned int</span><br><span class="hljs-comment">//float</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//int</span><br><span class="hljs-comment">//4.1</span><br><span class="hljs-comment">//double</span><br><span class="hljs-comment">//3.1</span><br><span class="hljs-comment">//double</span><br><span class="hljs-comment">//4</span><br><span class="hljs-comment">//int</span><br><span class="hljs-comment">//s</span><br><span class="hljs-comment">//char const* __ptr64</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//int</span><br></code></pre></td></tr></table></figure><h3 id="三模版的特化"><a href="#三模版的特化" class="header-anchor">¶</a>（三）模版的特化：</h3><p>模版的特化是模版参数在某种特定类型下的具体实现，是对单一模版提供的一个特殊实例，它将一个或多个模版参数绑定到特定的类型或值上。</p><p>通常情况下，使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可能会得到一些错误的结果，比如字符串不能进行比较，此时就需要特化出一个专门用于字符串的模版参数。</p><p>特化分为函数模版特化和类模版特化：</p><ul class="lvl-0"><li class="lvl-2"><p>函数模板特化：</p><p>必须要先有一个基础的函数模板，且使用特换模板函数时格式有要求：</p><ol><li class="lvl-5"><p>关键字template后面接一对空的尖括号&lt;&gt;。</p></li><li class="lvl-5"><p>函数名&lt;特化类型&gt;（特化类型 参数1， 特化类型 参数2 , …） 在函数名后跟&lt;&gt;其中写要特化的类型。</p></li></ol><p>函数形参表必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误。</p><p>（实际上，此为全特化，c++11中，函数模版也可以进行偏特化的部分特化相似操作，但实际上这是一种重载，会导致函数有多个匹配，此时无法区分；不能进行偏特化的部分限制）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">typename</span> T &gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a &gt; b)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == b)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp; a, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> &amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a, b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>(<span class="hljs-number">4.2</span>, <span class="hljs-number">2.3</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">compare</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)<span class="hljs-string">&quot;vvv&quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span>*)<span class="hljs-string">&quot;ttt&quot;</span>) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>类模版特化：</p><p>分为全特化和偏特化：</p><ul class="lvl-2"><li class="lvl-4"><p>全特化：将模版参数类型中所有的参数都确定化。</p><p>全特化的优先级比偏特化要高。</p></li><li class="lvl-4"><p>偏特化：对于模版的类型进行限制。</p><p>偏特化有两种表现方式：</p><ul class="lvl-4"><li class="lvl-6"><p>部分特化：将模版参数表中的一部分参数特化。</p></li><li class="lvl-6"><p>对于模版类型进行进一步的限制。（如必须特化为指针类型、引用类型）</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//类模版</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Data</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;T1,T2&gt;&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T1 _d1;<br>T2 _d2;<br>&#125;;<br><span class="hljs-comment">//全特化:</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Data</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;int,char&gt;&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _d1;<br><span class="hljs-type">char</span> _d2;<br>&#125;;<br><span class="hljs-comment">//偏特化1:部分特化</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&lt;<span class="hljs-type">int</span>, T1&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Data</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;int,T1&gt;&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> _d1;<br>T1 _d2;<br>&#125;;<br><br><span class="hljs-comment">//偏特化2:添加限制</span><br><span class="hljs-comment">//两个参数偏特化为指针类型</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &lt;T1*, T2*&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Data</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;T1*,T2*&gt;&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>T1 _d1;<br>T2 _d2;<br>&#125;;<br><br><span class="hljs-comment">//两个参数偏特化为引用类型</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&lt;T1&amp;, T2&amp;&gt; &#123;<br>T1&amp; _d1;<br>T2&amp; _d2;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Data</span>(T1&amp; a, T2&amp; b) :<br>_d1(a),<br>_d2(b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;T1&amp;,T2&amp;&gt;&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Data&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; d1;     <span class="hljs-comment">// Data&lt;T1,T2&gt;</span><br>Data&lt;string, string&gt; d2; <span class="hljs-comment">// Data&lt;T1,T2&gt;</span><br>Data&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; d3;     <span class="hljs-comment">// Data&lt;int,char&gt;,其实部分特化也满足,但优先进行全特化</span><br>Data&lt;<span class="hljs-type">int</span>, <span class="hljs-type">double</span>&gt; d4;    <span class="hljs-comment">// Data&lt;int,T1&gt;</span><br>Data&lt;<span class="hljs-type">int</span>*, <span class="hljs-type">double</span>*&gt; d5;  <span class="hljs-comment">// Data&lt;T1*,T2*&gt; </span><br><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span>&amp; pi = i;<br><span class="hljs-type">double</span> d = <span class="hljs-number">6.5</span>;<br><span class="hljs-type">double</span>&amp; pd = d;<br><span class="hljs-function">Data&lt;<span class="hljs-type">int</span>&amp;, <span class="hljs-type">double</span>&amp;&gt; <span class="hljs-title">d6</span><span class="hljs-params">(pi,pd)</span></span>; <span class="hljs-comment">//Data&lt;T1&amp;,T2&amp;&gt;</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——模版(二)</title>
    <link href="/xiaohei07.github.io/2023/04/14/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%A8%A1%E7%89%88(%E4%BA%8C)/"/>
    <url>/xiaohei07.github.io/2023/04/14/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%A8%A1%E7%89%88(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="一函数模版"><a href="#一函数模版" class="header-anchor">¶</a>（一）函数模版：</h3><p>重载函数通常基于不同的数据类型实现类似的操作，对不同数据类型有完全相同的操作，用函数模版实现更为简介方便。</p><h4 id="1-格式与定义"><a href="#1-格式与定义" class="header-anchor">¶</a>1. 格式与定义：</h4><p><em><strong>template &lt;类型形式参数表&gt;</strong></em>　<em><strong>返回类型 函数名(参数列表) { 函数体 }</strong></em></p><p>类型形式参数表= <em><strong>class T<sub>1</sub>, class T<sub>2</sub>, ... , class T<sub>n</sub></strong></em> or  <em><strong>typename T<sub>1</sub>, typename T<sub>2</sub>, ... , typename T<sub>n</sub></strong></em></p><p>函数模版定义由模版说明和函数定义构成。</p><p>模版说明的类属参数必须在函数定义中至少出现一次。</p><p>函数参数表中可以使用类属类型参数，也可以使用一般类型参数。</p><p>函数模板不允许自动类型转化。</p><p>其他要点前文已有讲述，此处不再重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; left, <span class="hljs-type">const</span> T&amp; right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> left == right;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual2</span><span class="hljs-params">(<span class="hljs-type">const</span> T1&amp; left, <span class="hljs-type">const</span> T2&amp; right)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> left == right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;           <span class="hljs-comment">// 隐式实例化</span><br><span class="hljs-comment">//cout&lt;&lt;IsEqual(1,1.2)&lt;&lt;endl;            // 模板参数不匹配,不知道是把int推断为double还是double推断为int</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; endl;    <span class="hljs-comment">// 显式实例化</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; endl; <span class="hljs-comment">// 显式实例化</span><br><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;          <span class="hljs-comment">//隐式实例化,表示IsEqual2&lt;int,int&gt;</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1.2</span>)&lt;&lt;endl;           <span class="hljs-comment">//隐式实例化,表示IsEqual2&lt;int,double&gt;</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual2</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; endl; <span class="hljs-comment">// 显式实例化</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual2</span>&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; endl; <span class="hljs-comment">// 显式实例化,注意此处1.2转为int后为1,返回true</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure><h4 id="2-重载函数模版"><a href="#2-重载函数模版" class="header-anchor">¶</a>2.  重载函数模版：</h4><p>当模版类型不能满足需要（不能提供类型的隐式转换）时，函数模版可以进行重载（效果和普通的函数重载一致），而且可以和普通重载函数并存。</p><p>此时如果均存在匹配，涉及到了匹配的优先级关系，为此，c++的函数模版有匹配约定：</p><ul class="lvl-0"><li class="lvl-2"><p>寻找和使用最符合函数名和函数类型的普通函数，若找到则调用它。</p></li><li class="lvl-2"><p>否则寻找一个函数模版，将其实例化产生一个匹配的函数参数，若找到则调用它。</p></li><li class="lvl-2"><p>否则，寻找可以通过类型转换进行参数匹配的重载函数，若找到则调用它。</p></li><li class="lvl-2"><p>如果前三次的寻找均为找到匹配函数，则调用错误；如果在三次的某次寻找中调用有多余一个的匹配选择，则调用匹配出现二义性。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; left,<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; right)</span><span class="hljs-comment">//普通函数重载</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;重载普通函数1&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> left == right;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; left, <span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; right)</span><span class="hljs-comment">//普通函数重载</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;重载普通函数2&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> left == right;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; left, <span class="hljs-type">const</span> T&amp; right)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;模版&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> left == right;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> T1&amp; left, <span class="hljs-type">const</span> T2&amp; right)</span><span class="hljs-comment">//重载,参数类型不同</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;重载模版1,参数类型不同&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> left == right;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEqual</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; right)</span> <span class="hljs-comment">//重载,参数个数不同</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;重载模版2，参数个数不同&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span> == right;<br>&#125;<br><br><span class="hljs-comment">//当同时使用下面两个函数模版时,如果传入(double,int)类型的参数,将会导致二义性错误。</span><br><span class="hljs-comment">//template &lt;typename T1&gt;</span><br><span class="hljs-comment">//bool IsEqual(const T1&amp; left, const int&amp; right)//重载,参数类型不同</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;重载模版3,参数类型不同&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//return left == right;</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//template &lt;typename T2&gt;</span><br><span class="hljs-comment">//bool IsEqual(const double&amp; left, const T2&amp; right)//重载,参数类型不同</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;重载模版3,参数类型不同&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//return left == right;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;<span class="hljs-comment">//因为有最佳匹配的普通函数1,调用该函数</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1.2</span>)&lt;&lt;endl; <span class="hljs-comment">//因为没有最佳匹配的普通函数,检查模版类,检查到有最佳的匹配重载模版1,调用该函数模版</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">1.2</span>) &lt;&lt; endl; <span class="hljs-comment">//因为有最佳匹配的普通函数2,调用该函数</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>(<span class="hljs-number">1.2</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;   <span class="hljs-comment">//因为没有最佳匹配的普通函数,检查模版类,检查到有最佳的匹配重载模版1,调用该函数模版</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>) &lt;&lt; endl; <span class="hljs-comment">//因为没有最佳匹配的普通函数,检查模版类,检查到有最佳的匹配重载模版,调用该函数模版</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">double</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &lt;&lt; endl;   <span class="hljs-comment">//显式说明调用的是函数模版,寻找到最佳匹配调用</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>&lt;<span class="hljs-type">double</span>,<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; endl; <span class="hljs-comment">//显式说明调用的是函数模版,寻找到最佳匹配调用</span><br>cout &lt;&lt; <span class="hljs-built_in">IsEqual</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">&#x27;1&#x27;</span>) &lt;&lt; endl;;         <span class="hljs-comment">//显式说明调用的是函数模版,寻找到最佳匹配调用</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//重载普通函数1</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//重载模版1, 参数类型不同</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//重载普通函数2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//重载模版1, 参数类型不同</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//模版</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//重载模版1, 参数类型不同</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//重载模版1, 参数类型不同</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//重载模版2，参数个数不同</span><br><span class="hljs-comment">//0</span><br></code></pre></td></tr></table></figure><h3 id="二类模版"><a href="#二类模版" class="header-anchor">¶</a>（二）类模版：</h3><p>类模版用于实现类所需数据的类型参数化。</p><p>类模版在表示如数组、表、图等数据结构上显得特别重要，这些数据结构的表示和算法不受所包含的元素类型的影响。</p><h4 id="1-格式"><a href="#1-格式" class="header-anchor">¶</a>1. 格式：</h4><p><em><strong>template&lt;类型形式参数表&gt;</strong></em><em><strong>class 类名{ ... };</strong></em></p><p>类属参数可以用于声明类中的成员变量和成员函数，在类中使用内置雷类型的地方也都可以用类属参数来声明。</p><p>另外，类模版中的成员函数放到类模版定义外面写时的语法有限制：</p><p><em><strong>template&lt;类型形式参数表&gt;</strong></em></p><p><em><strong>返回值类型 类模板名&lt;类型参数名列表&gt;::成员函数名(参数表) { 函数体 }</strong></em></p><p>创建对象的格式：</p><p><em><strong>类模板名&lt;真实类型参数表&gt; 对象名(构造函数实际参数表);</strong></em></p><p>如果有无参构造函数，可以是：</p><p><em><strong>类模板名&lt;真实类型参数表&gt; 对象名;</strong></em></p><p>注意：类模版形参不存在实参推演的问题，不能给真实类型参数表传递实参，只能传递类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span>:<br>T mAge;<br>T mID;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//类内定义类的成员函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&lt;T&gt;&amp; a) <br>&#123; <br><span class="hljs-keyword">this</span>-&gt;mAge = a.mAge;<br><span class="hljs-keyword">this</span>-&gt;mID = a.mID;<br>&#125;<br><span class="hljs-built_in">Person</span>() &#123;&#125;<br><span class="hljs-comment">//T在返回值中</span><br><span class="hljs-function">T <span class="hljs-title">getage</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> mAge;<br>&#125;<br><span class="hljs-function">T <span class="hljs-title">getmID</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> mID;<br>&#125;<br><span class="hljs-comment">//类外定义类的成员函数</span><br><span class="hljs-comment">//T在传入形参中</span><br><span class="hljs-built_in">Person</span>(T age, T id);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span>;<br><br>&#125;;<br><span class="hljs-comment">//外部实现成员函数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>Person&lt;T&gt;::<span class="hljs-built_in">Person</span>(T age, T id) &#123;<br><span class="hljs-keyword">this</span>-&gt;mID = id;<br><span class="hljs-keyword">this</span>-&gt;mAge = age;<br>&#125;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">void</span> Person&lt;T&gt;::<span class="hljs-built_in">Show</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Age:&quot;</span> &lt;&lt; mAge &lt;&lt; <span class="hljs-string">&quot; ID:&quot;</span> &lt;&lt; mID &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">20021111</span>)</span></span>; <span class="hljs-comment">//一般声明</span><br>Person&lt;string&gt;<span class="hljs-built_in">p2</span>(<span class="hljs-string">&quot;15&quot;</span>, <span class="hljs-string">&quot;20031111&quot;</span>);<br>Person&lt;string&gt;<span class="hljs-built_in">p3</span>(p2);<br>Person&lt;<span class="hljs-type">char</span>&gt; p4; <span class="hljs-comment">//无参构造的说明</span><br><span class="hljs-comment">//Person&lt;2&gt; p5;  //错误,没有实参类型推导,不能这样操作,必须是类型说明符</span><br>p<span class="hljs-number">1.</span><span class="hljs-built_in">Show</span>();<br>p<span class="hljs-number">2.</span><span class="hljs-built_in">Show</span>();<br>p<span class="hljs-number">3.</span><span class="hljs-built_in">Show</span>();<br>cout &lt;&lt; p<span class="hljs-number">1.</span><span class="hljs-built_in">getage</span>() &lt;&lt; endl;<br>cout &lt;&lt; p<span class="hljs-number">2.</span><span class="hljs-built_in">getmID</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//Age:10 ID : 20021111</span><br><span class="hljs-comment">//Age : 15 ID : 20031111</span><br><span class="hljs-comment">//Age : 15 ID : 20031111</span><br><span class="hljs-comment">//10</span><br><span class="hljs-comment">//20031111</span><br></code></pre></td></tr></table></figure><h4 id="2-类模版作为函数参数"><a href="#2-类模版作为函数参数" class="header-anchor">¶</a>2. 类模版作为函数参数：</h4><p>函数的形式参数类型可以是类模版或类模版的引用，对应的实际参数是该类模版实例化的模版类对象。</p><p>因此，只有函数模版能够拥有模版类参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;<br><span class="hljs-keyword">public</span>:<br>T n;<br>&#125;;<br><span class="hljs-comment">//声明函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">funtest</span><span class="hljs-params">(Array&lt;T&gt; a)</span> </span>&#123; cout &lt;&lt; a.n &lt;&lt; endl; <span class="hljs-keyword">return</span> a.n; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>Array&lt;<span class="hljs-type">int</span>&gt; a;<br>a.n = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//函数模板调用类模板的实例化对象</span><br>cout &lt;&lt; <span class="hljs-built_in">funtest</span>(a) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-模板类和类模板"><a href="#3-模板类和类模板" class="header-anchor">¶</a>3. 模板类和类模板：</h4><p>类模板是模板的一种，可以在使用确定类属参数。</p><p>类模板不是一个类，不会生成对象，也不会占据空间。</p><p>模板类是类模板的一个实例，是确定了类属参数的具体类，可以直接生成对象。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">//模板类:<br><span class="hljs-regexp">//</span>template&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class">//<span class="hljs-title">class</span> <span class="hljs-title">Array</span> </span>&#123;&#125;;<br><span class="hljs-regexp">//</span>类模板:<br>Array&lt;double&gt; array;<br></code></pre></td></tr></table></figure><h4 id="4-函数模板作为类模版成员"><a href="#4-函数模板作为类模版成员" class="header-anchor">¶</a>4. 函数模板作为类模版成员：</h4><p>类模板中的成员函数还可以是一个函数模板成员，函数模板只有在被调用时才会被实例化。</p><p>无论是原则还是声明，模板语法的优先级是最高的，不同模板的优先级先根据其声明顺序来判断，其次是函数修饰，然后是返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(T2 t)</span> </span>&#123; cout &lt;&lt; t &lt;&lt; endl; <span class="hljs-keyword">return</span>; &#125;  <span class="hljs-comment">//成员函数模板</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span>&gt;<br><span class="hljs-function">A&lt;T&gt; <span class="hljs-title">Func2</span><span class="hljs-params">(T3 t)</span></span>; <span class="hljs-comment">//类外定义：</span><br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span>&gt; <span class="hljs-comment">//最外层类模板对应的类属参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;  <span class="hljs-comment">//内层函数模板对应的类属参数</span><br>A&lt;T3&gt;              <span class="hljs-comment">//返回值</span><br>A&lt;T3&gt;::<span class="hljs-built_in">Func2</span>(T t)  <span class="hljs-comment">//函数名和形参表 </span><br>&#123; <br>cout &lt;&lt; t &lt;&lt; endl; <span class="hljs-comment">//函数体</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A&lt;<span class="hljs-type">int</span>&gt; a;<br>a.<span class="hljs-built_in">Func</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-string">&#x27;K&#x27;</span>);  <span class="hljs-comment">//成员函数模板Func被实例化</span><br>a.<span class="hljs-built_in">Func</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>a.<span class="hljs-built_in">Func2</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//75</span><br><span class="hljs-comment">//hello</span><br><span class="hljs-comment">//world</span><br></code></pre></td></tr></table></figure><h4 id="5-类层次中的类模版"><a href="#5-类层次中的类模版" class="header-anchor">¶</a>5. 类层次中的类模版：</h4><p>在类层次中，类模板可以是基类，也可以是派生类。</p><p>类模板可以从类模板或普通类派生：</p><ul class="lvl-0"><li class="lvl-2"><p>当一个类模板从普通类派生时，意味着派生类增加了类属参数。</p></li><li class="lvl-2"><p>当一个类模板从类模板派生时，可以添加新的类属参数，也可以保持，同时其他性质和一般的类之间的派生性质相同。</p></li></ul><p>普通类可以从模板类或普通类派生：</p><ul class="lvl-0"><li class="lvl-2"><p>当一个普通类从类模板派生时，意味着派生类继承基类时，需要提供实例化的类型参数使派生的普通类内没有类属参数，同时需要编译分配内存。</p></li><li class="lvl-2"><p>普通类之间的派生不涉及模板。</p></li></ul><p>类模板之间允许有多继承关系（性质简单，此略）。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//类模板派生普通类</span><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>T age;<br>Person() :age(<span class="hljs-number">5</span>) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//由类模板派生普通类时,提供实例化的类型参数,编译分配内容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubPerson</span> : <span class="hljs-keyword">public</span> Person&lt;<span class="hljs-built_in">int</span>&gt; <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">double</span> age;<br><span class="hljs-comment">//构造函数调用不需要指定Person后面的类型</span><br>SubPerson() :age(<span class="hljs-number">10</span>), Person() &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age:&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">//类模板派生类模板</span><br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>T age;<br>Animal() :age(<span class="hljs-number">5</span>) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>&#125;;<br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>&gt;   <span class="hljs-comment">//增加新的类属参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal&lt;T&gt; <br>&#123;<br><span class="hljs-keyword">public</span>:<br>T1 age;<br><span class="hljs-comment">//构造函数调用需要指定Animal后面的类型</span><br>Cat() :Animal&lt;T&gt;(), age(<span class="hljs-number">10</span>) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-comment">//普通类派生类模板,需要增加类属参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">int</span> age;<br>Student() :age(<span class="hljs-number">5</span>) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>&#125;;<br>template&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodStudent</span>:<span class="hljs-keyword">public</span> Student<br>&#123;<br><span class="hljs-keyword">public</span>:<br>T age;<br>GoodStudent() :Student(), age(<span class="hljs-number">10</span>) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-keyword">print</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;age&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-built_in">int</span> main(<span class="hljs-keyword">void</span>)<br>&#123;<br>Person&lt;<span class="hljs-built_in">double</span>&gt; p;<br>SubPerson pa;<br>Animal&lt;<span class="hljs-built_in">double</span>&gt; a;<br>Cat&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">double</span>&gt; cat;<br>Student s;<br>GoodStudent&lt;<span class="hljs-built_in">double</span>&gt; gs;<br>p.<span class="hljs-keyword">print</span>();<br>pa.<span class="hljs-keyword">print</span>();<br>a.<span class="hljs-keyword">print</span>();<br>cat.<span class="hljs-keyword">print</span>();<br>s.<span class="hljs-keyword">print</span>();<br>gs.<span class="hljs-keyword">print</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//age:5</span><br><span class="hljs-comment">//age:10</span><br><span class="hljs-comment">//age5</span><br><span class="hljs-comment">//age10</span><br><span class="hljs-comment">//age5</span><br><span class="hljs-comment">//age10</span><br></code></pre></td></tr></table></figure><h4 id="6-类模版和友元"><a href="#6-类模版和友元" class="header-anchor">¶</a>6. 类模版和友元：</h4><p>模板类的友元分三类：</p><p>1，非模板友元。</p><p>2，约束模板友元，即友元的类型取决于类被实例化时的类型。</p><p>3，非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元。</p><ul class="lvl-0"><li class="lvl-2"><p>一个函数或函数模板或函数模板的实例化（这个函数可以是某个类的成员函数）可以是类或类模板的友元——这会使其成为由该类模板实例化的每个类模板的友元函数。</p></li><li class="lvl-2"><p>一个类或类模板或者一个类模板的实例化可以是类或类模板的友元类——逻辑同上。</p></li></ul><p>所有友元中的函数的参数或者返回值可以是该模板类的类属参数。</p><p>友元的内容十分复杂，具体内容详见代码的讲解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//前置声明</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span>;<br><br><span class="hljs-comment">//类/类模板作友元均需要提前声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA3</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A3</span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA4</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A4</span>;<br><br><span class="hljs-comment">//函数模板作友元需要提前声明;</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">externprint2</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">getvalue2</span><span class="hljs-params">(<span class="hljs-type">const</span> base&lt;T&gt;&amp; b)</span></span>;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;             <br><span class="hljs-keyword">private</span>:<br>T val;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">base</span>(T value) :<span class="hljs-built_in">val</span>(value) &#123;&#125;<br><span class="hljs-comment">//非模板友元：</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">externprint</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">//普通函数友元,函数没有参数,只能对全局类变量操作</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> T <span class="hljs-title">getvalue</span><span class="hljs-params">(<span class="hljs-type">const</span> base&lt;T&gt;&amp; b)</span></span>;    <span class="hljs-comment">//普通函数友元(不是函数模板),函数有参数,可以操作对应类型</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span>;                        <span class="hljs-comment">//类友元</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span>&lt;<span class="hljs-type">int</span>&gt;;                   <span class="hljs-comment">//类模板实例化的友元,只有此一种是其所有实例化的友元</span><br><span class="hljs-comment">//约束模板友元</span><br><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-built_in">externprint2</span>&lt;T&gt;();          <span class="hljs-comment">//函数模板友元,且两者的实例化友元一一对相应</span><br><span class="hljs-keyword">friend</span> T getvalue2&lt;&gt;(<span class="hljs-type">const</span> base&lt;T&gt;&amp; b); <span class="hljs-comment">//函数模板友元,且两者的实例化友元一一对相应</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A3</span>&lt;T&gt;;                     <span class="hljs-comment">//类模板友元，且两者的实例化友元一一对应</span><br><br><span class="hljs-comment">//非约束模板友元</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-title">externprint3</span><span class="hljs-params">(T1 t)</span></span>;         <span class="hljs-comment">//函数模板友元,两者的对应关系是自由的</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA2</span>&gt;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A4</span>;                        <span class="hljs-comment">//类模板友元,两者的对应关系是自由的</span><br>&#125;;<br><span class="hljs-function">base&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">bd</span><span class="hljs-params">(<span class="hljs-number">3.14</span>)</span></span>;<br><span class="hljs-function">base&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">bi</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">externprint</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(bi.val) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>;<br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(bd.val) &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//可以重载多个类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getvalue</span><span class="hljs-params">(<span class="hljs-type">const</span> base&lt;<span class="hljs-type">int</span>&gt;&amp; b)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;int base:&quot;</span> &lt;&lt; b.val &lt;&lt; endl;<br><span class="hljs-keyword">return</span> b.val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getvalue</span><span class="hljs-params">(<span class="hljs-type">const</span> base&lt;<span class="hljs-type">double</span>&gt;&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;double base:&quot;</span> &lt;&lt; b.val &lt;&lt; endl;<br><span class="hljs-keyword">return</span> b.val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">externprint2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(bd.val)<span class="hljs-comment">//证明是友元函数</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(base&lt;T&gt;) &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">getvalue2</span><span class="hljs-params">(<span class="hljs-type">const</span> base&lt;T&gt;&amp; b)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(base&lt;T&gt;).<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; base:&quot;</span> &lt;&lt; b.val &lt;&lt; endl;<br><span class="hljs-keyword">return</span> b.val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">externprint3</span><span class="hljs-params">(T1 t)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (t == bd.val)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A1</span><br>&#123;<br>base&lt;<span class="hljs-type">int</span>&gt; b1;<br>base&lt;<span class="hljs-type">double</span>&gt; b2;<br>base&lt;<span class="hljs-type">char</span>&gt; b3;<br>base&lt;string&gt; b4;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A1</span>() :<span class="hljs-built_in">b1</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">b2</span>(<span class="hljs-number">3.14</span>), <span class="hljs-built_in">b3</span>(<span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">b4</span>(<span class="hljs-string">&quot;bbb&quot;</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>cout &lt;&lt; b<span class="hljs-number">1.</span>val &lt;&lt; endl; <br>cout &lt;&lt; b<span class="hljs-number">2.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">3.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">4.</span>val &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A2</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>base&lt;<span class="hljs-type">int</span>&gt; b1;<br>base&lt;<span class="hljs-type">double</span>&gt; b2;<br>base&lt;<span class="hljs-type">char</span>&gt; b3;<br>base&lt;string&gt; b4;<br><span class="hljs-keyword">public</span>:<br>TA2 bb;<br><span class="hljs-built_in">A2</span>() :<span class="hljs-built_in">b1</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">b2</span>(<span class="hljs-number">3.14</span>), <span class="hljs-built_in">b3</span>(<span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">b4</span>(<span class="hljs-string">&quot;bbb&quot;</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; b<span class="hljs-number">1.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">2.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">3.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">4.</span>val &lt;&lt; endl;<br>bb = b<span class="hljs-number">1.</span>val;<br>cout &lt;&lt; bb &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA3</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A3</span> <br>&#123;<br>base&lt;<span class="hljs-type">int</span>&gt; b1;<br>base&lt;<span class="hljs-type">double</span>&gt; b2;<br>base&lt;<span class="hljs-type">char</span>&gt; b3;<br>base&lt;string&gt; b4;<br><span class="hljs-keyword">public</span>:<br>TA3 bb;<br><span class="hljs-built_in">A3</span>() :<span class="hljs-built_in">b1</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">b2</span>(<span class="hljs-number">3.14</span>), <span class="hljs-built_in">b3</span>(<span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">b4</span>(<span class="hljs-string">&quot;bbb&quot;</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>cout &lt;&lt; b<span class="hljs-number">1.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">2.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">3.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">4.</span>val &lt;&lt; endl;<br>bb = b<span class="hljs-number">3.</span>val;<br>cout &lt;&lt; bb &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; b<span class="hljs-number">1.</span>val &lt;&lt; endl;<br>bb = b<span class="hljs-number">1.</span>val;<br>cout &lt;&lt; bb &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; b<span class="hljs-number">3.</span>val &lt;&lt; endl;<br>bb = b<span class="hljs-number">3.</span>val;<br>cout &lt;&lt; bb &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">TA4</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A4</span> <br>&#123;<br>base&lt;<span class="hljs-type">int</span>&gt; b1;<br>base&lt;<span class="hljs-type">double</span>&gt; b2;<br>base&lt;<span class="hljs-type">char</span>&gt; b3;<br>base&lt;string&gt; b4;<br><span class="hljs-keyword">public</span>:<br>TA4 bb;<br><span class="hljs-built_in">A4</span>() :<span class="hljs-built_in">b1</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">b2</span>(<span class="hljs-number">3.14</span>), <span class="hljs-built_in">b3</span>(<span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-built_in">b4</span>(<span class="hljs-string">&quot;bbb&quot;</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; b<span class="hljs-number">1.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">2.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">3.</span>val &lt;&lt; endl;<br>cout &lt;&lt; b<span class="hljs-number">4.</span>val &lt;&lt; endl;<br>bb = b<span class="hljs-number">4.</span>val;<br>cout &lt;&lt; bb &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><br>A1 a1;<br>A2&lt;<span class="hljs-type">int</span>&gt; a21;<br>A2&lt;<span class="hljs-type">double</span>&gt; a22;<br>A3&lt;<span class="hljs-type">int</span>&gt; a31;<br>A3&lt;<span class="hljs-type">char</span>&gt; a32;<br>A4&lt;string&gt; a41;<br>A4&lt;<span class="hljs-type">char</span>&gt; a42;<br><span class="hljs-built_in">externprint</span>();              <span class="hljs-comment">//访问全局base对象的数据成员</span><br><span class="hljs-comment">//externprint2&lt;int&gt;();      //访问bd是base&lt;double&gt;,由一一对应关系,此处无法访问bd.val</span><br><span class="hljs-built_in">externprint2</span>&lt;<span class="hljs-type">double</span>&gt;();     <span class="hljs-comment">//bd与double均为T,是一一对应关系,可以访问</span><br> cout &lt;&lt; <span class="hljs-built_in">externprint3</span>(<span class="hljs-number">3</span>) &lt;&lt; endl;     <span class="hljs-comment">//由于是自由对应关系,两个externprint3均可访问b.d</span><br>cout &lt;&lt; <span class="hljs-built_in">externprint3</span>(<span class="hljs-number">3.14</span>) &lt;&lt; endl; <br>cout &lt;&lt; endl;<br>a<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>a<span class="hljs-number">21.</span><span class="hljs-built_in">print</span>();<br><span class="hljs-comment">//a22.print();              //只有A2&lt;int&gt;这个实例化是友元类,A2&lt;double&gt;因此没有访问base私有数据的权限</span><br><span class="hljs-comment">//a31.print();              //print访问多种类型,由于A3和base是模板类型的一一对应关系,此处只能访问int</span><br>a<span class="hljs-number">31.</span><span class="hljs-built_in">print2</span>();<span class="hljs-comment">//A3&lt;int&gt;只能对base&lt;int&gt;访问</span><br>a<span class="hljs-number">32.</span><span class="hljs-built_in">print3</span>();               <span class="hljs-comment">//A3&lt;char&gt;只能对base&lt;char&gt;访问</span><br>a<span class="hljs-number">41.</span><span class="hljs-built_in">print</span>();                <span class="hljs-comment">//由自由对应关系,可以访问任意base实例化的val</span><br><span class="hljs-comment">//a42.print();              //无法转换string为char</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//4, 8</span><br><span class="hljs-comment">//8</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//3.14</span><br><span class="hljs-comment">//a</span><br><span class="hljs-comment">//bbb</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//3.14</span><br><span class="hljs-comment">//a</span><br><span class="hljs-comment">//bbb</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//a</span><br><span class="hljs-comment">//a</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//3.14</span><br><span class="hljs-comment">//a</span><br><span class="hljs-comment">//bbb</span><br><span class="hljs-comment">//bbb</span><br></code></pre></td></tr></table></figure><h4 id="7-类模版和static成员"><a href="#7-类模版和static成员" class="header-anchor">¶</a>7. 类模版和static成员：</h4><p>从类模版实例化的每个模版类有自己的类模版数据成员，该模版类的所有对象共享一个static数据成员。</p><p>每个模版类有自己的类模板的static数据成员副本，这之间不是直接共享的。</p><p>和非模版类的static数据成员一样，模版类的static数据成员也应该在文件范围定义和初始化。</p><p>static数据成员可以用类属参数对应的类型声明，在外部定义时无需赋值，但是需要在前面说明template和类属参数表，以对类模版的相关模版类进行定义，这些static成员在创建模版类时自动默认初始化（如int则初始化为0，等等）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>T val;<br><span class="hljs-comment">//int类型:</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> totalcount;<br><span class="hljs-comment">//抽象类型</span><br><span class="hljs-type">static</span> T totalval;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">A</span>(T v) :<span class="hljs-built_in">val</span>(v) &#123; totalcount += <span class="hljs-number">1</span>; totalval += val; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> T <span class="hljs-title">gettotalval</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> totalval; &#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gettotalcount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> totalcount; &#125;<br><span class="hljs-function">T <span class="hljs-title">getval</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> val; &#125;<br>~<span class="hljs-built_in">A</span>() &#123; totalcount -= <span class="hljs-number">1</span>; totalval -= val; &#125;<br>&#125;;<br><span class="hljs-comment">//定义确定类型静态数据成员</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>T A&lt;T&gt;::totalval;<br><span class="hljs-comment">//定义抽象类型静态数据成员</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-type">int</span> A&lt;T&gt;::totalcount=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">a1</span><span class="hljs-params">(<span class="hljs-number">5.5</span>)</span>, <span class="hljs-title">a2</span><span class="hljs-params">(<span class="hljs-number">4.5</span>)</span>, <span class="hljs-title">a3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-function">A&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a4</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">a5</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-comment">//两个模版类的静态数据成员在模版类内共享,但互相间独立。</span><br>cout &lt;&lt; A&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">gettotalcount</span>() &lt;&lt; endl;<br>cout &lt;&lt; A&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">gettotalval</span>() &lt;&lt; endl;<br>cout &lt;&lt; A&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">gettotalcount</span>() &lt;&lt; endl;<br>cout &lt;&lt; A&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">gettotalval</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//3</span><br><span class="hljs-comment">//13</span><br><span class="hljs-comment">//2</span><br><span class="hljs-comment">//9</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++基础——强制类型转换符</title>
    <link href="/xiaohei07.github.io/2023/04/14/c++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%A6/"/>
    <url>/xiaohei07.github.io/2023/04/14/c++%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念：</h3><p>隐式类型转换是编译器自动隐式进行的，需要在代码中体现，而显式类型转换由程序员明确指定。</p><p>C++支持C风格的强制转换（将类型名作为强制类型转换运算符的做法是C语言的老式做法），但是C风格的强制转换可能带来一些隐患，让一些问题难以发现。</p><p>所以C++ 引入了四种功能不同的强制类型转换运算符以进行强制类型转换。</p><p>强制转换运算符是一种特殊的运算符，它把一种数据类型转换为另一种数据类型。强制转换运算符是一元运算符，它的优先级与其他一元运算符相同。</p><p>大多数的 C++ 编译器都支持大部分通用的强制转换运算符。</p><p>形式为：**<em>强制类型转换运算符&lt;type&gt; (expression)</em> **</p><p>type为转换后的数据类型，expression为待转换的表达式</p><p>c++的四种强制类型转换运算符分别为：static_cast、reinterpret_cast、const_cast和dynamic_cast。</p><h3 id="二风险"><a href="#二风险" class="header-anchor">¶</a>（二）风险：</h3><p>强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成指针，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。</p><p>C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p><ul class="lvl-0"><li class="lvl-3"><p>没有从形式上体现转换功能和风险的不同。</p></li></ul><p>例如，将int强制转换成double是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。</p><ul class="lvl-0"><li class="lvl-2"><p>将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</p></li><li class="lvl-2"><p>难以在程序中寻找到底什么地方进行了强制类型转换。</p><p>强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。</p></li></ul><p>如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。</p><p>而用 C++ 的方式，则只需要查找_cast字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了reinterpret_cast导致的，就可以只查找reinterpret_cast字符串。</p><h3 id="三四种转换操作"><a href="#三四种转换操作" class="header-anchor">¶</a>（三）四种转换操作：</h3><h4 id="1-const_cast"><a href="#1-const_cast" class="header-anchor">¶</a>1. const_cast：</h4><p>const_cast 运算符用于修改类型的const /volatile属性。除了const或volatile属性之外，目标类型必须与源类型相同（即type和expression结果类型相同）。这种类型的转换主要是用来操作所传对象的const属性，可以加上const属性，也可以去掉const属性（常用）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">const</span> string s = <span class="hljs-string">&quot;Inception&quot;</span>;<br>string&amp; p = <span class="hljs-keyword">const_cast</span> &lt;string&amp;&gt; (s);<br>string* ps = <span class="hljs-keyword">const_cast</span> &lt;string*&gt; (&amp;s);<br>p += <span class="hljs-string">&quot;1&quot;</span>;<br>*ps += <span class="hljs-string">&quot;2&quot;</span>;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(p).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">typeid</span>(ps).<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; p &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//class std::basic_string&lt;char, struct std::char_traits&lt;char&gt;, class std::allocator&lt;char&gt; &gt;</span><br><span class="hljs-comment">//class std::basic_string&lt;char, struct std::char_traits&lt;char&gt;, class std::allocator&lt;char&gt; &gt;* __ptr64</span><br><span class="hljs-comment">//Inception12</span><br></code></pre></td></tr></table></figure><h4 id="2-reinterpret_cast"><a href="#2-reinterpret_cast" class="header-anchor">¶</a>2. reinterpret_cast：</h4><p>reinterpret_cast 运算符用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</p><p>reinterpret_cast 功能十分强大，可以实现任意类型之间的转换。</p><p>这个转换是“最不安全”的。不推荐使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> j;<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> n1,<span class="hljs-type">int</span> n2) :<span class="hljs-built_in">i</span>(n1), <span class="hljs-built_in">j</span>(n2) &#123; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;show1&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">return</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">show2</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>*)</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;show2&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>)</span></span>;<br><br><span class="hljs-comment">//强行让r引用a</span><br><span class="hljs-type">int</span>&amp; r = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">int</span>&amp;&gt;(a); <br>r = <span class="hljs-number">300</span>;  <span class="hljs-comment">//把a.i变成了300</span><br>std::cout &lt;&lt; a.i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 300,200</span><br><br><span class="hljs-comment">//强行让pa指向n</span><br><span class="hljs-type">int</span> n = <span class="hljs-number">400</span>;<br>A* pa = <span class="hljs-built_in">reinterpret_cast</span>&lt;A*&gt; (&amp;n); <br>pa-&gt;i = <span class="hljs-number">500</span>;  <span class="hljs-comment">// n变成400</span><br><span class="hljs-comment">//pa-&gt;j = 600;  //此条语句越界操作内存,不安全,会导致程序崩溃</span><br>cout &lt;&lt; n &lt;&lt; endl;  <span class="hljs-comment">// 输出 500</span><br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> la = <span class="hljs-number">0x12345678abcdLL</span>;<br>pa = <span class="hljs-built_in">reinterpret_cast</span>&lt;A*&gt;(la); <span class="hljs-comment">//la太长，只取低32位0x5678abcd拷贝给pa</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> u = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(pa);<span class="hljs-comment">//pa逐个比特拷贝到u</span><br>cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  <span class="hljs-comment">//输出 5678abcd</span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*PF1)</span> <span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*PF2)</span> <span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>*)</span></span>;<br><span class="hljs-comment">//两个不同类型的函数指针之间可以互相转换,但是pf1和pf2必须初始化</span><br>PF1 pf1=show1;  PF2 pf2=show2;<br><span class="hljs-built_in">pf1</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//show1</span><br>cout &lt;&lt; <span class="hljs-built_in">pf2</span>(<span class="hljs-number">1</span>, (<span class="hljs-type">char</span>*)(<span class="hljs-string">&quot;1&quot;</span>)) &lt;&lt; endl; <span class="hljs-comment">//show2,返回1</span><br>pf2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;PF2&gt;(pf1);<br><span class="hljs-built_in">pf1</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//show1</span><br>cout &lt;&lt; <span class="hljs-built_in">pf2</span>(<span class="hljs-number">1</span>, (<span class="hljs-type">char</span>*)(<span class="hljs-string">&quot;1&quot;</span>)) &lt;&lt; endl; <span class="hljs-comment">//show1，返回1，(表现非常奇怪，不安全)</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//300, 200</span><br><span class="hljs-comment">//500</span><br><span class="hljs-comment">//5678abcd</span><br><span class="hljs-comment">//show1</span><br><span class="hljs-comment">//show2</span><br><span class="hljs-comment">//1</span><br><span class="hljs-comment">//show1</span><br><span class="hljs-comment">//show1</span><br><span class="hljs-comment">//b0e74080</span><br></code></pre></td></tr></table></figure><h4 id="3-static_cast"><a href="#3-static_cast" class="header-anchor">¶</a>3. static_cast:</h4><p>编译器隐式执行的任何类型转换都可以由static_cast显式完成。</p><p>static_cast主要用于基本数据类型之间的转换，如把char转换为 int，把int转换为double等。</p><p>使用static_cast可以明确告诉编译器，损失精度的转换是在知情的情况下进行的，也可以让阅读程序的其他程序员明确转换的目的而不是由于疏忽。</p><p>把精度大的类型转换为精度小的类型，static_cast使用位截断进行处理。</p><p>static_cast执行的是非动态转换，没有运行时的类型检查来保证转换的安全性。</p><p>例如，对于类层次的转换：</p><ul class="lvl-0"><li class="lvl-2"><p>static_cast 进行上行转换是安全的，即把派生类的指针转换为基类的；</p></li><li class="lvl-2"><p>static_cast 进行下行转换是不安全的，即把基类的指针转换为派生类的。</p></li></ul><p>使用static_cast可以找回存放在void*指针中的值。</p><p>static_cast可以把任何类型的表达式转换成void*类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-type">int</span> j;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br><span class="hljs-keyword">operator</span> <span class="hljs-type">char</span>* () &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> :<span class="hljs-keyword">public</span> A <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> z;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)<span class="hljs-string">&quot;New Dragon Inn&quot;</span>;<br>n = <span class="hljs-keyword">static_cast</span> &lt;<span class="hljs-type">int</span>&gt; (a);     <span class="hljs-comment">//调用 a.operator int,n的值变为1</span><br>cout &lt;&lt; n &lt;&lt; endl;<br>p = <span class="hljs-keyword">static_cast</span> &lt;<span class="hljs-type">char</span>*&gt; (a);   <span class="hljs-comment">//调用 a.operator char*,p的值变为NULL</span><br>cout &lt;&lt; &amp;p &lt;&lt; endl;<br>n = <span class="hljs-keyword">static_cast</span> &lt;<span class="hljs-type">int</span>&gt; (<span class="hljs-number">3.14</span>);  <span class="hljs-comment">//转换丢失精度,n的值变为3</span><br>cout &lt;&lt; n &lt;&lt; endl;<br><span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> y = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(x); <span class="hljs-comment">// 转换为无符号整数最大值,此处为4294967295</span><br>cout &lt;&lt; y &lt;&lt; endl;<br><span class="hljs-comment">//n = static_cast &lt;int&gt; (p);  //编译错误，static_cast不能将指针转换成整型</span><br><span class="hljs-comment">//p = static_cast &lt;char*&gt; (n);  //编译错误，static_cast 不能将整型转换成指针</span><br><br><span class="hljs-type">double</span> da = <span class="hljs-number">2.991</span>;<br><span class="hljs-type">void</span>* vp = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(&amp;da);    <span class="hljs-comment">//double转void*类型,void*指向double类型值</span><br><span class="hljs-type">double</span>* dp = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>*&gt;(vp); <span class="hljs-comment">//将void*类型的double值找回来</span><br>cout &lt;&lt; *dp &lt;&lt; endl;   <span class="hljs-comment">//输出2.991</span><br>A* pa = <span class="hljs-keyword">new</span> A;<br>B* pb = <span class="hljs-keyword">new</span> B;<br>pa-&gt;i = <span class="hljs-number">1</span>;<br>pa-&gt;j = <span class="hljs-number">2</span>;<br>pb-&gt;i = <span class="hljs-number">10</span>;<br>pb-&gt;j = <span class="hljs-number">20</span>;<br>pb-&gt;z = <span class="hljs-number">30</span>;<br>A* pab = <span class="hljs-built_in">static_cast</span>&lt;B*&gt;(pb); <span class="hljs-comment">//上行转换,派生类指针-&gt;基类指针,pab的i和j的值与pb的相同,z的值丢弃</span><br>cout &lt;&lt; pab-&gt;i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; pab-&gt;j &lt;&lt; endl;<br>B* pba = <span class="hljs-built_in">static_cast</span>&lt;B*&gt;(pa); <span class="hljs-comment">//下行转换,基类指针-&gt;派生类指针,不进行类型检查,不安全,i和j的值与pa的相同,但是z的值相当于未初始化</span><br>cout &lt;&lt; pba-&gt;z &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; pba-&gt;i &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; pba-&gt;j &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-dynamic_cast"><a href="#4-dynamic_cast" class="header-anchor">¶</a>4. dynamic_cast:</h4><p>dynamic_cast 主要用于类层次间的上行转换或安全的下行转换（实际就是专门用于将多态基类指针或引用转换为派生类指针或引用）。在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。</p><p>对于“向下转型”有两种情况：</p><ul class="lvl-0"><li class="lvl-2"><p>基类指针所指对象是派生类类型的，这种情况下将其转换为派生类指针转换是安全的；</p></li><li class="lvl-2"><p>基类指针所指对象为基类类型，在这种情况下dynamic_cast在运行时做检查，转换失败，返回结果为NULL指针；</p></li></ul><p>dynamic_cast最特殊的地方在于它支持运行时识别指针或引用。</p><p>dynamic_cast 是在运行时执行转换，进行类型检查的。如果转换未执行，则转换失败，表达式 expr 被判定为 null。dynamic_cast 执行动态转换时，type 必须是类的指针、类的引用或者 void*，如果 type 是类指针类型，那么 expr 也必须是一个指针，如果 type 是一个引用，那么 expr 也必须是一个引用。</p><p>dynamic_cast检查的来源是虚函数表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> i;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am Base.&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> j;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;I am Derive.&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 上行转换</span><br>Derive* d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derive</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;d1: &quot;</span> &lt;&lt; d1 &lt;&lt; endl;<br>Base* b1 = <span class="hljs-built_in">dynamic_cast</span>&lt;Base*&gt;(d1); <span class="hljs-comment">//转换安全,且无影响。</span><br>cout &lt;&lt; <span class="hljs-string">&quot;b1: &quot;</span> &lt;&lt; b1 &lt;&lt; endl;<br><br><span class="hljs-comment">// 下行转换</span><br><span class="hljs-comment">//基类指针指向派生类类型进行转换</span><br>Base* b2 = <span class="hljs-keyword">new</span> Derive;<br>cout &lt;&lt; <span class="hljs-string">&quot;b2: &quot;</span> &lt;&lt; b2 &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (Derive* d2 = <span class="hljs-built_in">dynamic_cast</span>&lt;Derive*&gt;(b2))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第一种情况转换成功&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;d2: &quot;</span> &lt;&lt; d2 &lt;&lt; endl;<br>d2-&gt;<span class="hljs-built_in">Show</span>();<br>&#125;<br><span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;第一种情况转换失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//基类指针指向基类类型进行转换</span><br>Base* b3 = <span class="hljs-keyword">new</span> Base;<br>cout &lt;&lt; <span class="hljs-string">&quot;b3: &quot;</span> &lt;&lt; b3 &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (Derive* d3 = <span class="hljs-built_in">dynamic_cast</span>&lt;Derive*&gt;(b3))<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二种情况转换成功&quot;</span> &lt;&lt; endl;<br>d3-&gt;<span class="hljs-built_in">Show</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二种情况转换失败&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;d3: &quot;</span> &lt;&lt; d3 &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">delete</span> b1;<br><span class="hljs-keyword">delete</span> b2;<br><span class="hljs-keyword">delete</span> b3;<br><br><span class="hljs-comment">//引用在其他方面表现和指针一样,但因为没有NULL类型,不能用dynamic_cast强制转换时抛出错误。</span><br>Base bbb;<br>Base&amp; bbbb = bbb;<br><span class="hljs-comment">//Derive&amp; dddd = dynamic_cast&lt;Derive&amp;&gt;(bbbb); </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//d1 : 000002531E58F8C0</span><br><span class="hljs-comment">//b1 : 000002531E58F8C0</span><br><span class="hljs-comment">//b2 : 000002531E58F740</span><br><span class="hljs-comment">//第一种情况转换成功</span><br><span class="hljs-comment">//d2 : 000002531E58F740</span><br><span class="hljs-comment">//I am Derive.</span><br><span class="hljs-comment">//b3 : 000002531E592440</span><br><span class="hljs-comment">//第二种情况转换失败</span><br><span class="hljs-comment">//d3 : 0000000000000000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——多态(三)</title>
    <link href="/xiaohei07.github.io/2023/04/08/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81(%E4%B8%89)/"/>
    <url>/xiaohei07.github.io/2023/04/08/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="header-anchor">¶</a>纯虚函数和抽象类：</h3><h4 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念：</h4><ul class="lvl-0"><li class="lvl-2"><p>纯虚函数：</p><p>纯虚函数是指在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后面加=0。</p><p>纯虚函数是一定要被继承的，它为各派生类提供了一个公共界面，方便了多态的使用，而且无需在基类中实现函数（有时这样的操作是不合理的）。</p><p>纯虚函数可以写实现，但不建议写。</p><p><em>纯虚函数格式：<strong>virtual 类型 函数名(参数表 )=0</strong></em></p></li><li class="lvl-2"><p>抽象类：</p><p>一个具有纯虚函数的类被称为抽象类，也被称为接口类。</p><p>抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。</p><p>所以，派生类实际上刻画了一组派生类的操作接口的通用语义，这些语义能够传给派生类，派生类可以具体实现这些语义，也可以再将这些语义传给自己的派生类。</p></li></ul><h4 id="二抽象类的限制"><a href="#二抽象类的限制" class="header-anchor">¶</a>（二）抽象类的限制：</h4><ul class="lvl-0"><li class="lvl-2"><p>抽象类最重要的一点是无法实例化出对象。</p></li><li class="lvl-2"><p>抽象类的派生类也无法实例化出对象，除非其重写了基类的纯虚函数——不重写，该派生类仍为抽象类，重写后成为可以建立具体的对象的类。</p></li><li class="lvl-2"><p>抽象类创建抽象类的指针和引用，但其只能用来指向派生类的对象。</p></li><li class="lvl-2"><p>抽象类不能作为函数的返回类型。</p></li><li class="lvl-2"><p>抽象类不能作为传值参数类型。</p></li><li class="lvl-2"><p>不能建立抽象类型存储空间。</p></li></ul><h4 id="三接口继承和实现继承"><a href="#三接口继承和实现继承" class="header-anchor">¶</a>（三）接口继承和实现继承：</h4><p>普通成员函数的继承就是实现继承，虚函数的继承就是接口继承。</p><p>派生类的成员函数通过实现继承来继承，可以直接使用；而虚函数通过接口继承只会继承接口，需要重写实现。</p><p>所以，如果不用多态，不要把函数写成虚函数。</p><h4 id="四代码"><a href="#四代码" class="header-anchor">¶</a>（四）代码：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-comment">//抽象类,不能创建对象,可以创建指针和引用</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>AbstractClass() &#123;&#125;<br><span class="hljs-keyword">virtual</span> ~AbstractClass() &#123;&#125;<br><br><span class="hljs-comment">//纯虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toString</span>()</span> = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//实现的纯虚函数,但是没必要实现</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toString2</span>()</span> = <span class="hljs-number">0</span> &#123; cout &lt;&lt; <span class="hljs-string">&quot;toString2&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-comment">//派生类继承抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> : <span class="hljs-title">public</span> <span class="hljs-title">AbstractClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>SubClass() : AbstractClass() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>~SubClass() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//完成纯虚函数实现,可以创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toString</span>()</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Sub::toString()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toString2</span>()</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Sub::toString2()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//同样继承,但是未全部实现,仍为抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass2</span> :<span class="hljs-title">public</span> <span class="hljs-title">AbstractClass</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>SubClass2() : AbstractClass() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>~SubClass2() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//完成部分纯虚函数实现,不能创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toString</span>()</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;SubClass2::toString()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass3</span> :<span class="hljs-title">public</span> <span class="hljs-title">SubClass2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>SubClass3() : SubClass2() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>~SubClass3() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//toString的纯虚函数实现在SubClass2中实现了,此处可以不实现,也可以再次实现</span><br><span class="hljs-comment">//完成剩余部分的纯虚函数实现,可以创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toString2</span>()</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;SubClass3::toString2()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass4</span> :<span class="hljs-title">public</span> <span class="hljs-title">SubClass2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>SubClass4() : SubClass2() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br>~SubClass4() &#123;&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//toString的纯虚函数实现在SubClass2中实现了,此处重写实现</span><br><span class="hljs-comment">//完成全部的纯虚函数实现,可以创建对象</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toString</span>()</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;SubClass4::toString()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">toString2</span>()</span> &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;SubClass4::toString2()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//错误函数:不能将抽象类作为函数参数,也不能作为函数返回值。</span><br><span class="hljs-comment">//AbstractClass print(AbstractClass a) &#123; return; &#125;</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span>** argv</span>)</span> &#123;<br><span class="hljs-comment">//AbstractClass a;error:不允许使用抽象类类型的对象</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(AbstractClass) &lt;&lt; endl; <span class="hljs-comment">//为8,是虚指针</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(SubClass) &lt;&lt; endl;      <span class="hljs-comment">//亦为8，也是虚指针,两者始终相同</span><br>SubClass s;<br><span class="hljs-comment">//SubClass2 s2; error:不允许使用抽象类类型的对象</span><br>SubClass3 s3;<br>SubClass4 s4;<br>AbstractClass&amp; c = s;<br>AbstractClass* pc = &amp;s;<br>c.toString();<br>pc-&gt;toString2();<br>pc = &amp;s3;<br>pc-&gt;toString();<br>pc-&gt;toString2();<br>pc = &amp;s4;<br>pc-&gt;toString();<br>pc-&gt;toString2();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//Sub::toString()</span><br><span class="hljs-comment">//Sub::toString2()</span><br><span class="hljs-comment">//SubClass2::toString()</span><br><span class="hljs-comment">//SubClass3::toString2()</span><br><span class="hljs-comment">//SubClass4::toString()</span><br><span class="hljs-comment">//SubClass4::toString2()</span><br></code></pre></td></tr></table></figure><h3 id="异质链表"><a href="#异质链表" class="header-anchor">¶</a>异质链表：</h3><h4 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念：</h4><p>用基类类型指针（抽象类类型指针也可以），可以生成一个连接不同派生类对象的动态链表。</p><p>每个结点指针可以指向类层次中不同的派生类对象，这种结点类型不相同的链表被称为异质链表。</p><h4 id="二限制"><a href="#二限制" class="header-anchor">¶</a>（二）限制：</h4><ul class="lvl-0"><li class="lvl-2"><p>链表节点的类类型不止一个时，这些类必须是继承关系。</p></li><li class="lvl-2"><p>可以是多层继承关系，但是必须有一个基类是所有类的基类（类似于树的根节点）。</p></li><li class="lvl-2"><p>声明节点时的指针必须是基类类型，创建节点时new后面的类型可以是基类或者是派生类。</p></li><li class="lvl-2"><p>输出方法可以是各个类的自己成员函数或友元函数，或者是另写一个输出方法。</p></li></ul><h4 id="三代码"><a href="#三代码" class="header-anchor">¶</a>（三）代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> Person* head;<br><span class="hljs-type">static</span> Person* tail;<br>Person* next;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string n = <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>) :<span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123; cout &lt;&lt; <span class="hljs-string">&quot;Person()&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;   <span class="hljs-comment">//将新结点加入链表</span><br>    <span class="hljs-comment">//head、tail 是静态的，就相当于全局变量；</span><br><span class="hljs-keyword">if</span> (tail == <span class="hljs-literal">NULL</span>)<br>head = tail = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">else</span> &#123;<br>tail-&gt;next = <span class="hljs-keyword">this</span>;<br>tail = <span class="hljs-keyword">this</span>;<br>tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; name = &quot;</span> &lt;&lt; name &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot; age = &quot;</span> &lt;&lt; age &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~person()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br>Person* Person::head = <span class="hljs-literal">NULL</span>;<br>Person* Person::tail = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">//Student中增加了一个score</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-type">float</span> score;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> a, <span class="hljs-type">float</span> f) :<span class="hljs-built_in">Person</span>(n, a),<span class="hljs-built_in">score</span>(f) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Student()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;display student:&quot;</span> &lt;&lt; endl;<br>Person::<span class="hljs-built_in">display</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot; score =&quot;</span> &lt;&lt; score &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Student</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Student()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//Teacher中增加了salary</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> salary;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Teacher</span>(string n, <span class="hljs-type">int</span> a, <span class="hljs-type">double</span> salary) :<span class="hljs-built_in">Person</span>(n, a) &#123;<br><span class="hljs-keyword">this</span>-&gt;salary = salary;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;display teacher:&quot;</span> &lt;&lt; endl;<br>Person::<span class="hljs-built_in">display</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot; Salary =&quot;</span> &lt;&lt; salary &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Teacher</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~Teacher()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function">Student* <span class="hljs-title">CreateStudent</span><span class="hljs-params">()</span> </span>&#123;<br>string name;<br><span class="hljs-type">int</span>  age;<br><span class="hljs-type">float</span> score;<br>cout &lt;&lt; <span class="hljs-string">&quot;Student name:&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; name;<br>cout &lt;&lt; <span class="hljs-string">&quot;age: &quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; age;<br>cout &lt;&lt; <span class="hljs-string">&quot;score: &quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; score;<br>Student* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(name, age, score);<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Teacher* t1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-string">&quot;最萌斌斌姐&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-number">100</span>);<br>Student* s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;wlh&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">99</span>);<br>Student* s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Student</span>(<span class="hljs-string">&quot;zk&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">60</span>);<br>Teacher* t2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Teacher</span>(<span class="hljs-string">&quot;wdg&quot;</span>, <span class="hljs-number">45</span>, <span class="hljs-number">20</span>);<br>Student* ps = <span class="hljs-built_in">CreateStudent</span>();<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;Person list&quot;</span> &lt;&lt; endl;<br>t1-&gt;<span class="hljs-built_in">insert</span>();<br>s1-&gt;<span class="hljs-built_in">insert</span>();<br>s2-&gt;<span class="hljs-built_in">insert</span>();<br>t2-&gt;<span class="hljs-built_in">insert</span>();<br>ps-&gt;<span class="hljs-built_in">insert</span>();<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;dispay Person list:&quot;</span> &lt;&lt; endl;<br>Person* p;<br>p = Person::head;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>p-&gt;<span class="hljs-built_in">display</span>();<br>cout &lt;&lt; endl;<br>p = p-&gt;next;<br>&#125;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;delete whole list&quot;</span> &lt;&lt; endl;<br>p = Person::head;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span>)<br>&#123;<br>Person::head = p-&gt;next;<br><span class="hljs-keyword">delete</span> p;<br>p = Person::head;<br>&#125;<br>Person::tail = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*运行结果</span><br><span class="hljs-comment">Person()</span><br><span class="hljs-comment">Person()</span><br><span class="hljs-comment">Student()</span><br><span class="hljs-comment">Person()</span><br><span class="hljs-comment">Student()</span><br><span class="hljs-comment">Person()</span><br><span class="hljs-comment">Student name :</span><br><span class="hljs-comment">zzh</span><br><span class="hljs-comment">age :</span><br><span class="hljs-comment">21</span><br><span class="hljs-comment">score :</span><br><span class="hljs-comment">100</span><br><span class="hljs-comment">Person()</span><br><span class="hljs-comment">Student()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Person list</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">dispay Person list :</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">display teacher :</span><br><span class="hljs-comment">name = 最萌斌斌姐</span><br><span class="hljs-comment">age = 25</span><br><span class="hljs-comment">Salary = 100</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">display student :</span><br><span class="hljs-comment">name = wlh</span><br><span class="hljs-comment">age = 21</span><br><span class="hljs-comment">score = 99</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">display student :</span><br><span class="hljs-comment">name = zk</span><br><span class="hljs-comment">age = 21</span><br><span class="hljs-comment">score = 60</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">display teacher :</span><br><span class="hljs-comment">name = wdg</span><br><span class="hljs-comment">age = 45</span><br><span class="hljs-comment">Salary = 20</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">display student :</span><br><span class="hljs-comment">name = zzh</span><br><span class="hljs-comment">age = 21</span><br><span class="hljs-comment">score = 100</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">delete whole list</span><br><span class="hljs-comment">~Teacher()</span><br><span class="hljs-comment">~person()</span><br><span class="hljs-comment">~Student()</span><br><span class="hljs-comment">~person()</span><br><span class="hljs-comment">~Student()</span><br><span class="hljs-comment">~person()</span><br><span class="hljs-comment">~Teacher()</span><br><span class="hljs-comment">~person()</span><br><span class="hljs-comment">~Student()</span><br><span class="hljs-comment">~person()*/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——多态(二)</title>
    <link href="/xiaohei07.github.io/2023/04/08/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81(%E4%BA%8C)/"/>
    <url>/xiaohei07.github.io/2023/04/08/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="一动态联编"><a href="#一动态联编" class="header-anchor">¶</a>（一）动态联编：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>编译程序在编译阶段不能确定将要调用的函数，只有在程序执行时才能动态地确定将要调用的同名函数，为此。如果要确切地指明将要调用的函数，就要求联编工作在程序运行时进行，这种在程序运行时进行的联编工作被称为动态联编，或称动态束定，又叫晚期联编。</p><p>一旦涉及到虚函数和多态性均应当使用动态联编。</p><h4 id="2-使用"><a href="#2-使用" class="header-anchor">¶</a>2. 使用：</h4><p>必须用基类指针调用派生类的不同实现版本，且被调用的必须是虚函数，且必须完成对基类虚函数的重写（稍后说明虚函数和重写），动态联编对成员函数的选择是基于指针所指向的对象类型。（因为基类指针引用派生类对象不需要进行显式转换）</p><h4 id="3-优点"><a href="#3-优点" class="header-anchor">¶</a>3. 优点：</h4><p>灵活性强但效率低。</p><h3 id="二虚函数"><a href="#二虚函数" class="header-anchor">¶</a>（二）虚函数：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p><strong>虚函数</strong>是在基类中使用关键字<strong>virtual</strong>声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。</p><p>virtual关键字只用在类定义里的函数声明中，写函数体时不用。</p><p>c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加，但习惯上每一层声明函数时都加virtual,使程序更加清晰。</p><p>虚函数需要重写，一个虚函数在派生类层界面相同的重载函数都保持虚特性。</p><ul class="lvl-0"><li class="lvl-2"><p>虚函数重写：虚函数重写是指在基类中声明实现的虚函数在派生类中再次实现，且基类和派生类中虚函数的原型必须保持一致（返回值类型，函数名称以及参数列表），协变函数（基类或派生类的虚函数返回本身类型的指针或引用）和析构函数除外。</p><p>协变函数：子类的虚函数和父类的虚函数的返回值可以不同，也能构成重载。但需要子类的返回值是一个子类的指针或者引用，父类的返回值是一个父类的指针或者引用，且返回值代表的两个类也成继承关系。这个叫做协变。</p><p>重写的访问限定符可以不同。</p><p>如果仅仅返回类型不同，c++认为是错误重载。</p><p>如果函数原型不同，仅函数名相同，会丢失虚特性。</p></li><li class="lvl-2"><p>隐藏：不局限于虚函数，但需要和虚函数概念结合理解。</p><p>隐藏是指派生类的函数屏蔽了与其同名的基类函数。</p><p>如果派生类的函数与基类的函数同名，但是参数不同。此时，不论是否为虚函数，基类的函数将被隐藏（注意不是重载，重载是在同一个类中发生）。</p><p>如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意不是重写，重写有virtual关键字）。</p></li></ul><p>——实际上共有四种情况：</p><ol><li class="lvl-3"><p>参数相同、有virtual关键字：多态重写；</p></li><li class="lvl-3"><p>参数相同、无virtual关键字：隐藏；与重写区分。</p></li><li class="lvl-3"><p>参数不同、有virtual关键字：隐藏；与重载区分。</p></li><li class="lvl-3"><p>参数不同、无virtual关键字：隐藏；与重载区分。</p></li></ol><h4 id="2-限制"><a href="#2-限制" class="header-anchor">¶</a>2. 限制：</h4><ul class="lvl-0"><li class="lvl-2"><p>只有类的成员函数才能声明为虚函数（友元函数、全局函数等都不可以），虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。</p></li><li class="lvl-2"><p>静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。</p></li><li class="lvl-2"><p>内联函数不能是虚函数，因为内联函数不能在运行中动态确定位置。</p></li><li class="lvl-2"><p>构造函数不能是虚函数：</p><p>建立派生类对象是从类层次的根开始沿着继承路径逐个调用基类的构造函数，声明为虚的无法全部初始化，而且构造函数是创建时自动调用的，不可能用父类的指针引用or调用。</p></li><li class="lvl-2"><p>析构函数可以是虚函数，而且建议声明为虚函数。</p><p>虚析构函数用于指引delete运算符正确析构动态对象。否则可能不能正确识别对象类型而不能正确调用析构函数。</p><p>实际上，析构函数被编译器全部换成了Destructor，所以加上virtual就可以成为虚析构函数。只要父类的析构函数用virtual修饰，无论子类是否有virtual，都构成析构。这也解释了为什么派生类不写virtual可以构成重写，因为编译器担心你忘记析构。</p><p>实际上，析构函数即使是虚函数，仍为静态联编。因为它们所调用的虚函数是自己的类，或者基类中定义的函数而不是在任何派生类中重定义的函数</p></li><li class="lvl-2"><p>不建议把赋值运算符重载作为虚函数。</p></li></ul><h4 id="3-工作原理"><a href="#3-工作原理" class="header-anchor">¶</a>3. 工作原理：</h4><p>C++编译器处理虚函数的方法是给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向存放函数地址的数组的指针（vptr）。这种数组称为<strong>虚函数表</strong>（vtable）。虚函数表中存储了为类对象进行声明的虚函数的地址。</p><p>注意：这个隐藏成员默认是第一个数据成员，在地址中分布在最开始处。</p><p>虚函数表只存在于有虚函数的类及其派生类中，会使其多出8字节，这8字节存放了虚函数表本身的地址。</p><p>如：基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。</p><p>派生类对象将包含一个指向独立地址表（也就是和基类无关）的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址。</p><p>如果派生类没有重新定义虚函数，该指针将保存原始版本的地址（理论上和基类的虚函数表相同）。如果派生类定义了新的虚函数（指基类没有的），则该函数的地址也将被添加到该指针中。</p><p>不论包含的虚函数数量，都只需要在对象中添加一个地址成员，只是大小不同而已。</p><p>当调用虚函数时，程序将查看存储在对象中的指针地址，然后转向相应的函数地址表。如果类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行该地址对应的函数。如果使用类声明中的第三个函数，程序将使用地址为数组中的第三个元素的函数。</p><p>所以使用虚函数和动态联编，无可避免地会增加内存和时间的开销，</p><ul class="lvl-0"><li class="lvl-2"><p>每个对象都将增大，增大量为存储地址的空间；</p></li><li class="lvl-2"><p>对于每个类，编译器都会创建一个虚函数地址表（本质上就是数组）；</p></li><li class="lvl-2"><p>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</p></li></ul><h4 id="4-c11-override-ampamp-final"><a href="#4-c11-override-ampamp-final" class="header-anchor">¶</a>4. C++11 override &amp;&amp; final</h4><p>C++11新增了两个关键字override和final。</p><p>被override修饰的虚函数，编译器会检查这个虚函数是否重写。如果没有重写，编译器会报错。</p><p>用final修饰的虚函数无法重写。用final修饰的类无法被继承。final像这个单词的意思一样，这就是最终的版本，不用再更新了。</p><h4 id="5-表现"><a href="#5-表现" class="header-anchor">¶</a>5. 表现：</h4><ul class="lvl-0"><li class="lvl-2"><p>通过基类指针调用基类和派生类中的同名虚函数时:</p><ol><li class="lvl-5">若该指针指向一个基类的对象，那么被调用的是基类的虚函数；</li><li class="lvl-5">若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li></ol><p>这种机制就是实际上的“多态”——调用哪个虚函数，取决于指针对象指向哪种类型的对象。</p></li><li class="lvl-2"><p>通过基类引用调用基类和派生类中的同名虚函数时:</p><ol><li class="lvl-5">若该引用引用了一个基类的对象，那么被调用的是基类的虚函数；</li><li class="lvl-5">若该引用引用了一个派生类的对象，那么被调用的是派生类的虚函数。</li></ol><p>这种机制也是实际上的“多态”——调用哪个虚函数，取决于指针对象指向哪种类型的对象。</p></li></ul><h4 id="6代码"><a href="#6代码" class="header-anchor">¶</a>6.代码：</h4><ul class="lvl-0"><li class="lvl-2"><p>一般情况的函数的虚函数重写，发生了动态联编（各种错误也在其中）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">#include&lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-comment">//不允许对友元函数使用virtual</span><br><span class="hljs-comment">//virtual friend void fun();</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//如果下面的静态数据成员和成员函数被声明,不允许加virtual,必须去掉</span><br><span class="hljs-comment">//static int i;</span><br><span class="hljs-comment">//virtual static void addi()&#123;&#125;</span><br><br><span class="hljs-comment">//不能对构造函数加virtual,必须去掉</span><br><span class="hljs-comment">//virtual Person() &#123;&#125;</span><br><br><span class="hljs-comment">//一般虚函数声明</span><br>virtual void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person-&gt;fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//内联虚函数,能否内联成功取决于编译器对其的判断是否为虚函数</span><br><span class="hljs-keyword">inline</span> virtual void fun2()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person-&gt;fun()2&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//不被允许的操作:仅改变返回类型,编译器无法区别。</span><br><span class="hljs-comment">//virtual int fun()</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;Person-&gt;fun()&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br>&#125;;<br><span class="hljs-comment">//不能对全局函数使用virtual</span><br><span class="hljs-comment">//virtual void fun()&#123;&#125;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-type">public</span> <span class="hljs-title">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:       <br>virtual void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-comment">//子类重写父类虚函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Student-&gt;fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//重写内联虚函数,能否内联成功取决于编译器对其的判断是否为虚函数</span><br><span class="hljs-keyword">inline</span> virtual void fun2()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Student-&gt;fun()2&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>:<span class="hljs-type">public</span> <span class="hljs-title">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:      <br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-comment">//子类重写父类虚函数,不加virtual但编译器默认其为虚函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Teacher-&gt;fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//下面的fun函数因为有参数,和前面了产生了函数原型的区别,</span><br><span class="hljs-comment">//实际上丢失了虚特性</span><br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(int)</span></span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person2-&gt;fun()&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodStudent</span> :<span class="hljs-type">public</span> <span class="hljs-title">Student</span> <br>&#123;<br>virtual void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-comment">//子类重写父类虚函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;GoodStudent-&gt;fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodTeacher</span> :<span class="hljs-type">public</span> <span class="hljs-title">Teacher</span><br>&#123;<br>void <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-comment">//子类重写父类虚函数,不加virtual但编译器默认其为虚函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;GoodTeacher-&gt;fun()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br>int main()<br>&#123;<br>Student s;<br>GoodStudent gs;<br>Teacher t;<br>GoodTeacher gt;<br>Person* p = &amp;s;<br><span class="hljs-comment">//基类指针指向派生类,因为虚函数的声明,所以调用的是派生类的重写虚函数。</span><br>p-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//此处发生内联，因为用对象执行成员函数是可以在编译时确定联编的</span><br>s.fun2();<br><span class="hljs-comment">//此处未发生内联,inline被自动忽略了，因为用指针发生虚函数执行，此时是动态联编，不能直接内联。</span><br>p-&gt;fun2();<br>p = &amp;t;<br><span class="hljs-comment">//同p-&gt;fun();</span><br>p-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>p = &amp;gs;<br><span class="hljs-comment">//调用GoodStudent的重写虚函数</span><br>p-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>p = &amp;gt;<br><span class="hljs-comment">//调用GoodTeacher的重写虚函数</span><br>p-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>Student* ps = &amp;gs;<br><span class="hljs-comment">//派生类Student指针指向其派生类GoodStudent,调用GoodStudent的重写虚函数</span><br>ps-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>Teacher* pt = &amp;gt;<br>pt-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>pt-&gt;Teacher::<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//访问限定符可以不同,强制执行Teacher的fun函数</span><br><br>cout &lt;&lt; endl;<br><span class="hljs-comment">//基类引用引用派生类,和指针效果相同。</span><br><span class="hljs-comment">//注意引用一经确定对象后就无法修改了</span><br>Person&amp; cp1=s;<br>cp1.<span class="hljs-keyword">fun</span>();<br>cp1.fun2();<br>Person&amp; cp2 = t;<br>cp2.<span class="hljs-keyword">fun</span>();<br>Person&amp; cp3 = gs;<br>cp3.<span class="hljs-keyword">fun</span>();<br>Person&amp; cp4 = gt;<br>cp4.<span class="hljs-keyword">fun</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//Student-&gt;fun()</span><br><span class="hljs-comment">//Student-&gt;fun()2</span><br><span class="hljs-comment">//Student-&gt;fun()2</span><br><span class="hljs-comment">//Teacher-&gt;fun()</span><br><span class="hljs-comment">//GoodStudent-&gt;fun()</span><br><span class="hljs-comment">//GoodTeacher-&gt;fun()</span><br><span class="hljs-comment">//GoodStudent-&gt;fun()</span><br><span class="hljs-comment">//GoodTeacher-&gt;fun()</span><br><span class="hljs-comment">//Teacher-&gt;fun()</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//Student-&gt;fun()</span><br><span class="hljs-comment">//Student-&gt;fun()2</span><br><span class="hljs-comment">//Teacher-&gt;fun()</span><br><span class="hljs-comment">//GoodStudent-&gt;fun()</span><br><span class="hljs-comment">//GoodTeacher-&gt;fun()</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>协变函数的重写，发生了动态联编：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">#include&lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>virtual Person* <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-comment">//返回父类指针</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person-&gt;fun()&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> nullptr;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<span class="hljs-type">public</span> <span class="hljs-title">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//返回子类指针，虽然返回值不同，也构成重写</span><br>virtual Student* <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><span class="hljs-comment">//子类重写父类虚函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Student-&gt;fun()&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> nullptr;<br>&#125;<br>&#125;;<br>int main()<br>&#123;<br>Person p;<br>Student s;<br>Person* pp = &amp;p;<br>pp-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br>pp = &amp;s;<br>pp-&gt;<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//执行Student的成员函数</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>虚函数表指针的占用大小和实际作用：</p><p>64位和32位的大小不同（因为虚指针vptr在64位占8字节，int发生了自动补齐，需要全部按数据成员最大占8字节处理所有数据成员，32位因为vptr只占4位，不会发生自动补齐）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">int</span> i;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> &#123; &#125; <span class="hljs-comment">// 虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print2</span>()</span> &#123; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">public</span> <span class="hljs-title">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">int</span> n;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> &#123; &#125; <span class="hljs-comment">// 虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print2</span>()</span> &#123; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">int</span> i;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span> &#123; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>Base2 b;<br>Base bb;<br>Derived d;<br><span class="hljs-comment">//64位下运行结果:</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; endl;  <span class="hljs-comment">//4-&gt;int              </span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(bb) &lt;&lt; endl;  <span class="hljs-comment">//16=8+8-&gt;vptr(64位下占8字节)+int(从4补齐到8)</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(d) &lt;&lt; endl;   <span class="hljs-comment">//24=8+8+8-&gt;vptr+int+int(均从4补齐到8)</span><br><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Base2) &lt;&lt; endl;  <span class="hljs-comment">//4</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Base) &lt;&lt; endl;    <span class="hljs-comment">//16</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Derived) &lt;&lt; endl; <span class="hljs-comment">//24</span><br><span class="hljs-comment">//32位下运行结果:</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(b) &lt;&lt; endl;  <span class="hljs-comment">//4-&gt;int              </span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(bb) &lt;&lt; endl;  <span class="hljs-comment">//8=4+4-&gt;vptr(64位下占4字节)+int</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(d) &lt;&lt; endl;   <span class="hljs-comment">//12=4+4+4-&gt;vptr+int+int</span><br><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Base2) &lt;&lt; endl;  <span class="hljs-comment">//4</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Base) &lt;&lt; endl;    <span class="hljs-comment">//8</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Derived) &lt;&lt; endl; <span class="hljs-comment">//12</span><br><br>Base* pb = <span class="hljs-keyword">new</span> Derived();<br>pb-&gt;Print();<br><span class="hljs-comment">//Derive</span><br><span class="hljs-built_in">int</span>* p1 = (<span class="hljs-built_in">int</span>*)&amp;bb;<br><span class="hljs-built_in">int</span>* p2 = (<span class="hljs-built_in">int</span>*)pb;<br><br>*p2 = *p1;<br>pb-&gt;Print();<br><span class="hljs-comment">//Base</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Derive原因:pb指向的是Derived对象，因此pb执行Print()时实际执行的是Derived的虚函数。</p><p>p1实际是Base的虚指针(64位请改成double，因为要占8位才能和pvtr对齐)，p2实际是Derive的虚指针。</p><p>通过*p2=*p1，将Base的虚指针赋给了Derive的虚指针，从而修改了Derive对应的虚指针，使其也指向了Base的虚函数表，故代码后面的调用最终执行了Base的虚函数。</p></li><li class="lvl-2"><p>虚析构函数的实际效果：</p><p>如下，对于基类指针指向派生类对象，如果对析构函数进行了virtual声明，在析构此指针指向对象时调用的是派生类的析构函数（这个析构函数可以再调用基类的析构函数）；如果不进行声明，在析构此指针指向对象时调用的是基类的析构函数。</p><p>显然前者是我们更需要的，否则派生类中的某些成员我们无法析构。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;iostream&gt;</span><br>using namespace std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>public:<br>virtual  ~A()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-attr"> : public</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>public:<br>virtual ~B()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~B()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A2</span></span><br><span class="hljs-class"></span>&#123;<br>public:<br> ~A2()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~A2()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B2</span><span class="hljs-attr"> : public</span> <span class="hljs-title">A2</span></span><br><span class="hljs-class"></span>&#123;<br>public:<br>~B2()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;~B2()&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">int</span> main()<br>&#123;<br>A* a = new B;<br><span class="hljs-keyword">delete</span> a;<br><span class="hljs-regexp">//</span>~B()<br>//~A()<br>A2* a2 = new B2;<br><span class="hljs-keyword">delete</span> a2;<br><span class="hljs-regexp">//</span>~A2()<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>override &amp;&amp; final：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//正确,前面有声明的成员虚函数可供其重写,不会报错</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span>  <span class="hljs-keyword">override</span></span>&#123;&#125;<br><span class="hljs-comment">//错误:使用“override”声明的成员函数不能重写基类成员</span><br><span class="hljs-comment">//也就是前面必须有基类成员声明为了虚函数可供其重写</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">final</span> <span class="hljs-comment">//A类无法被继承</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> <span class="hljs-comment">//fun函数无法被重写</span></span><br><span class="hljs-function"></span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A <span class="hljs-comment">//错误:不能将final类类型作为基类</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> <span class="hljs-comment">//错误:不能重写final中的虚函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——多态(一)</title>
    <link href="/xiaohei07.github.io/2023/04/08/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81(%E4%B8%80)/"/>
    <url>/xiaohei07.github.io/2023/04/08/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E6%80%81(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><h4 id="1-简介"><a href="#1-简介" class="header-anchor">¶</a>1. 简介：</h4><p>多态字面意思就是多种形态，可以简单地概括为“一个接口，多种方法”，多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作，多态是面向对象编程领域的核心概念。</p><h4 id="2-目的"><a href="#2-目的" class="header-anchor">¶</a>2. 目的：</h4><p>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了“接口重用”。也即，不论传递过来的究竟是类的哪个对象，函数都能够通过同一个接口调用到适应各自对象的实现方法。</p><h4 id="3-c的应用"><a href="#3-c的应用" class="header-anchor">¶</a>3. c++的应用：</h4><p>当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++中的多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p><p>c++中多态最常见的用法就是声明基类类型的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。</p><h4 id="4-分类"><a href="#4-分类" class="header-anchor">¶</a>4. 分类：</h4><p>C++支持两种多态性：编译时多态性，运行时多态性。前者被称为静态多态（也叫静态联编），通过重载函数和泛型编程实现；后者被称为动态多态（也叫动态联编），主要依赖虚函数体现。</p><p>两者的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。</p><p>一般情况下，我们说明的多态多数是指动态多态。</p><h3 id="二静态联编"><a href="#二静态联编" class="header-anchor">¶</a>（二）静态联编：</h3><h4 id="1-联编"><a href="#1-联编" class="header-anchor">¶</a>1. 联编：</h4><p>联编是指一个程序模块、代码之间相互关联的过程。</p><p>将源代码中的函数调用解释为执行特定的函数代码块的过程称为函数名联编。</p><p>同一个名称的函数有多种，联编可以把调用和具体的实现进行链接映射到某个最适合的函数。</p><h4 id="2-概念"><a href="#2-概念" class="header-anchor">¶</a>2. 概念：</h4><p>C++编译器在编译过程中完成的编译叫做静态联编，也就是早期匹配。因为这种联编实在程序开始运行之前就完成了。在程序编译阶段进行的这种联编在编译时就解决了程序的操作调用与执行该操作代码间的关系。</p><p>静态联编的效率高，但灵活性差。</p><h4 id="3-体现"><a href="#3-体现" class="header-anchor">¶</a>3. 体现：</h4><p>普通成员函数重载可表达为两种形式：</p><ul class="lvl-0"><li class="lvl-2"><p>只在一个类说明中重载：</p><p>等价于一般函数重载，编译器可以根据其形参表进行区分。</p></li><li class="lvl-2"><p>基类的成员在派生类重载：</p><p>有三种编译区分方法：</p><ul class="lvl-2"><li class="lvl-4"><p>根据参数的特征加以区分。（该方法实际上和上面的类似，只是可以都在任何一个继承层次上）</p></li><li class="lvl-4"><p>使用&quot;::&quot;加以区分。</p></li><li class="lvl-4"><p>根据类对象加以区分。</p></li></ul></li></ul><p>实际上，静态联编对函数的选择是基于指向对象的指针或者引用的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">double</span> i = <span class="hljs-number">0</span>) :<span class="hljs-built_in">a</span>(i) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt;<span class="hljs-string">&quot;A1:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">bool</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A2:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> b;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">double</span> i = <span class="hljs-number">0</span>) :<span class="hljs-built_in">b</span>(i) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;B1:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(string)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;B2:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>A a;<br>B b;<br>a.<span class="hljs-built_in">print</span>();      <span class="hljs-comment">//A1</span><br>a.<span class="hljs-built_in">print</span>(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//A2</span><br>b.<span class="hljs-built_in">print</span>();      <span class="hljs-comment">//B1</span><br>b.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>);   <span class="hljs-comment">//B2</span><br>a.<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>);   <span class="hljs-comment">//A2,强制类型转换</span><br><span class="hljs-comment">//b.print(true);//无法匹配</span><br>b.A::<span class="hljs-built_in">print</span>();   <span class="hljs-comment">//A1</span><br>b.A::<span class="hljs-built_in">print</span>(<span class="hljs-literal">true</span>);   <span class="hljs-comment">//A2</span><br>b.B::<span class="hljs-built_in">print</span>();   <span class="hljs-comment">//B1</span><br>b.B::<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//B2</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三类指针的关系"><a href="#三类指针的关系" class="header-anchor">¶</a>（三）类指针的关系：</h3><p>基类指针、引用和派生类指针、引用与基类对象和派生类对象有4种的可能匹配：</p><ul class="lvl-0"><li class="lvl-2"><p>直接用基类指针、引用来引用基类对象。</p></li><li class="lvl-2"><p>直接用派生类指针、引用来引用派生类对象。</p></li><li class="lvl-2"><p>用基类的指针、引用来引用一个派生类对象：</p><p>只能访问从基类继承的对象，除非对这个基类指针进行强制类型转换成派生类指针，用派生类指针访问。</p></li><li class="lvl-2"><p>用派生类指针、引用来引用一个基类对象：</p><p>不安全，会越界访问，不被允许，派生类指针只有经过强制类型转换之后才能引用基类对象。</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">double</span> a;<br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-built_in">double</span> i = <span class="hljs-number">0</span>) :a(i) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>()</span> <br>&#123;<br>cout &lt;&lt; typeid(<span class="hljs-keyword">this</span>).name() &lt;&lt; endl;<br>cout &lt;&lt;<span class="hljs-string">&quot;A1:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span></span>)</span> <br>&#123;<br>cout &lt;&lt; typeid(<span class="hljs-keyword">this</span>).name() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;A2:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:<span class="hljs-title">public</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">double</span> b;<br><span class="hljs-keyword">public</span>:<br>B(<span class="hljs-built_in">double</span> i = <span class="hljs-number">0</span>) :b(i) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>()</span><br>&#123;<br>cout &lt;&lt; typeid(<span class="hljs-keyword">this</span>).name() &lt;&lt; endl;<br>cout &lt;&lt; typeid((A*)<span class="hljs-keyword">this</span>).name() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;B1:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-built_in">string</span></span>)</span><br>&#123;<br>cout &lt;&lt; typeid(<span class="hljs-keyword">this</span>).name() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;B2:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> <br>&#123;<br><span class="hljs-function">A <span class="hljs-title">a</span>(<span class="hljs-params"><span class="hljs-number">3</span></span>)</span>;<br><span class="hljs-function">B <span class="hljs-title">b</span>(<span class="hljs-params"><span class="hljs-number">4</span></span>)</span>;<br>A* pa = &amp;a;<br>pa-&gt;print();<br>cout &lt;&lt; endl;<br>B* pb = &amp;b;<br>pb-&gt;print();<br>cout &lt;&lt; endl;<br>pa = &amp;b;<br>pa-&gt;print();<br>cout &lt;&lt; endl;<br>B* pbb = (B*)pa;<br>pbb-&gt;print();<br>cout &lt;&lt; endl;<br>A* paa = (A*)&amp;pb; <span class="hljs-comment">//A中数未初始化</span><br>paa-&gt;print();<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——继承(三)</title>
    <link href="/xiaohei07.github.io/2023/04/05/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF(%E4%B8%89)/"/>
    <url>/xiaohei07.github.io/2023/04/05/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<p>本部分主要是继承的应用实例：</p><p>考察一个点、圆、圆柱体的层次结构。</p><img src="https://s1.ax1x.com/2023/04/05/pp5dacj.png" style="zoom:33%;"><p>为其各自设计输出运算符的友元重载。</p><p>Point数据成员为x和y，能够重写点位置和获得点位置，能输出点位置；</p><p>Circle继承Point，除了Point的成员和功能外，同时拥有自己的数据成员radius，能够获得和重写radius，也可以计算并获得出其面积；</p><p>Cylinder继承Circle，除了Circle的成员和功能外，同时拥有自己的数据成员weight，能够获得和重写weight，也可以计算并获得出其面积；</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> Point&amp; p);<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> d1 = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> d2 = <span class="hljs-number">0.0</span>) :<span class="hljs-built_in">x</span>(d1), <span class="hljs-built_in">y</span>(d2) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPoint</span><span class="hljs-params">(<span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2)</span> </span><br><span class="hljs-function"></span>&#123;<br>x = d1, y = d2;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> :<span class="hljs-keyword">public</span> Point<br>&#123;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> Circle&amp; c);<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> radius;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Circle</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> d1 = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> d2 = <span class="hljs-number">0.0</span>):<span class="hljs-built_in">radius</span>(r),<span class="hljs-built_in">Point</span>(d1,d2) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRadius</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> </span><br><span class="hljs-function"></span>&#123;<br>radius = (r &gt; <span class="hljs-number">0</span> ? r : <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getRadius</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> radius; &#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>) * radius * radius;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cylinder</span> :<span class="hljs-keyword">public</span> Circle<br>&#123;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> Cylinder&amp; c);<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> height;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cylinder</span>(<span class="hljs-type">double</span> h=<span class="hljs-number">0.0</span>,<span class="hljs-type">double</span> r=<span class="hljs-number">0.0</span>,<span class="hljs-type">double</span> d1=<span class="hljs-number">0.0</span>,<span class="hljs-type">double</span> d2=<span class="hljs-number">0.0</span>):<span class="hljs-built_in">height</span>(h),<span class="hljs-built_in">Circle</span>(r,d1,d2)&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">double</span> h)</span> </span><br><span class="hljs-function"></span>&#123;<br>height = (h &gt; <span class="hljs-number">0</span> ? h : <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> height; &#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">area</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * Circle::<span class="hljs-built_in">area</span>() + <span class="hljs-number">2</span> * <span class="hljs-built_in">acos</span>(<span class="hljs-number">-1</span>) * radius * height;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">volume</span><span class="hljs-params">()</span><span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> Circle::<span class="hljs-built_in">area</span>() * height;<br>&#125;<br><br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> Point&amp; p)<br>&#123;<br>output &lt;&lt; <span class="hljs-string">&quot;Point: (&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl &lt;&lt; endl;<br><span class="hljs-keyword">return</span> output;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> Circle&amp; c)<br>&#123;<br>output &lt;&lt; <span class="hljs-string">&quot;Circle:&quot;</span> &lt;&lt; endl;<br>output &lt;&lt; <span class="hljs-string">&quot;Center: (&quot;</span> &lt;&lt; c.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; c.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>output &lt;&lt; <span class="hljs-string">&quot;Radius:&quot;</span> &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed | ios::showpoint) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; c.radius &lt;&lt; endl;<br><span class="hljs-keyword">return</span> output;<br>&#125;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> Cylinder&amp; c)<br>&#123;<br>output &lt;&lt; <span class="hljs-string">&quot;Cylinder:&quot;</span> &lt;&lt; endl;<br>output &lt;&lt; <span class="hljs-string">&quot;Center: (&quot;</span> &lt;&lt; c.x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; c.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>output &lt;&lt; <span class="hljs-string">&quot;Radius:&quot;</span> &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed | ios::showpoint) &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; c.radius &lt;&lt; endl;<br>output &lt;&lt; <span class="hljs-string">&quot;Height:&quot;</span> &lt;&lt; c.height &lt;&lt; endl;<br><span class="hljs-keyword">return</span> output;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; p;<br>p.<span class="hljs-built_in">setPoint</span>(<span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;change Point p:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; p;<br><br><span class="hljs-function">Circle <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">8.1</span>, <span class="hljs-number">3.1</span>, <span class="hljs-number">4.1</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;c:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; c;<br>cout &lt;&lt; <span class="hljs-string">&quot;c area:&quot;</span> &lt;&lt; c.<span class="hljs-built_in">area</span>() &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>c.<span class="hljs-built_in">setRadius</span>(<span class="hljs-number">8</span>);<br>c.<span class="hljs-built_in">setPoint</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;chaneg Circle c:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; c;<br>cout &lt;&lt; <span class="hljs-string">&quot;c area:&quot;</span> &lt;&lt; c.<span class="hljs-built_in">area</span>() &lt;&lt; endl;<br>cout &lt;&lt; endl;<br><br><span class="hljs-function">Cylinder <span class="hljs-title">cy</span><span class="hljs-params">(<span class="hljs-number">5.5</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>, <span class="hljs-number">4.5</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;cy:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; cy;<br>cout &lt;&lt; <span class="hljs-string">&quot;cy area:&quot;</span> &lt;&lt; cy.<span class="hljs-built_in">area</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;cy volume:&quot;</span> &lt;&lt; cy.<span class="hljs-built_in">area</span>() &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>cy.<span class="hljs-built_in">setHeight</span>(<span class="hljs-number">5</span>);<br>cy.<span class="hljs-built_in">setRadius</span>(<span class="hljs-number">2</span>);<br>cy.<span class="hljs-built_in">setPoint</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;chaneg Cylinder cy:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; cy;<br>cout &lt;&lt; <span class="hljs-string">&quot;cy area:&quot;</span> &lt;&lt; cy.<span class="hljs-built_in">area</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;cy volume:&quot;</span> &lt;&lt; cy.<span class="hljs-built_in">volume</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//p:</span><br><span class="hljs-comment">//Point: (2.5, 3.5)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//change Point p :</span><br><span class="hljs-comment">//Point: (9, 10)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//c :</span><br><span class="hljs-comment">//Circle :</span><br><span class="hljs-comment">//Center : (3.1, 4.1)</span><br><span class="hljs-comment">//Radius : 8.10</span><br><span class="hljs-comment">//c area : 206.12</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//chaneg Circle c :</span><br><span class="hljs-comment">//Circle:</span><br><span class="hljs-comment">//Center: (1.00, 2.00)</span><br><span class="hljs-comment">//Radius : 8.00</span><br><span class="hljs-comment">//c area : 201.06</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//cy :</span><br><span class="hljs-comment">//Cylinder :</span><br><span class="hljs-comment">//Center : (3.50, 4.50)</span><br><span class="hljs-comment">//Radius : 2.50</span><br><span class="hljs-comment">//Height : 5.50</span><br><span class="hljs-comment">//cy area : 125.66</span><br><span class="hljs-comment">//cy volume : 125.66</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//chaneg Cylinder cy :</span><br><span class="hljs-comment">//Cylinder:</span><br><span class="hljs-comment">//Center: (3.00, 4.00)</span><br><span class="hljs-comment">//Radius : 2.00</span><br><span class="hljs-comment">//Height : 5.00</span><br><span class="hljs-comment">//cy area : 87.96</span><br><span class="hljs-comment">//cy volume : 62.83</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——继承(二)</title>
    <link href="/xiaohei07.github.io/2023/04/03/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF(%E4%BA%8C)/"/>
    <url>/xiaohei07.github.io/2023/04/03/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="一基类和派生类的默认成员函数"><a href="#一基类和派生类的默认成员函数" class="header-anchor">¶</a>（一）基类和派生类的默认成员函数：</h3><p>默认的成员函数共有六个：</p><ul class="lvl-0"><li class="lvl-2"><p>构造函数</p></li><li class="lvl-2"><p>析构函数</p></li><li class="lvl-2"><p>拷贝构造函数</p></li><li class="lvl-2"><p>重载的赋值操作符</p></li><li class="lvl-2"><p>重载的取地址操作符</p></li><li class="lvl-2"><p>重载的const修饰的取地址操作符。</p></li></ul><p>在继承关系内，在派生类中如果没有显示定义这六个默认构造函数，编译器系统会默认合成这六个成员函数。</p><p>后面的两个很少需要我们自己实现，此处略。</p><h4 id="1-构造函数"><a href="#1-构造函数" class="header-anchor">¶</a>1. 构造函数：</h4><p>建立一个类层次后，通常创建某个派生类的对象，该对象也包括使用基类的数据和函数。</p><p>c++提供一种机制，在创建派生类对象时用指定参数调用基类的构造函数来初始化派生类继承基类的数据。</p><p>此时，派生类的构造函数声明为：</p><p><em><strong>派生类构造函数(变元表)：基类(变元表),对象成员1(变元表), ……. , 对象成员n(变元表) { 函数体}</strong></em></p><p>派生类的构造函数必须调用基类的构造函数初始化基类的那一部分成员，如果基类没有默认的构造函数，则必须在派生类构造函数的初始化列表阶段显式调用。</p><p>构造函数的执行顺序为基类-&gt;派生类。</p><h4 id="2-析构函数"><a href="#2-析构函数" class="header-anchor">¶</a>2. 析构函数：</h4><p>因为在派生类的构造函数调用了基类的构造函数，因此其析构函数也需要对派生类对象和基类对象都进行清理。该任务的完成由各自的析构函数完成。</p><p>析构函数的执行顺序为派生类-&gt;基类。</p><p>注意：不要在派生类中主动调用基类的析构函数，因为派生类的析构函数在被调用完成后会自动调用基类的析构函数清理基类成员。以此来保证派生类对象先清理派生类成员再清理基类成员。</p><h4 id="3-拷贝构造函数"><a href="#3-拷贝构造函数" class="header-anchor">¶</a>3. 拷贝构造函数：</h4><p>派生类的拷贝构造函数必须调用基类的拷贝构造函数完成对基类的拷贝初始化。</p><p>基类的拷贝构造函数会通过“切片”（见后面的内容）拿到基类需要的一部分值进行初始化。</p><h4 id="4-赋值操作符重载"><a href="#4-赋值操作符重载" class="header-anchor">¶</a>4. 赋值操作符重载：</h4><p>派生类的operator=必须要显式调用基类的operator=完成基类的复制。</p><p>因为基类和派生类的运算符，编译器默认给的是同一个名字，构成了隐藏，每次调用=这个赋值运算符都会一直调用子类，造成无限循环，所以赋值运算符要直接修饰限定的基类。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">double</span> weight;<br><span class="hljs-type">double</span> height;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Father</span>(string s=<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> w=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> h=<span class="hljs-number">0</span>) :<span class="hljs-built_in">name</span>(s), <span class="hljs-built_in">age</span>(i), <span class="hljs-built_in">weight</span>(w), <span class="hljs-built_in">height</span>(h)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用基类的构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Father</span>(<span class="hljs-type">const</span> Father&amp; f)<br>&#123;<br>name = f.name;<br>age = f.age;<br>weight = f.weight;<br>height = f.height;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用基类的拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>Father&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Father&amp; f)<br>&#123;<br>name = f.name;<br>age = f.age;<br>weight = f.weight;<br>height = f.height;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用基类的赋值运算符&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Father</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用基类的析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>:<span class="hljs-keyword">public</span> Father<br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> sex;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>(string s=<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-type">int</span> i1=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> w=<span class="hljs-number">0</span>, <span class="hljs-type">double</span> h=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> i2=<span class="hljs-number">0</span>):<span class="hljs-built_in">Father</span>(s,i1,w,h),<span class="hljs-built_in">sex</span>(i2)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用派生类的构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">Son</span>(<span class="hljs-type">const</span> Son&amp; s):<span class="hljs-built_in">Father</span>(s)<br>&#123;<br>sex = s.sex;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用派生类的拷贝构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>Son&amp; <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> Son&amp; s)<br>&#123;<br>Father::<span class="hljs-keyword">operator</span>=(s);<br>sex = s.sex;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用派生类的赋值运算符&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>~<span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用派生类的析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Son <span class="hljs-title">me</span><span class="hljs-params">(<span class="hljs-string">&quot;S&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">188</span>, <span class="hljs-number">190</span>, <span class="hljs-number">0</span>)</span></span>;<br>cout &lt;&lt; endl;<br><span class="hljs-function">Son <span class="hljs-title">you</span><span class="hljs-params">(<span class="hljs-string">&quot;SS&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">199</span>, <span class="hljs-number">200</span>, <span class="hljs-number">1</span>)</span></span>;<br>cout &lt;&lt; endl;<br>Son he;<br>cout &lt;&lt; endl;<br>he = me;<br>cout &lt;&lt; endl;<br><span class="hljs-function">Son <span class="hljs-title">she</span><span class="hljs-params">(you)</span></span>;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果</span><br><span class="hljs-comment">//调用基类的构造函数</span><br><span class="hljs-comment">//调用派生类的构造函数</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//调用基类的构造函数</span><br><span class="hljs-comment">//调用派生类的构造函数</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//调用基类的构造函数</span><br><span class="hljs-comment">//调用派生类的构造函数</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//调用基类的赋值运算符</span><br><span class="hljs-comment">//调用派生类的赋值运算符</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//调用基类的拷贝构造函数</span><br><span class="hljs-comment">//调用派生类的拷贝构造函数</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//调用派生类的析构函数</span><br><span class="hljs-comment">//调用基类的析构函数</span><br><span class="hljs-comment">//调用派生类的析构函数</span><br><span class="hljs-comment">//调用基类的析构函数</span><br><span class="hljs-comment">//调用派生类的析构函数</span><br><span class="hljs-comment">//调用基类的析构函数</span><br><span class="hljs-comment">//调用派生类的析构函数</span><br><span class="hljs-comment">//调用基类的析构函数</span><br></code></pre></td></tr></table></figure><h3 id="二基类和派生类的赋值转换"><a href="#二基类和派生类的赋值转换" class="header-anchor">¶</a>（二）基类和派生类的赋值转换：</h3><p>派生类对象可以赋值给：</p><ul class="lvl-0"><li class="lvl-2"><p>基类的对象：</p><p>因为派生类中包括基类的所有数据成员，赋值时将这部分赋值给基类即可完成赋值转换。</p></li><li class="lvl-2"><p>基类的指针：</p><p>基类指针指向派生类的首元素地址，不会发生越界，而且只能在基类的相对应的数据成员范围上操作，不能越界操作派生类数据成员。</p></li><li class="lvl-2"><p>基类的引用：</p><p>基类引用只可以操作派生类中对应的基类的数据成员，同样不能越界操作。</p></li></ul><p>这个过程也被称为切片/切割，意即把派生类中基类的部分切出赋值过去。</p><p>基类对象一般情况下不能赋值给派生类对象。但可以把基类的指针强制类型转换赋值给派生类的指针，此指针还要求指向的是派生类对象，否则可能会越界访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> aa;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i,<span class="hljs-type">double</span> d):<span class="hljs-built_in">a</span>(i),<span class="hljs-built_in">aa</span>(d)&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;aa:&quot;</span> &lt;&lt; aa &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeaa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>aa++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> bb;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">double</span> d1, <span class="hljs-type">double</span> d2) :<span class="hljs-built_in">b</span>(i1), <span class="hljs-built_in">bb</span>(d1), <span class="hljs-built_in">A</span>(i2, d2) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A::<span class="hljs-built_in">printA</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;bb:&quot;</span> &lt;&lt; bb &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changebb</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>aa--;<br>bb++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">B <span class="hljs-title">b1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>)</span></span>;<br><span class="hljs-function">B <span class="hljs-title">b2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>)</span></span>;<br>A a1 = b1;<br>A* pa1 = &amp;b1;<br>A&amp; a2 = b2;<br><br>a<span class="hljs-number">1.</span><span class="hljs-built_in">printA</span>();<br>pa1-&gt;<span class="hljs-built_in">printA</span>();<br>a<span class="hljs-number">2.</span><span class="hljs-built_in">printA</span>();<br>cout &lt;&lt; endl;<br>b<span class="hljs-number">1.</span><span class="hljs-built_in">changeaa</span>();<br>a<span class="hljs-number">1.</span><span class="hljs-built_in">printA</span>();<br>pa1-&gt;<span class="hljs-built_in">printA</span>();<br>cout &lt;&lt; endl;<br>b<span class="hljs-number">2.</span><span class="hljs-built_in">changebb</span>();<br>a<span class="hljs-number">2.</span><span class="hljs-built_in">printA</span>();<br>cout &lt;&lt; endl;<br>B *b3 = (B*)(pa1);<br>b<span class="hljs-number">1.</span><span class="hljs-built_in">printB</span>();<br>b3-&gt;<span class="hljs-built_in">printB</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//a:10</span><br><span class="hljs-comment">//aa : 2.5</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 2.5</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 2.5</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 2.5</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 3.5</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 1.5</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 3.5</span><br><span class="hljs-comment">//b : 1</span><br><span class="hljs-comment">//bb : 1.5</span><br><span class="hljs-comment">//a : 10</span><br><span class="hljs-comment">//aa : 3.5</span><br><span class="hljs-comment">//b : 1</span><br><span class="hljs-comment">//bb : 1.5</span><br></code></pre></td></tr></table></figure><h3 id="三单继承和多继承"><a href="#三单继承和多继承" class="header-anchor">¶</a>（三）单继承和多继承：</h3><h4 id="1-基本内容"><a href="#1-基本内容" class="header-anchor">¶</a>1. 基本内容</h4><p>单继承是指派生类只有一个直接基类，多继承是指一个派生类拥有两个或多个直接基类。</p><p>继承的格式详见一。</p><p>多继承完成了更多的代码复用，并使得复用的程度更深。</p><p>多继承时，派生类构造函数调用多个基类的构造函数，析构函数同理，构造顺序按照声明继承的顺序进行，析构则相反顺序。</p><p>若不同继承基类有同名成员，直接访问会造成命名冲突，此时需要在名字前加上类名和域解析符::，显式指定使用哪个类的成员，消除二义性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i):<span class="hljs-built_in">x</span>(i)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用A构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用A析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">x</span>(i)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用B构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">B</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用B析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:<span class="hljs-keyword">public</span> A, <span class="hljs-keyword">public</span> B<br>&#123;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i1,<span class="hljs-type">int</span> i2,<span class="hljs-type">int</span> i3) :<span class="hljs-built_in">B</span>(i1),<span class="hljs-built_in">A</span>(i2),<span class="hljs-built_in">x</span>(i3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printx</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A.x:&quot;</span> &lt;&lt; A::x &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;B.x:&quot;</span> &lt;&lt; B::x &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;x:&quot;</span> &lt;&lt; x &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>~<span class="hljs-built_in">C</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">C <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>c.<span class="hljs-built_in">printx</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//调用A构造函数</span><br><span class="hljs-comment">//调用B构造函数</span><br><span class="hljs-comment">//调用C构造函数</span><br><span class="hljs-comment">// A.x:2</span><br><span class="hljs-comment">//B.x:1</span><br><span class="hljs-comment">//x : 3</span><br><span class="hljs-comment">//调用C析构函数</span><br><span class="hljs-comment">//调用B析构函数</span><br><span class="hljs-comment">//调用A析构函数</span><br></code></pre></td></tr></table></figure><h4 id="2-菱形继承"><a href="#2-菱形继承" class="header-anchor">¶</a>2. 菱形继承</h4><p>多继承内存在着许多问题，例如二义性和代码冗余，下面通过菱形继承说明。</p><p>菱形继承是多继承的一种特殊情况。</p><p><img src="https://s1.ax1x.com/2023/04/04/pp4VDQs.png" alt="20_C++菱形继承"></p><p>如图，类B和类C分别继承类A，类D对类BC进行多继承，此时，创建一个D对象，会导致基类A构造两次并析构两次——派生类中产生了重复的基类数据，并且重复的构造和析构同一个基类对象，造成了代码冗余，浪费了很大的空间。</p><p>同时，因为BC都继承了A的成员，D在继承BC时会存在同名的数据成员，无法直接通过变量名读取相应的值，产生了二义性，此时需要通过域解析符::进行区分，非常麻烦。</p><p>一般情况下，不建议设计多继承和菱形继承，因为情况比较复杂。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-built_in">int</span> number;<br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-built_in">int</span> i1,<span class="hljs-built_in">int</span> i2):a(i1),number(i2)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用A构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~A()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用A析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:<span class="hljs-title">public</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> b;<br><span class="hljs-keyword">public</span>:<br>B(<span class="hljs-built_in">int</span> i1,<span class="hljs-built_in">int</span> i2,<span class="hljs-built_in">int</span> i3) :A(i1,i2),b(i3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用B构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~B()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用B析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>:<span class="hljs-title">public</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> c;<br><span class="hljs-keyword">public</span>:<br>C(<span class="hljs-built_in">int</span> i1, <span class="hljs-built_in">int</span> i2, <span class="hljs-built_in">int</span> i3) :A(i1, i2), c(i3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~C()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>:<span class="hljs-title">public</span> <span class="hljs-title">B</span>,<span class="hljs-title">public</span> <span class="hljs-title">C</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> d;<br><span class="hljs-keyword">public</span>:<br>D(<span class="hljs-built_in">int</span> i1, <span class="hljs-built_in">int</span> i2, <span class="hljs-built_in">int</span> i3,<span class="hljs-built_in">int</span> i4,<span class="hljs-built_in">int</span> i5) :B(i1,i2,i3),C(i1,i2,i4),d(i5)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printD</span>()</span> &#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(A) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(B):&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(B) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(C):&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(C) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(D):&quot;</span> &lt;&lt; <span class="hljs-keyword">sizeof</span>(D) &lt;&lt; endl; <br>cout &lt;&lt; <span class="hljs-string">&quot;d:&quot;</span> &lt;&lt; d &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-function">D <span class="hljs-title">d</span>(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span></span>)</span>;<br>d.printD();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//调用A构造函数</span><br><span class="hljs-comment">//调用B构造函数</span><br><span class="hljs-comment">//调用A构造函数</span><br><span class="hljs-comment">//调用C构造函数</span><br><span class="hljs-comment">//调用C构造函数</span><br><span class="hljs-comment">//sizeof(A) : 8</span><br><span class="hljs-comment">//sizeof(B) : 12</span><br><span class="hljs-comment">//sizeof(C) : 12</span><br><span class="hljs-comment">//sizeof(D) : 28</span><br><span class="hljs-comment">//d : 5</span><br><span class="hljs-comment">//调用C析构函数</span><br><span class="hljs-comment">//调用A析构函数</span><br><span class="hljs-comment">//调用B析构函数</span><br><span class="hljs-comment">//调用A析构函数</span><br></code></pre></td></tr></table></figure><h4 id="3-菱形继承的解决虚继承"><a href="#3-菱形继承的解决虚继承" class="header-anchor">¶</a>3. 菱形继承的解决：虚继承</h4><p>为了避免以上的情况出现，我们需要通过虚继承的方式解决问题——需要虚基类。</p><p>虚基类不是在声明基类时声明的，而是声明派生类时指定继承方式声明的。</p><p>虚继承是指在继承的基类前添加关键字virtual，格式为：</p><p><em><strong>class 派生类名: virtual 继承方式 基类名</strong></em></p><p>此时的基类被称为虚基类，也就是被虚继承的基类（不是抽象类！！）</p><p>在菱形继承中，当BC对A都进行虚继承后，D对BC进行多继承时，重复的变量将只会保留一份。这是因为，D不仅对直接基类进行初始化，也会对虚基类初始化，且只有一次——c++编译器只调用最后的派生类对基类的构造函数调用，忽略其他派生类对虚基类的构造函数调用，避免了对基类数据成员的重复初始化。</p><p>虚继承后，访问同名变量不需要使用域成员运算符，因为只有一个基类对象。</p><p>此处暂不介绍虚继承的内存模型，以后有需要单开一篇进行介绍。</p><p>以下是虚继承之后的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> i1,<span class="hljs-type">int</span> i2):<span class="hljs-built_in">a</span>(i1),<span class="hljs-built_in">number</span>(i2)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用A构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">A</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用A析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">B</span>(<span class="hljs-type">int</span> i1,<span class="hljs-type">int</span> i2,<span class="hljs-type">int</span> i3) :<span class="hljs-built_in">A</span>(i1,i2),<span class="hljs-built_in">b</span>(i3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用B构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">B</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用B析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>:<span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> A<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> c;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">A</span>(i1, i2), <span class="hljs-built_in">c</span>(i3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">C</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>:<span class="hljs-keyword">public</span> B,<span class="hljs-keyword">public</span> C<br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> d;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">D</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3,<span class="hljs-type">int</span> i4,<span class="hljs-type">int</span> i5) :<span class="hljs-built_in">A</span>(i1,i2),<span class="hljs-built_in">B</span>(i1,i2,i3),<span class="hljs-built_in">C</span>(i1,i2,i4),<span class="hljs-built_in">d</span>(i5)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用C构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printD</span><span class="hljs-params">()</span> </span>&#123; <br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(A):&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(B):&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(B) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(C):&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(C) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof(D):&quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(D) &lt;&lt; endl; <br>cout &lt;&lt; <span class="hljs-string">&quot;anumberaddress:&quot;</span> &lt;&lt; &amp;(A::number) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;bnumberaddress:&quot;</span> &lt;&lt; &amp;(B::number) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;cnumberaddress:&quot;</span> &lt;&lt; &amp;(C::number) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;dnumberaddress:&quot;</span> &lt;&lt; &amp;number &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;d:&quot;</span> &lt;&lt; d &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">D <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>;<br>d.<span class="hljs-built_in">printD</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//调用A构造函数</span><br><span class="hljs-comment">//调用B构造函数</span><br><span class="hljs-comment">//调用C构造函数</span><br><span class="hljs-comment">//调用C构造函数</span><br><span class="hljs-comment">//sizeof(A) : 8</span><br><span class="hljs-comment">//sizeof(B) : 24</span><br><span class="hljs-comment">//sizeof(C) : 24</span><br><span class="hljs-comment">//sizeof(D) : 48</span><br><span class="hljs-comment">//anumberaddress : 000000C76B8FF5C4</span><br><span class="hljs-comment">//bnumberaddress : 000000C76B8FF5C4</span><br><span class="hljs-comment">//cnumberaddress : 000000C76B8FF5C4</span><br><span class="hljs-comment">//dnumberaddress : 000000C76B8FF5C4</span><br><span class="hljs-comment">//d : 5</span><br><span class="hljs-comment">//调用C析构函数</span><br><span class="hljs-comment">//调用B析构函数</span><br><span class="hljs-comment">//调用A析构函数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——继承(一)</title>
    <link href="/xiaohei07.github.io/2023/03/31/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF(%E4%B8%80)/"/>
    <url>/xiaohei07.github.io/2023/03/31/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念：</h3><p>继承机制是面向对象程序设计中最重要的一个概念，也是使代码可以复用的最重要的手段。</p><p>继承机制允许我们依据一个类来定义另一个类，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，能使对类的创建和维护更加容易——能够重用代码功能和提高执行效率。</p><p>被继承的类，也就是已有的类，被称为基类(父类)，而发生继承的类，也就是新建的类，被称为派生类(子类)。</p><p>如果要使用基类的成员，派生类不需要重新编写新的数据成员和成员函数，只需要指定继承的已有的类的成员。但是，派生类不能继承基类的构造函数、析构函数、拷贝构造函数、重载运算符和友元函数。</p><p>一个基类可以派生出多个派生类，一个派生类也可以从多个基类中继承数据成员和成员函数。</p><p>派生类只能访问基类的非私有成员。</p><h3 id="二继承的语法形式"><a href="#二继承的语法形式" class="header-anchor">¶</a>（二）继承的语法形式：</h3><p><em><strong>class 派生类名:基类名表</strong></em></p><p><em><strong>{</strong></em></p><p><em><strong>数据成员和成员函数声明</strong></em></p><p><em><strong>};</strong></em></p><p>其中，基类和一般情况下声明的类基本相同。</p><p>基类名表的组成为：</p><p><em><strong>访问控制 基类名<sub>1</sub> , 访问控制 基类名2 , .......</strong></em></p><p>访问控制是关键字，表示派生类对基类的继承方式。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;iostream&gt;</span><br>using namespace std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">person</span></span><br><span class="hljs-class"></span>&#123;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">animal</span></span><br><span class="hljs-class"></span>&#123;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">knowledge</span></span>&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span><span class="hljs-attr"> :public</span> <span class="hljs-title">animal</span>,<span class="hljs-title">protected</span> <span class="hljs-title">person</span>,<span class="hljs-title">private</span> <span class="hljs-title">knowledge</span></span><br><span class="hljs-class"></span>&#123;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">teacher</span>:<span class="hljs-title">public</span> <span class="hljs-title">animal</span>, <span class="hljs-title">protected</span> <span class="hljs-title">person</span>, <span class="hljs-title">private</span> <span class="hljs-title">knowledge</span></span><br><span class="hljs-class"></span>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="三继承的三种方式"><a href="#三继承的三种方式" class="header-anchor">¶</a>（三）继承的三种方式：</h3><p>访问控制的关键字共有三个，分别为public、private和protected。</p><p>如果未直接指定访问控制关键字，默认为private。</p><p>访问控制决定了不同的访问权限和访问类型，详细情况见下表。</p><p><img src="https://s1.ax1x.com/2023/04/02/ppfs4QH.png" alt></p><p>可以看到，对于基类成员，派生类的继承如下：</p><p>- 基类的私有成员，派生类不可以访问</p><p>- 基类的保护成员，派生类可以继承为自己的保护成员(protected继承)和私有成员(private继承)，在派生类可以访问，在外部不可以访问。</p><p>- 基类的公有成员，子类可以继承为自己的公有成员(public继承),保护成员(protected继承)和私有成员(private继承)。在派生类可以访问，在外部也可以访问。</p><p>对于派生类，公有继承保持基类的保护成员和公有成员不变；保护继承将基类的公有和保护成员变为保护成员；私有继承则将公有和保护成员变为私有成员。</p><p><strong>注意：通过派生类可以初始化基类的私有数据成员，方式是通过调用基类的构造函数来实现对私有数据成员的初始化。</strong></p><p><strong>注意：虽然基类的私有数据成员不能在派生类中直接访问，但是派生类的对象也会为其建立私有的数据空间，所有继承时即使基类数据成员均为私有，也会导致派生类的占用空间很大。</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Axy</span> <span class="hljs-comment">//基类</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> Aname;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-built_in">double</span> x;<br><span class="hljs-built_in">double</span> y;<br><span class="hljs-keyword">public</span>:<br>Axy(<span class="hljs-built_in">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">0</span>,<span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;pointA&quot;</span> ):Aname(s),x(d1),y(d2)&#123; &#125;<br><span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">getx</span>()</span> &#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">gety</span>()</span> &#123; <span class="hljs-keyword">return</span> y; &#125;<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getAname</span>()</span> &#123; <span class="hljs-keyword">return</span> Aname; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Bxy</span> :<span class="hljs-title">public</span> <span class="hljs-title">Axy</span> <span class="hljs-comment">//公有继承A，除了不能继承Aname，其余保持不变，构造函数不继承需要重新写</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> Bname;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//对基类的一种初始化方式</span><br>Bxy(<span class="hljs-built_in">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">0</span>, <span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;pointB&quot;</span>,<span class="hljs-built_in">string</span> s2 =<span class="hljs-string">&quot;pointA&quot;</span>) :Bname(s1), Axy(d1, d2, s2) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Cxy</span>:<span class="hljs-title">protected</span> <span class="hljs-title">Axy</span> <span class="hljs-comment">//保护继承A，不能继承Aname，其他均变为protected类型，构造函数不继承需要重新写</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> Cname;<br><span class="hljs-keyword">public</span>:<br>Cxy(<span class="hljs-built_in">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">0</span>, <span class="hljs-built_in">string</span> s1 = <span class="hljs-string">&quot;pointC&quot;</span>) :Cname(s1)<br>&#123;<br><span class="hljs-comment">//继承可以直接使用基类的非私有数据成员</span><br>x = d1;<br>y = d2;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_A_function</span>()</span><br>&#123;<br><span class="hljs-comment">//继承可以使用基类的非私有成员函数</span><br>cout &lt;&lt; getx() &lt;&lt; endl;<br>cout &lt;&lt; gety() &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use_A_function2</span>()</span><br>&#123;<br>cout &lt;&lt; x &lt;&lt; endl;<br>cout &lt;&lt; y &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Dxy</span>:<span class="hljs-title">private</span> <span class="hljs-title">Cxy</span> <span class="hljs-comment">//私有继承C，不能继承Cname，其他均变为private类型，构造函数不继承需要重新写</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> Dname;<br><span class="hljs-keyword">public</span>:<br>Dxy(<span class="hljs-built_in">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">0</span>, <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;pointD&quot;</span>) :Dname(s), Cxy(d1, d2) &#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Exy</span> :<span class="hljs-title">public</span> <span class="hljs-title">Dxy</span> <span class="hljs-comment">//保护继承D，因为上面均变为private类型，所以什么都都没继承，只能对其构造和析构</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> Dname;<br><span class="hljs-keyword">public</span>:<br>Exy(<span class="hljs-built_in">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">0</span>, <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;pointD&quot;</span>) :Dname(s), Dxy(d1, d2) &#123;&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> <br>&#123;<br><span class="hljs-function">Bxy <span class="hljs-title">b</span>(<span class="hljs-params"><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;bbb&quot;</span>,<span class="hljs-string">&quot;aaa&quot;</span></span>)</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b.getx() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b.gety() &lt;&lt; endl; <span class="hljs-comment">//调用A的成员函数处理B的数据成员</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Aname:&quot;</span> &lt;&lt; b.getAname() &lt;&lt; endl;<br>Cxy c; <span class="hljs-comment">//c为保护继承，类外均不能调用原有的成员函数</span><br>c.use_A_function();  <span class="hljs-comment">//通过调用C的成员函数调用A的成员函数处理C的数据成员</span><br>c.use_A_function2(); <span class="hljs-comment">//调用C的成员函数对C的数据成员操作</span><br>Dxy d; <span class="hljs-comment">//d为私有继承，类外均不能调用原有的成员函数</span><br>Exy e; <span class="hljs-comment">//e为公有继承，但什么都没继承到，所以没有可以调用的成员函数。</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Axy) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Bxy) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Cxy) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Dxy) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>(Exy) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//b:1, 1</span><br><span class="hljs-comment">//Aname : aaa</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//0</span><br><span class="hljs-comment">//56</span><br><span class="hljs-comment">//96</span><br><span class="hljs-comment">//96</span><br><span class="hljs-comment">//136</span><br><span class="hljs-comment">//176</span><br></code></pre></td></tr></table></figure><h3 id="四重名成员"><a href="#四重名成员" class="header-anchor">¶</a>（四）重名成员：</h3><ul class="lvl-0"><li class="lvl-2"><p>同名也称为隐藏，派生类定义了与基类同名的成员时，派生类的同名成员会屏蔽掉基类的同名成员——子类优先。</p></li><li class="lvl-2"><p>如果要使用基类的同名成员，需要显式地使用类名限定符。</p></li><li class="lvl-2"><p>对于成员函数，同名的要求是函数名相同，对参数列表没有要求。</p></li><li class="lvl-2"><p>注意基类和派生类的作用域是独立的（表现为各有自己的this指针），但是基类的作用域被延伸到了派生类中（也就是在派生类的作用域中可以调用基类的作用域）。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Axy</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>string Aname;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Axy</span>(<span class="hljs-type">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> d2 = <span class="hljs-number">0</span>,string s = <span class="hljs-string">&quot;pointA&quot;</span> ):<span class="hljs-built_in">Aname</span>(s),<span class="hljs-built_in">x</span>(d1),<span class="hljs-built_in">y</span>(d2)&#123; &#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getx</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gety</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125;<br><span class="hljs-function">string <span class="hljs-title">getAname</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Aname; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bxy</span> :<span class="hljs-keyword">public</span> Axy<br>&#123;<br><span class="hljs-keyword">private</span>:<br>string Bname;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Bxy</span>(<span class="hljs-type">double</span> d1 = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> d2 = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> d3=<span class="hljs-number">0</span>,<span class="hljs-type">double</span> d4=<span class="hljs-number">0</span>,string s1 = <span class="hljs-string">&quot;pointB&quot;</span>,string s2 =<span class="hljs-string">&quot;pointA&quot;</span>):<span class="hljs-built_in">x</span>(d1),<span class="hljs-built_in">y</span>(d2),<span class="hljs-built_in">Bname</span>(s1), <span class="hljs-built_in">Axy</span>(d3, d4, s2) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getx</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> x; &#125; <span class="hljs-comment">//访问默认的子类的同名变量x</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">gety</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> y; &#125; <span class="hljs-comment">//访问默认的子类的同名变量y</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getAx</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Axy::x; &#125; <span class="hljs-comment">//访问基类的同名变量x</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getAy</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Axy::y; &#125; <span class="hljs-comment">//访问基类的同名变量y</span><br><span class="hljs-function">string <span class="hljs-title">getAname</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Axy::<span class="hljs-built_in">getAname</span>(); &#125; <span class="hljs-comment">//调用基类的成员函数getAname，这里绝对不能不加作用域，否则会陷入死循环。</span><br><span class="hljs-function">string <span class="hljs-title">getBname</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Bname; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Bxy b;<br>cout &lt;&lt; <span class="hljs-string">&quot;b:&quot;</span> &lt;&lt; b.<span class="hljs-built_in">getx</span>() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b.<span class="hljs-built_in">gety</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; b.<span class="hljs-built_in">getAx</span>() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b.<span class="hljs-built_in">getAy</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; b.Axy::<span class="hljs-built_in">getx</span>() &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; b.Axy::<span class="hljs-built_in">gety</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;bname:&quot;</span> &lt;&lt; b.<span class="hljs-built_in">getBname</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;aname:&quot;</span> &lt;&lt; b.<span class="hljs-built_in">getAname</span>() &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;aname:&quot;</span> &lt;&lt; b.Axy::<span class="hljs-built_in">getAname</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//b:0, 0</span><br><span class="hljs-comment">//a : 0, 0</span><br><span class="hljs-comment">//a : 0, 0</span><br><span class="hljs-comment">//bname : pointB</span><br><span class="hljs-comment">//aname : pointA</span><br><span class="hljs-comment">//aname : pointA</span><br></code></pre></td></tr></table></figure><h3 id="五派生类访问静态成员"><a href="#五派生类访问静态成员" class="header-anchor">¶</a>（五）派生类访问静态成员：</h3><ul class="lvl-0"><li class="lvl-2"><p>基类定义的静态成员将被所有派生类共享。</p></li><li class="lvl-2"><p>根据静态成员自身的访问特性和派生类的继承方式，类层次体系中有不同的访问性质。</p></li><li class="lvl-2"><p>派生类中访问静态成员，用以下形式显式说明：</p><ul class="lvl-2"><li class="lvl-4"><em><strong>类名::成员</strong></em></li><li class="lvl-4"><em><strong>对象名.成员</strong></em></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">add_i</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>i++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-type">int</span> A::i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">protected</span> A<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_i2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>i++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A a;<br>B b;<br>a.i++;<br>a.<span class="hljs-built_in">add_i</span>();<br>b.<span class="hljs-built_in">add_i2</span>();<br><span class="hljs-comment">//b.A::add_i(); protect继承不能在类外访问A的成员</span><br><span class="hljs-comment">//B::A::add_i(); 这样也不行</span><br>A::i++;<br>A::<span class="hljs-built_in">add_i</span>();<br>a.<span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//i:5</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——类与类之间的关系</title>
    <link href="/xiaohei07.github.io/2023/03/31/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/xiaohei07.github.io/2023/03/31/c++%E7%B1%BB%E2%80%94%E2%80%94%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一依赖"><a href="#一依赖" class="header-anchor">¶</a>（一）依赖：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>是一种使用关系，耦合度最弱。类A使用类B的一部分属性和方法，不会主动改变类B的内容，但是类B的变化会影响到A。具有偶然性、临时性。</p><h4 id="2-体现"><a href="#2-体现" class="header-anchor">¶</a>2. 体现：</h4><ul class="lvl-0"><li class="lvl-2"><p>类B作为类A的成员函数参数。</p></li><li class="lvl-2"><p>类B作为A的成员函数的局部变量</p></li><li class="lvl-2"><p>类A的成员函数调用的类B的静态方法</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="header-anchor">¶</a>3. 代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">showB</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;showB&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallB1</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>B::<span class="hljs-built_in">showB</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallB2</span><span class="hljs-params">(B b)</span> </span><br><span class="hljs-function"></span>&#123;<br>b.<span class="hljs-built_in">showB</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallB3</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>B b;<br>b.<span class="hljs-built_in">showB</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>B b;<br>A a;<br>a.<span class="hljs-built_in">CallB1</span>();<br>a.<span class="hljs-built_in">CallB2</span>(b);<br>a.<span class="hljs-built_in">CallB3</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//showB</span><br><span class="hljs-comment">//showB</span><br><span class="hljs-comment">//showB</span><br></code></pre></td></tr></table></figure><h3 id="二关联"><a href="#二关联" class="header-anchor">¶</a>（二）关联：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>关联是对象之间的一种引用关系，用于表示一类对象与另一类对象的联系。</p><p>关连也是一种弱从属关系，是可以有方向的，可以是单向也可以是双向的。</p><p>关联体现的是两个类之间的一种强依赖关系，不存在偶然性和临时性，一般是长期性的、平等的。</p><p>依赖和关联都是一个类用乐另一个类，但是前者是使用，后者是拥有。</p><h4 id="2-体现"><a href="#2-体现" class="header-anchor">¶</a>2. 体现：</h4><ul class="lvl-0"><li class="lvl-2"><p>被关联类B以类的属性形式出来在关联类A中。</p></li><li class="lvl-2"><p>关联类A引用了一个类型为被关联类B的全局变量。</p></li></ul><h4 id="3-代码"><a href="#3-代码" class="header-anchor">¶</a>3. 代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//A和B是关联关系：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Me</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">You</span><br>&#123;<br><span class="hljs-keyword">private</span>: <br>Me* pm;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMe</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printYou</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Me</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>You* py;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printme</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printyou</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">You::printMe</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;You:&quot;</span> &lt;&lt; endl;<br>pm-&gt;<span class="hljs-built_in">printme</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">You::printYou</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我中有你&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Me::printyou</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Me:&quot;</span> &lt;&lt; endl;<br>py-&gt;<span class="hljs-built_in">printYou</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Me::printme</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;你中有我&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>Me zzh;<br>zzh.<span class="hljs-built_in">printyou</span>();<br>zzh.<span class="hljs-built_in">printme</span>();<br>You xxx;<br>xxx.<span class="hljs-built_in">printMe</span>();<br>xxx.<span class="hljs-built_in">printYou</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//Me:</span><br><span class="hljs-comment">//我中有你</span><br><span class="hljs-comment">//你中有我</span><br><span class="hljs-comment">//You :</span><br><span class="hljs-comment">//你中有我</span><br><span class="hljs-comment">//我中有你</span><br></code></pre></td></tr></table></figure><h3 id="三聚合"><a href="#三聚合" class="header-anchor">¶</a>（三）聚合：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>聚合关系又名委托关系，聚合关系是关联关系的一种，是一种强关联关系，是整体和部分之间的关系，是has-a的关系。</p><p>聚合关系也是一种弱所属关系，整体和部分之间是可分离的，具有各自的生命周期，部分可以属于多个整体的对象，也可以为多个整体对象共享。</p><p>聚合和关联的区别主要是语义，关联的两个对象一般是平等的，而聚合一般不是平等的。</p><h4 id="2-体现"><a href="#2-体现" class="header-anchor">¶</a>2. 体现：</h4><p>聚合通过成员对象来实现的。</p><p>聚合需要配合语义，结合上下文才能判断出是否为聚合，无法直接判断。</p><h4 id="3-代码"><a href="#3-代码" class="header-anchor">¶</a>3. 代码：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Wife</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">House</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">public</span>:<br>House(<span class="hljs-built_in">string</span> s=<span class="hljs-string">&quot;家&quot;</span>):name(s)&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showname</span>()</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;家:&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Husband</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>House h;<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">public</span>:<br>Husband(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2=<span class="hljs-string">&quot;zzh&quot;</span>) :h(s1),name(s2) <br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showHouse</span>()</span> <br>&#123;<br>h.showname();<br>cout &lt;&lt; <span class="hljs-string">&quot;丈夫&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Wife</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>House h;<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">public</span>:<br>Wife(<span class="hljs-built_in">string</span> s1, <span class="hljs-built_in">string</span> s2 = <span class="hljs-string">&quot;xxx&quot;</span>) :h(s1), name(s2)<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showHouse</span>()</span><br>&#123;<br>h.showname();<br>cout &lt;&lt; <span class="hljs-string">&quot;妻子:&quot;</span>&lt;&lt;name &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> <br>&#123;<br><span class="hljs-function">Husband <span class="hljs-title">me</span>(<span class="hljs-params"><span class="hljs-string">&quot;home&quot;</span></span>)</span>;<br><span class="hljs-function">Wife <span class="hljs-title">who</span>(<span class="hljs-params"><span class="hljs-string">&quot;Home&quot;</span></span>)</span>;<br>me.showHouse();<br>who.showHouse();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//家:home</span><br><span class="hljs-comment">//丈夫zzh</span><br><span class="hljs-comment">//家 : Home</span><br><span class="hljs-comment">//妻子 : xxx</span><br></code></pre></td></tr></table></figure><h3 id="四组合"><a href="#四组合" class="header-anchor">¶</a>（四）组合：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>也是关联关系的一种特例，是整体和部分的关系，一个对象（是部分）被放到另一个对象中（是整体），是contains-a的关系。</p><p>是一种强所属关系（比聚合更强），和聚合不同的是，整体和部分是不可分的，具有相同的生命周期，整体（组合类）可以控制部分（被组合类）的生命周期，整体的对象不存在，则部分的对象也不存在，也就是部分对象不能独立存在。</p><p>相比聚合，组合的两个对象的不平等性进一步加大。</p><h4 id="2-体现"><a href="#2-体现" class="header-anchor">¶</a>2. 体现：</h4><p>同聚合关系，组合也是通过成员对象来实现的。</p><p>组合也需要配合语义，结合上下文才能判断出是否为聚合，无法直接判断。</p><p>聚合和组合的最关键区别是两个对象的生命周期是否一致，而不是出现的形式。</p><h4 id="3-代码"><a href="#3-代码" class="header-anchor">¶</a>3. 代码：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">eye</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">double</span> lefteyesight;<br><span class="hljs-built_in">double</span> righteyesight;<br><span class="hljs-keyword">public</span>:<br>eye(<span class="hljs-built_in">double</span> d1, <span class="hljs-built_in">double</span> d2) :lefteyesight(d1), righteyesight(d2) <br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printeyesight</span>()</span> <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;左眼:&quot;</span> &lt;&lt; lefteyesight &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;右眼:&quot;</span> &lt;&lt; righteyesight &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>eye e;<br><span class="hljs-built_in">int</span> sex;<br><span class="hljs-keyword">public</span>:<br>person(<span class="hljs-built_in">int</span> x=<span class="hljs-number">0</span>, <span class="hljs-built_in">double</span> d1 = <span class="hljs-number">1.0</span>, <span class="hljs-built_in">double</span> d2 = <span class="hljs-number">1.0</span>) :e(d1, d2), sex(x)&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printperson</span>()</span> <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;性别:&quot;</span> &lt;&lt; sex &lt;&lt; endl;<br>e.printeyesight();<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> <br>&#123;<br>person p;<br>p.printperson();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:</span><br><span class="hljs-comment">//性别:0</span><br><span class="hljs-comment">//左眼 : 1</span><br><span class="hljs-comment">//右眼 : 1</span><br></code></pre></td></tr></table></figure><h3 id="五实现"><a href="#五实现" class="header-anchor">¶</a>（五）实现：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>是接口与实现类之间的关系，在此关系中，类实现接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><h4 id="2-体现"><a href="#2-体现" class="header-anchor">¶</a>2. 体现：</h4><p>接口通过纯虚函数来实现，多态就是通过虚函数来实现的。</p><h4 id="3-代码"><a href="#3-代码" class="header-anchor">¶</a>3. 代码：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printperson</span>()</span> = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title">student</span>:<span class="hljs-title">public</span> <span class="hljs-title">person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">string</span> name;<br><span class="hljs-keyword">public</span>:<br>student(<span class="hljs-built_in">string</span> s=<span class="hljs-string">&quot;zzh&quot;</span>) :name(s) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printperson</span>()</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;这是一个人&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;是学生,名字是:&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> <br>&#123;<br>student s;<br>s.printperson();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//这是一个人</span><br><span class="hljs-comment">//是学生, 名字是:zzh</span><br></code></pre></td></tr></table></figure><h3 id="六继承"><a href="#六继承" class="header-anchor">¶</a>（六）继承：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>继承关系又名泛化关系，是面向对象的三大特征之一，是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是is-a关系。</p><p>继承表达的是一种上下级关系。</p><p>更多内容详见c++类——继承关系。</p><h4 id="2-体现"><a href="#2-体现" class="header-anchor">¶</a>2. 体现：</h4><p>通过面向对象的继承机制实现继承关系。</p><h4 id="3-代码"><a href="#3-代码" class="header-anchor">¶</a>3. 代码：</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#include&lt;iostream&gt;</span><br>using namespace std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">person</span> </span>&#123;&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span><span class="hljs-attr"> :public</span> <span class="hljs-title">person</span> </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="七不同类之间关系的强弱比较"><a href="#七不同类之间关系的强弱比较" class="header-anchor">¶</a>（七）不同类之间关系的强弱比较：</h3><p>继承=实现&gt;组合&gt;聚合&gt;关联&gt;依赖</p>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——字符编码</title>
    <link href="/xiaohei07.github.io/2023/03/29/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <url>/xiaohei07.github.io/2023/03/29/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="header-anchor">¶</a>前言：</h3><p>python 2.x默认的字符编码是ASCII，默认的文件编码也是ASCII。</p><p>python 3.x默认的字符编码是unicode，默认的文件编码是utf-8。</p><p>不同的编码之间不能互相识别，不能相互转化，会报错或出现乱码，所以一定要进行区别。</p><p>因此，本篇介绍这三种出现的编码以及额外的中文GB2312编码。</p><h3 id="一ascii编码"><a href="#一ascii编码" class="header-anchor">¶</a>（一）ASCII编码：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>ASCII编码是美国信息交换标准代码，是基于拉丁字母的一套电脑编码，主要用于显示现代英语和其他西欧语言，是最通用的信息交换标准。</p><h4 id="2-产生原因"><a href="#2-产生原因" class="header-anchor">¶</a>2. 产生原因：</h4><p>所有的数据在存储和运算时都要使用二进制表示，在字符和字符串中，对字母、数字以及一些常用符号的存储需要确定使用哪些确定的二进制数来表示对应的符号，因此，ASCII码产生了。</p><h4 id="3-ascii码内容"><a href="#3-ascii码内容" class="header-anchor">¶</a>3. ASCII码内容：</h4><p>ASCII编码使用1个字节表示常用字符，基础ASCII码字符从对应的二进制数范围从0到127（指定的7位二进制数），扩展则从128到255（指定的8位二进制数）。</p><p>基础ASCII码对应内容如下：</p><ul class="lvl-0"><li class="lvl-2"><p>0～31及127 (共33个)是控制字符或通信专用字符（其余为可显示字符）。</p><p>如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等；</p><p>通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；</p><p>ASCII值为8、9、10 和13 分别转换为退格、制表、换行和回车字符。</p></li><li class="lvl-2"><p>32                空格</p></li><li class="lvl-2"><p>33-47          <strong>! &quot; # $ % &amp; ' ( ) * + , - . /</strong></p></li><li class="lvl-2"><p>48-57          数字<strong>0-9</strong></p></li><li class="lvl-2"><p>58-64          <strong>: ; &lt; = &gt; ? @</strong></p></li><li class="lvl-2"><p>91-96          <strong>[ \ ] ^ _ `</strong></p></li><li class="lvl-2"><p>65-90          大写字母<strong>A-Z</strong></p></li><li class="lvl-2"><p>97-122        小写字母<strong>a-z</strong></p></li><li class="lvl-2"><p>123-126      <strong>{ | } ~</strong></p></li></ul><h4 id="4-python中ascii码的转换"><a href="#4-python中ascii码的转换" class="header-anchor">¶</a>4. python中ASCII码的转换：</h4><p>事实上下面的两个函数可以传入和Unicode相对应的字符，但这些内容之后讨论。</p><ul class="lvl-0"><li class="lvl-2"><p>ASCII码转字符函数chr()：</p><p>形式：<em><strong>chr(int)</strong></em></p><p>int为整数，在此处范围为0~255，可以是十进制和十六进制的形式的数字。</p><p>chr函数返回整数对应的字符。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-keyword">chr</span>(<span class="hljs-number">112</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># p</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>字符转ASCII码函数ord()：</p><p>形式：ord(char)</p><p>char为字符，在此处传入字符可以是那些ASCII码表内有对应的整数的字符，字符长度为1。</p><p>返回值为ASCII码表内对应的整数。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ord</span>(<span class="hljs-string">&quot;a&quot;</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 97</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="二gb2312编码"><a href="#二gb2312编码" class="header-anchor">¶</a>（二）GB2312编码：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>为了能够在计算机中存储汉字，中国国家标准总局发布了一系列的汉字字符集国家标准编码，这些编码统称为GB码，GB全称GuoBiao，也就是国标，所以也称为国标码。</p><p>GB2312是上述编码中最早颁布的和最有影响力的一种汉字编码格式，2312来自于1980年发布的《信息交换用汉字编码字符集 基本集》的标准号GB 2312-1980。</p><p>GB2312因其使用的普遍，也被称为国标码（狭义角度），通行于我国内地，几乎所有的中文系统和国际化软件都支持GB2312。</p><p>GB2312兼容ASCII码，不过需要进行一些转换才能完成。</p><h4 id="2-产生原因"><a href="#2-产生原因" class="header-anchor">¶</a>2. 产生原因：</h4><p>为了满足国内在计算机中使用汉字的需要。</p><h4 id="3-gb2312内容"><a href="#3-gb2312内容" class="header-anchor">¶</a>3. GB2312内容：</h4><p>共收录了6763个常用汉字（一级汉字3755个，二级汉字3008个）和682个特殊符号，特殊符号包括数字和字母，但是这些数字和字母占据的是两个字节，和ASCII码的数字和字母的区别，相当于输入法中的&quot;全角&quot;和&quot;半角&quot;，编译器只能识别&quot;半角&quot;，不能识别&quot;全角&quot;，注意区别。</p><p>GB2312编码对所收录字符进行了“分区”处理，共94个区，每区含有94个位，共8836个码位。这种表示方式也称为区位码。</p><p>01-09区收录除汉字外的682个字符。</p><p>10-15区为空白区，没有使用。</p><p>16-55区收录3755个一级汉字，按拼音排序。</p><p>56-87区收录3008个二级汉字，按部首/笔画排序。</p><p>88-94区为空白区，没有使用。</p><p>GB2312中每个字符占据2bytes，且最高位不为0（和ASCII码兼容），第一个字节为“高字节”，对应94个区，代表区号；第二个字节为“低字节”，对应94个位，代表位号。</p><p>因此，区位码范围是：0101－9494。对区号和位号分别加上0xA0就是GB2312编码。、</p><p>例如最后一个码位是9494，区号和位号分别转换成十六进制是5E5E，0x5E+0xA0＝0xFE，所以该码位的GB2312编码是FEFE。</p><p>从上面可以看出，GB2312编码范围就是A1A1－FEFE，其中汉字的编码范围为B0A1-F7FE，第一字节0xB0-0xF7（对应区号：16－87），第二个字节0xA1-0xFE（对应位号：01－94）。</p><h4 id="4-python中gb2312码的转换"><a href="#4-python中gb2312码的转换" class="header-anchor">¶</a>4. python中GB2312码的转换：</h4><p>将python字符串编码为GB2312后，类型为bytes，一般以双字节形式保存，如果是可以以一个字节字符保存的按一个字节保存。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;中国&quot;</span>.encode(<span class="hljs-string">&#x27;gb2312&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a&quot;</span>.encode(<span class="hljs-string">&#x27;gb2312&#x27;</span>))<br><span class="hljs-built_in">print</span>(type(<span class="hljs-string">&quot;中国&quot;</span>.encode(<span class="hljs-string">&#x27;gb2312&#x27;</span>)))<br><span class="hljs-built_in">print</span>(len(<span class="hljs-string">&quot;中国&quot;</span>.encode(<span class="hljs-string">&#x27;gb2312&#x27;</span>)))<br><span class="hljs-built_in">print</span>(len(<span class="hljs-string">&quot;中国&quot;</span>))<br><span class="hljs-built_in">print</span>(len(<span class="hljs-string">&quot;a&quot;</span>.encode(<span class="hljs-string">&#x27;gb2312&#x27;</span>)))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># b&#x27;\xd6\xd0\xb9\xfa&#x27;</span><br><span class="hljs-comment"># b&#x27;a&#x27;</span><br><span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure><h3 id="三unicode标准编码"><a href="#三unicode标准编码" class="header-anchor">¶</a>（三）Unicode标准编码:</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>Unicode是国际标准字符集，是计算机科学领域里的一项业界标准。是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求，Unicode是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。</p><p>注意：Unicode标准编码对应的是一个符号集，规定了每个符号的二进制值，但是没有规定符号如何存储。</p><h4 id="2-产生原因"><a href="#2-产生原因" class="header-anchor">¶</a>2. 产生原因：</h4><p>为了所有语言都统一到一套编码里，解决ASCII不能表示其他语言的问题。</p><h4 id="3-unicode标准编码内容"><a href="#3-unicode标准编码内容" class="header-anchor">¶</a>3. Unicode标准编码内容：</h4><p>Unicode字符集的标准编码范围是 <strong>0x0000 - 0x10FFFF</strong>，可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应，这里的二进制数值也叫码点。</p><p>比如：汉字&quot;中&quot;的码点是 0x4E2D, 大写字母A的码点是0x41。</p><p>但在Unicode标准编码中，A的存储为0x00000041，必须补0对齐其字节数统一为4（最大存储的字节数为4），Unicode标准编码使用32位进行补0编码的方式占据了过大的空间，浪费了存储空间，因此其不能被用于硬盘存储（文件的存储）和数据传输（网络上的传输）中。</p><p>这使得Unicode需要其他的特定编码格式，稍后我们详细介绍其中的一种编码方式：UTF-8编码。</p><p>在python中，如果想要进行硬盘存储和数据传输，需要将字符串转化为bytes类型。</p><h4 id="4-字符串前加u-r-b"><a href="#4-字符串前加u-r-b" class="header-anchor">¶</a>4. 字符串前加u、r、b：</h4><ul class="lvl-0"><li class="lvl-2"><p>字符串前加u表示以Unicode格式进行编码，一般用于中文字符串前面（一般字符串是不用加的，因为python默认用Unicode进行编码）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">u&quot;123&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">u&quot;中&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 123</span><br><span class="hljs-comment"># 中</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>字符串前面加r表示后面的字符串是普通字符串，也就是没有转义字符等其他含义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">r&quot;\n\n\n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&quot;123&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&quot;中&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># \n\n\n</span><br><span class="hljs-comment"># 123</span><br><span class="hljs-comment"># 中</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>字符串前面加b表示字符串是bytes类型，只能处理ASCII码内有的类型（其他类型需要编码解码等操作）。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">print(b<span class="hljs-string">&quot;123&quot;</span>)<br>print(b<span class="hljs-string">&quot;\n\n\n&quot;</span>)<br># print(b<span class="hljs-string">&quot;中&quot;</span>)  出错<br># # 运行结果：<br># b<span class="hljs-string">&#x27;123&#x27;</span><br># b<span class="hljs-string">&#x27;\n\n\n&#x27;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5-python中unicode标准编码的转换"><a href="#5-python中unicode标准编码的转换" class="header-anchor">¶</a>5. python中Unicode标准编码的转换：</h4><ul class="lvl-0"><li class="lvl-2"><p>Unicode编码转字符函数chr()：</p><p>形式：<em><strong>chr(int)</strong></em></p><p>int为整数，在此处范围为0~ 1114111，可以是十进制和十六进制 (最大0x10FFFF) 的形式的数字。</p><p>chr函数返回整数对应的字符。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-keyword">chr</span>(<span class="hljs-number">114514</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 𛽒 可能无法显示，但是确实是个字符</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>字符转Unicode标准编码函数ord()：</p><p>形式：ord(char)</p><p>char为字符，在此处传入字符可以是那些Unicode编码表内有对应的整数的字符，字符长度为1。</p><p>返回值为Unicode码表内对应的整数。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">print</span>(<span class="hljs-keyword">ord</span>(<span class="hljs-string">&quot;汉&quot;</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 27721</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="四utf-8编码"><a href="#四utf-8编码" class="header-anchor">¶</a>（四）UTF-8编码：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>UTF(Unicode Transformation Format)，是指Unicode转换格式。</p><p>UTF-8是Unicode特定编码的一种，是对Unicode字符串的编码具体实现和存储方法，也是在互联网上使用最广的一种 Unicode 的实现方式。</p><p>UTF-8的最大特点就是就是它是一种变长的编码方式，可以使用1~4个字节来表示一个符号，根据不同的符号变化字节长度。</p><h4 id="2-产生原因"><a href="#2-产生原因" class="header-anchor">¶</a>2. 产生原因：</h4><p>解决Unicode标准编码占用空间过大的问题，统一编码方式。</p><h4 id="3-utf-8编码内容"><a href="#3-utf-8编码内容" class="header-anchor">¶</a>3. UTF-8编码内容：</h4><p>UTF-8的编码规则很简单，只有二条：</p><ul class="lvl-0"><li class="lvl-2"><p>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的——UTF-8编码能够兼容ASCII编码，这也是互联网普遍采用UTF-8的原因之一。</p></li><li class="lvl-2"><p>对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p></li></ul><p>下表是Unicode编码码点对应UTF-8需要的字节数量以及编码格式：</p><p><img src="https://s1.ax1x.com/2023/04/07/ppThZfe.jpg" alt></p><p>第一列表示Unicode码点的位数；二三列表示码点的取值范围；第四列表示UTF-8需要的字节数；后面几列则是具体的表示，其中的1和0都是固定的前缀，而x表示可编码的二进制位，与前面的码点位数匹配。</p><p>可以看出，前面有多少个连续的1，后面就有多少位可编码的字节数，随后的一个0表示停止计量字节数，是对可编码位置和不可编码位置的分割，每个字节的10则是固定前缀。</p><p>比如下面的“汉”的Unicode和UTF-8编码对应如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(bin(ord(<span class="hljs-string">&quot;汉&quot;</span>)))<br><span class="hljs-built_in">print</span>(bin(int.from_bytes(<span class="hljs-string">&quot;汉&quot;</span>.encode())))<br># 运行结果：<br># <span class="hljs-number">0b110110001001001</span><br># <span class="hljs-number">0b111001101011000110001001</span> 注意，<span class="hljs-number">11100</span>的最后这个<span class="hljs-number">0</span>是因为上面是<span class="hljs-number">15</span>位，前面有一位空<span class="hljs-number">0</span>需要补齐<br></code></pre></td></tr></table></figure><h4 id="4-python中utf-8码的转换"><a href="#4-python中utf-8码的转换" class="header-anchor">¶</a>4. python中UTF-8码的转换：</h4><ul class="lvl-0"><li class="lvl-2"><p>encode()函数</p><p>描述：以指定的编码格式编码Unicode标准编码，也就是python的默认字符串，默认编码为 'utf-8'。</p><p>语法：<em><strong>str.encode(encoding='utf-8', errors='strict')</strong></em></p><p>str未无编码的python默认字符串，Unicode标准编码格式，否则需要先解码再编码。</p><p>encoding 参数可选，即要使用的编码，默认编码为 'utf-8'，也可以指定gb2312等编码。</p><p>errors 参数可选，设置不同错误的处理方案。默认为 'strict'，意为编码错误引起一个UnicodeEncodeError。 其它可能值有 'ignore', 'replace', 'xmlcharrefreplace'以及通过 codecs.register_error() 注册其它的值。</p><p>返回编码后的字符串，bytes类型。</p></li><li class="lvl-2"><p>decode()函数：</p><p>描述：以指定的编码格式解码字符串为Unicode标准编码格式，也就是默认字符串，默认为UTF-8编码进行解码。</p><p>语法：<em><strong>str.decode(encoding='utf-8', errors='strict')</strong></em></p><p>str为已编码的字符串，bytes类型，编码格式多种。</p><p>encoding 参数可选，即要解码的对应编码，默认为 'utf-8'，如：utf-8，gb2312等。</p><p>errors参数可选，设置不同错误的处理方案。默认为 'strict'，意为编码错误引起一个UnicodeDecodeError。其它可能得值有 'ignore', 'replace'以及通过 codecs.register_error() 注册其它的值。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">str1 = <span class="hljs-string">&quot;世界&quot;</span><br>str2 = b<span class="hljs-string">&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span><br>str3 =<span class="hljs-string">&#x27;\n&#x27;</span><br>str4 = r<span class="hljs-string">&#x27;\n&#x27;</span><br>str5 = <span class="hljs-string">&quot;\u5408&quot;</span><br><span class="hljs-built_in">print</span>(str1)<br><span class="hljs-built_in">print</span>(str1.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(type(str1.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)))<br><span class="hljs-built_in">print</span>(str2)<br><span class="hljs-built_in">print</span>(str2.decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(type(str2.decode(<span class="hljs-string">&quot;utf-8&quot;</span>)))<br><span class="hljs-built_in">print</span>(str3.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(str4.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(str5.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-built_in">print</span>(str5.encode(<span class="hljs-string">&quot;utf-8&quot;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 世界</span><br><span class="hljs-comment"># b&#x27;\xe4\xb8\x96\xe7\x95\x8c&#x27;</span><br><span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-comment"># b&#x27;\xe4\xb8\xad\xe5\x9b\xbd&#x27;</span><br><span class="hljs-comment"># 中国</span><br><span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-comment"># b&#x27;\n&#x27;</span><br><span class="hljs-comment"># b&#x27;\\n&#x27;</span><br><span class="hljs-comment"># b&#x27;\xe5\x90\x88&#x27;</span><br><span class="hljs-comment"># 合</span><br></code></pre></td></tr></table></figure><h3 id="五python字符串的unicode存储原因和优化"><a href="#五python字符串的unicode存储原因和优化" class="header-anchor">¶</a>（五）python字符串的Unicode存储原因和优化：</h3><h4 id="1-原因"><a href="#1-原因" class="header-anchor">¶</a>1. 原因：</h4><p>为什么python中依旧要使用Unicode存储而不用UTF-8编码：</p><p>UTF-8编码方案的每个字符的占用字节长度是变化的，导致了无法按索引随意访问单个字符，如果对某个字符串str[n]使用UFT-8编码去访问，需要统计前n个字符占用的字节长度，导致了运行时间从 O(1) 变成了 O(n) ，时间开销太大。</p><p>因此Python内部需要采用定长的方式存储字符串来加快各种操作的速度，所以依然使用Unicode存储。</p><h4 id="2-优化"><a href="#2-优化" class="header-anchor">¶</a>2. 优化：</h4><ul class="lvl-0"><li class="lvl-2"><p>三种内部表示Unicode字符串：</p><p>为了减少内存的消耗，三种内部表示Unicode字符串</p><ul class="lvl-2"><li class="lvl-4"><p>每个字符 1 个字节（Latin-1）</p><p>如果字符串的所有字符都在ASCII码范围内，那么就可以用占用1个字符的Latin-1编码进行存储。</p></li><li class="lvl-4"><p>每个字符 2 个字节（UCS-2）</p><p>如果字符串中存在了需要占用两个字节的字符，整个字符串全部采用占用2个字节的UCS-2编码存储。</p><p>大多数的自然语言只需要2字节编码。</p></li><li class="lvl-4"><p>每个字符 4 个字节（UCS-4）</p><p>如果加入一些极特殊的字符导致有占用4个字节的字符，就会全体采用UCS-4编码，基本和Unicode彼岸准编码一致。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import sys<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-string">&quot;a&quot;</span>))<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-string">&quot;aa&quot;</span>))<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-string">&quot;我&quot;</span>))<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-string">&quot;a我&quot;</span>))<br><span class="hljs-built_in">print</span>(sys.getsizeof(<span class="hljs-string">&quot;我我&quot;</span>))<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># 50</span><br><span class="hljs-comment"># 51  aa-a=1，a占用一个字节</span><br><span class="hljs-comment"># 76 </span><br><span class="hljs-comment"># 78  a我-我=2，a占用两个字节</span><br><span class="hljs-comment"># 78  a和我的占用相同了</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>字符串驻留机制：</p><p>将短小的字符串做成池，当程序创建字符串对象前先检查池中是否有能满足的字符串。</p><p>池中驻留的字符串一般为下划线、字母和数字不超过20的字符串。</p><p>驻留检查：</p><ul class="lvl-2"><li class="lvl-4"><p>空字符串 <code>''</code> 及所有；</p></li><li class="lvl-4"><p>变量名；</p></li><li class="lvl-4"><p>参数名；</p></li><li class="lvl-4"><p>字符串常量（代码中定义的所有字符串）；</p></li><li class="lvl-4"><p>字典键；</p></li><li class="lvl-4"><p>属性名称；</p></li></ul><p>此机制节省了大量的重复字符串内存。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(八)类型转换</title>
    <link href="/xiaohei07.github.io/2023/03/28/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AB)%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/xiaohei07.github.io/2023/03/28/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AB)%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><p>在某些情景下，我们需要对数据内置的类型进行转换，以使其能够参与某些运算/进行某些输出和分析。</p><p>数据类型的转换分为显式（自动）和隐式的类型转换，隐式的可以自动完成，显式的需要使用类型函数。</p><p>类型函数内无参数时创建的是各类型所对应的空值。</p><h3 id="二隐式类型转换"><a href="#二隐式类型转换" class="header-anchor">¶</a>（二）隐式类型转换：</h3><p>隐式类型转换主要发生在Number数字的数据类型中（因其内部有不同类型的数据），当两个不同类型的数据进行运算时，默认向更高精度转换。</p><p>数据类型的精度由低到高依次是：bool int float complex</p><p>各种类型的隐式转换如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># bool-&gt;int</span><br>a1 = 99+<span class="hljs-literal">True</span><br>b1 =<span class="hljs-literal">False</span>+10<br><span class="hljs-built_in">print</span>(a1)<br><span class="hljs-built_in">print</span>(b1)<br><span class="hljs-comment"># bool-&gt;float</span><br>a2 = 3.14+<span class="hljs-literal">False</span><br>b2 = <span class="hljs-literal">True</span>+9.9<br><span class="hljs-built_in">print</span>(a2)<br><span class="hljs-built_in">print</span>(b2)<br><span class="hljs-comment"># bool-&gt;complex</span><br>a3 = 3+4j +<span class="hljs-literal">True</span><br>b3 = <span class="hljs-literal">False</span> +5j<br><span class="hljs-built_in">print</span>(a3)<br><span class="hljs-built_in">print</span>(b3)<br><span class="hljs-comment"># int-&gt;float</span><br>aa1 = 5+3.14<br>bb1 = 10<span class="hljs-number">*8</span>.88<br><span class="hljs-built_in">print</span>(aa1)<br><span class="hljs-built_in">print</span>(bb1)<br><span class="hljs-comment"># int-&gt;complex</span><br>aa2 = 3+(4.5+2j)<br>bb2 = 1.1j+3<br><span class="hljs-built_in">print</span>(aa2)<br><span class="hljs-built_in">print</span>(bb2)<br><span class="hljs-comment"># float-&gt;complex</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">aaa </span>= 3.14159+(6.28+9.99j)<br>bbb = 4j+5.5<br><span class="hljs-built_in">print</span>(aaa)<br><span class="hljs-built_in">print</span>(bbb)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 100  int </span><br><span class="hljs-comment"># 10   int</span><br><span class="hljs-comment"># 3.14 float</span><br><span class="hljs-comment"># 10.9 float</span><br><span class="hljs-comment"># (4+4j) complex</span><br><span class="hljs-comment"># 5j   complex</span><br><span class="hljs-comment"># 8.14 float</span><br><span class="hljs-comment"># 88.80000000000001 float</span><br><span class="hljs-comment"># (7.5+2j) complex</span><br><span class="hljs-comment"># (3+1.1j) complex</span><br><span class="hljs-comment"># (9.42159+9.99j) complex</span><br><span class="hljs-comment"># (5.5+4j) complex</span><br></code></pre></td></tr></table></figure><h3 id="三显式类型转换"><a href="#三显式类型转换" class="header-anchor">¶</a>（三）显式类型转换：</h3><h4 id="1-int将其他类型转换为整型"><a href="#1-int将其他类型转换为整型" class="header-anchor">¶</a>1. int()将其他类型转换为整型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>int(x, base=10)</strong></em></p></li><li class="lvl-2"><p>允许的x范围类型：字符串、浮点数、布尔值，base是进制数，默认为十进制。</p><ul class="lvl-2"><li class="lvl-4">浮点型转换为整型，直接舍去小数部分。</li><li class="lvl-4">布尔值转换为整型，True为1，False为0。</li><li class="lvl-4">字符串转换为整型，仅有纯整型字符串可以转换（即使是浮点型也不可以）。</li></ul></li><li class="lvl-2"><p>base仅允许在x为纯数字和纯整型字符串的情况下才可以指定，否则报错。</p><p>当字符串对应的纯整型字符串为k进制时，应当将base指定为k进制的形式。</p><p>如果base指定的k进制和字符串存储的数字无法对应（比如base中k=2但字符串出现0和1以外的数字），则报错。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-number">3.14</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-literal">True</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;123456&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;101010&quot;</span>,<span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&quot;aaac&quot;</span>,<span class="hljs-number">16</span>))<br><span class="hljs-comment">#输出结果：</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 123456</span><br><span class="hljs-comment"># 42</span><br><span class="hljs-comment"># 43692</span><br></code></pre></td></tr></table></figure><h4 id="2-float将其他类型转换为浮点型"><a href="#2-float将其他类型转换为浮点型" class="header-anchor">¶</a>2. float()将其他类型转换为浮点型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>float(x)</strong></em></p></li><li class="lvl-2"><p>允许的x范围类型：字符串、布尔值和整型。</p><ul class="lvl-2"><li class="lvl-4">整型转换为浮点型，后面+.0</li><li class="lvl-4">布尔值转换为浮点型，True为1.0，False为0.0。</li><li class="lvl-4">字符串转换为浮点型，只有纯整型字符串（十进制）和纯浮点型字符串可以转换（含小数点，小数点位置任意），其他均不可以。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-literal">True</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;123456&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;3.14159&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;.123&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;321.&quot;</span>))<br><span class="hljs-comment"># 运行结果</span><br><span class="hljs-comment"># 3.0</span><br><span class="hljs-comment"># 1.0</span><br><span class="hljs-comment"># 123456.0</span><br><span class="hljs-comment"># 3.14159</span><br><span class="hljs-comment"># 0.123</span><br><span class="hljs-comment"># 321.0</span><br></code></pre></td></tr></table></figure><h4 id="3-complex将其他类型转换为复数类型"><a href="#3-complex将其他类型转换为复数类型" class="header-anchor">¶</a>3. complex()将其他类型转换为复数类型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>complex(real, imag=0)</strong></em></p></li><li class="lvl-2"><p>允许的real和imag类型：字符串、布尔值、整型和浮点型。</p><ul class="lvl-2"><li class="lvl-4">整型转换为复数类型，为 (整型数+0j)。</li><li class="lvl-4">布尔值类型转换为复数类型，True为 (1+0j)，False为 (0j)</li><li class="lvl-4">浮点型转换为复数类型，为 (浮点数+0j)</li><li class="lvl-4">事实上，前面三个可以组合输入两次作为 (输入参数1,输入参数2j)转换。</li><li class="lvl-4">字符串类型转换为复数类型，只能为一个参数传入，可以是纯整型字符串和浮点型字符串，也可以形如 i +j 形式或者 i-j 形式</li></ul></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(complex(123,2))<br><span class="hljs-built_in">print</span>(complex(<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>))<br><span class="hljs-built_in">print</span>(complex(3.14,2.22))<br><span class="hljs-built_in">print</span>(complex(1,<span class="hljs-literal">False</span>))<br><span class="hljs-built_in">print</span>(complex(99.9,2))<br><span class="hljs-built_in">print</span>(complex(<span class="hljs-string">&quot;3+4j&quot;</span>))<br><span class="hljs-built_in">print</span>(complex(<span class="hljs-string">&quot;3&quot;</span>))<br><span class="hljs-built_in">print</span>(complex(<span class="hljs-string">&quot;3.14&quot;</span>))<br><span class="hljs-comment"># 运行结果:</span><br><span class="hljs-comment"># (123+2j)</span><br><span class="hljs-comment"># (1+0j)</span><br><span class="hljs-comment"># (3.14+2.22j)</span><br><span class="hljs-comment"># (1+0j)</span><br><span class="hljs-comment"># (99.9+2j)</span><br><span class="hljs-comment"># (3-4j)</span><br><span class="hljs-comment"># (3+0j)</span><br><span class="hljs-comment"># (3.14+0j)</span><br></code></pre></td></tr></table></figure><h4 id="4-bool将其他类型转换为布尔类型"><a href="#4-bool将其他类型转换为布尔类型" class="header-anchor">¶</a>4.  bool()将其他类型转换为布尔类型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>bool(x)</strong></em></p></li><li class="lvl-2"><p>所有的数据类型都可以转换成为布尔型，结果只有True和False两种。</p></li><li class="lvl-2"><p>转换为False共十种情况，其余均为True类型：</p><ul class="lvl-2"><li class="lvl-4">整型0</li><li class="lvl-4">浮点型0.0</li><li class="lvl-4">复数0+0j</li><li class="lvl-4">布尔型False</li><li class="lvl-4">空字符串&quot;&quot;或''或&quot;''&quot;</li><li class="lvl-4">空列表[]</li><li class="lvl-4">空元组()</li><li class="lvl-4">空字典{}</li><li class="lvl-4">空集合set()</li><li class="lvl-4">python关键字None</li></ul></li></ul><p>不再一一列举（有兴趣的自己去试试）。</p><h4 id="5-str将其他类型转换为字符串类型"><a href="#5-str将其他类型转换为字符串类型" class="header-anchor">¶</a>5. str()将其他类型转换为字符串类型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>str(x)</strong></em></p></li><li class="lvl-2"><p>所有类型均可以转换为字符串类型，表示方式只是在最外面增加&quot;&quot;。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;\n&#x27;</span>,<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">3</span>+<span class="hljs-number">4j</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(<span class="hljs-literal">True</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(<span class="hljs-number">.15926</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>((<span class="hljs-string">&quot;i&quot;</span>,<span class="hljs-string">&quot;j&quot;</span>,<span class="hljs-string">&quot;k&quot;</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-string">&quot;\t\t\t&quot;</span>&#125;))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>(&#123;<span class="hljs-number">1</span>:<span class="hljs-literal">True</span>,<span class="hljs-number">2</span>:<span class="hljs-literal">False</span>,<span class="hljs-number">3</span>:<span class="hljs-number">8</span>+<span class="hljs-number">1j</span>,<span class="hljs-number">4</span>:[],<span class="hljs-number">5</span>:&#123;&#125;&#125;))<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 2, 3, 4, &#x27;\n&#x27;, &#x27;aaa&#x27;, (3+4j)]</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># 0.15926</span><br><span class="hljs-comment"># (&#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;)</span><br><span class="hljs-comment"># &#123;1, &#x27;\t\t\t&#x27;&#125;</span><br><span class="hljs-comment"># &#123;1: True, 2: False, 3: (8+1j), 4: [], 5: &#123;&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="6-list将其他类型转换为列表类型"><a href="#6-list将其他类型转换为列表类型" class="header-anchor">¶</a>6. list()将其他类型转换为列表类型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>list(x)</strong></em></p></li><li class="lvl-2"><p>允许的x范围类型：字符串，元组，字典，集合。</p><ul class="lvl-2"><li class="lvl-4">字符串转换为列表，每个字符作为一个元素组成列表。</li><li class="lvl-4">字典转换为列表，只将每个键作为一个元素组成列表，值被丢弃。</li><li class="lvl-4">元组和集合只是在原有数据的基础上加[]</li></ul></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;abcdefg1234\n\n\n&quot;</span>))<br><span class="hljs-selector-tag">print</span>(<span class="hljs-built_in">list</span>(&#123;<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>,<span class="hljs-number">3</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;b&quot;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;))<br><span class="hljs-selector-tag">print</span>(<span class="hljs-built_in">list</span>((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,[<span class="hljs-string">&quot;jkl&quot;</span>])))<br><span class="hljs-selector-tag">print</span>(<span class="hljs-built_in">list</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;))<br># 运行结果：<br># <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>]</span><br># <span class="hljs-selector-attr">[1, 2, 3, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]</span><br># <span class="hljs-selector-attr">[1, 2, 3, 4, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, [<span class="hljs-string">&#x27;jkl&#x27;</span>]</span>] <br># <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;c&#x27;</span>, 1, 2, 3, (1, 2, 3), <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]</span> #集合转列表时元素顺序无序<br></code></pre></td></tr></table></figure><h4 id="7-tuple将其他类型转换为元组类型"><a href="#7-tuple将其他类型转换为元组类型" class="header-anchor">¶</a>7. tuple()将其他类型转换为元组类型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>tuple(x)</strong></em></p></li><li class="lvl-2"><p>允许的x范围类型：字符串，列表，字典，集合。</p></li><li class="lvl-2"><p>规则和list一致，只是外面加()</p></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit">print(tuple(<span class="hljs-string">&quot;abcdefg1234\n\n\n&quot;</span>))<br>print(tuple(&#123;<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>,<span class="hljs-number">3</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&quot;b&quot;</span>:[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]&#125;))<br>print(tuple([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,[<span class="hljs-string">&quot;jkl&quot;</span>]]))<br>print(tuple(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;))<br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>)</span><br><span class="hljs-meta"># (1, 2, 3, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>)</span><br><span class="hljs-meta"># (1, 2, 3, 4, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, [<span class="hljs-string">&#x27;jkl&#x27;</span>])</span><br><span class="hljs-meta"># (1, 2, 3, <span class="hljs-string">&#x27;b&#x27;</span>, (1, 2, 3), <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h4 id="8-set将其他类型转换为集合类型"><a href="#8-set将其他类型转换为集合类型" class="header-anchor">¶</a>8. set()将其他类型转换为集合类型：</h4><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>set(x)</strong></em></p></li><li class="lvl-2"><p>允许的x范围类型：字符串，列表，字典，元组。</p></li><li class="lvl-2"><p>规则和list一致，只是外面加{}，不过元素顺序是无序的。</p><p>注意：pycharm中直接强制转化set会警告，因为直接用{}强制转化就可以代替，为了演示效果，下面进行了两次强制转化：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">print</span>(<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;abcdefg1234\n\n\n&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">set</span>(dict(&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>, <span class="hljs-number">2</span>: <span class="hljs-number">2</span>, <span class="hljs-number">3</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&quot;b&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;)))<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">set</span>(list([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>])))<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">set</span>(tuple((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)))))<br>#运行结果：<br># &#123;<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>&#125;<br># &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>&#125;<br># &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;jkl&#x27;</span>&#125;<br># &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="9-dict将其他类型转换为字典类型"><a href="#9-dict将其他类型转换为字典类型" class="header-anchor">¶</a>9. dict()将其他类型转换为字典类型：</h4><p>在说明dict的类型转换前，需要说明容器和多级容器的概念：</p><h5 id="容器"><a href="#容器" class="header-anchor">¶</a>容器：</h5><p>Python中，可包含其他对象的对象，称之为“容器”。容器是一种数据结构。</p><p>常用的容器主要划分为两种：序列（如：列表、元祖等）和映射（如：字典）。序列中，每个元素都有下标，它们是有序的。映射中，每个元素都有名称（又称“ 键 ”），它们是无序的。</p><p>除了序列和映射之外，还有一种需要注意的容器——“ 集合 ”。</p><h5 id="多级容器"><a href="#多级容器" class="header-anchor">¶</a>多级容器：</h5><p>在一个容器中嵌套一个容器，这个容器就叫二级容器；在被嵌套的容器中可以再嵌套容器，最外层的容器就叫做多级容器......由此可以获得多级容器。</p><p>多级容器不包括字符串，字符串是特殊的容器，任何字符在字符串中都是字符串的一个单独元素；</p><p>容器的类型取决于最外层的容器，不同的类型容器可以相互嵌套，但是，集合和字典除外；因为字典的键和集合中的值必须是可哈希的类型，即可变数据类型。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">l</span> =<span class="hljs-meta"> [1,2,[3,4,[5,6]]]</span><br><span class="hljs-attribute">d</span> = &#123;<span class="hljs-number">0</span>:&#123;<span class="hljs-number">1</span>:<span class="hljs-number">1</span>,<span class="hljs-number">2</span>:<span class="hljs-number">2</span>,<span class="hljs-number">3</span>:&#123;<span class="hljs-number">4</span>:<span class="hljs-number">4</span>,<span class="hljs-number">5</span>:<span class="hljs-number">5</span>,<span class="hljs-number">6</span>:<span class="hljs-number">6</span>&#125;&#125;&#125;<br><span class="hljs-attribute">t</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;)<br><span class="hljs-attribute">print</span>(type(l))<br><span class="hljs-attribute">print</span>(type(d))<br><span class="hljs-attribute">print</span>(type(t))<br><span class="hljs-comment">#运行结果：</span><br><span class="hljs-comment"># &lt;class &#x27;list&#x27;&gt;</span><br><span class="hljs-comment"># &lt;class &#x27;dict&#x27;&gt;</span><br><span class="hljs-comment"># &lt;class &#x27;tuple&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h5 id="等长的多级容器"><a href="#等长的多级容器" class="header-anchor">¶</a>等长的多级容器：</h5><p>外层容器中的元素都是容器。</p><p>被嵌套容器中的元素个数是一样的。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">l</span>=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]] #等长的二级容器<br></code></pre></td></tr></table></figure><h5 id="字典的强制转换"><a href="#字典的强制转换" class="header-anchor">¶</a>字典的强制转换：</h5><ul class="lvl-0"><li class="lvl-2"><p>形式：<em><strong>dict(x)</strong></em></p></li><li class="lvl-2"><p>允许的x范围类型：等长的二级容器，且内部元素个数必须为两个。</p></li><li class="lvl-2"><p>转换类型上，不能在最外层使用字符串。</p></li><li class="lvl-2"><p>转换类型的元素建议使用列表和元组，尽量不要用集合和字符串（集合难以形成键值对的对应关系，两者可能互换，而字符串只允许长度为2）</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">print</span>(dict([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>),&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;,<span class="hljs-string">&quot;78&quot;</span>]))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;1: 2, 3: 4, 5: 6, &#x27;7&#x27;: &#x27;8&#x27;&#125;  不建议使用集合，但是此处顺序是固定的，字符串如果是两位可以用。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(七)字典</title>
    <link href="/xiaohei07.github.io/2023/03/25/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%83)%E5%AD%97%E5%85%B8/"/>
    <url>/xiaohei07.github.io/2023/03/25/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%83)%E5%AD%97%E5%85%B8/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><p>字典（dictionary）是python语言中唯一的标准映射类型，是python中除了列表以外最灵活的数据类型。</p><p>字典是一种无序的、可变的序列，元素以&quot;键值对&quot;的形式进行存储，是可变的容器，容量是无限的。</p><p>字典的键值是hashable值，即所有不可变类型的值（基于对象标识而非值进行比较的对象），可变类型不能用作键，且键值一定是唯一的，不能出现多次，否则只会保留最后出现的一个键值对。</p><p>注意：数字类型用作键时遵循数字比较的一般原则：即两个近似数值相等的值会被用来作为一个键值索引同一条字典条目。（因此不建议把浮点数作为字典的键）</p><p>字典的值可以是任何数据类型，并无太多要求。（可以是标准的对象，也可以是用户定义的类型对象）</p><p>同一字典的不同键值对的键和值的类型均可以不同。（不过一般都是放同类型的数据）</p><h3 id="二创建与形式"><a href="#二创建与形式" class="header-anchor">¶</a>（二）创建与形式：</h3><p>python中用{}来主要表示字典，但对元素格式有要求，否则会被认为是集合。（但空的{}表示的是空字典）</p><p>形式为：<em><strong>字典名= {键1:值1 , 键2:值2 , 键三:值3 , ....... , 键n:值n }</strong></em></p><p>键对应key，值对应value，keyk : valuek表示第k个键值对，作为一个元素item存在。</p><p>&quot; : &quot;用于分割键对和值对，&quot; , &quot;用于分割元素，均放在{}中。</p><p>除了通过赋值的形式用{}直接创建字典外，还可以dict.fromkeys方法创建字典。（dict是python内置的字典类型关键字）</p><p>形式为：<em><strong>dictname = dict.fromkeys(list，value=None)</strong></em></p><p>dictname是方法的返回值所付赋给的变量名。</p><p>list参数是要创建的字典中所有的键组成的列表。</p><p>value参数是要创建的字典的元素的值的默认值，所有元素的值均为此默认值，不写时默认为空值None。</p><p>其他创建主要是通过关键字dict来进行创建：</p><ol><li class="lvl-3"><p><em><strong>dictname=dict()</strong></em>：也是空字典</p></li><li class="lvl-3"><p><em><strong>dictname=dict(key1=value1 , key2=value2 , ...... , keyn= valuen)</strong></em>，通过dict和其参数创建字典，会将=换为:，另外，key1作为字符串时在此处不能加&quot;&quot;或者''。</p></li><li class="lvl-3"><p><em><strong>dictname=dict(listname)</strong></em>，通过列表创建字典，但要求列表的元素是有两个元素的元组。</p></li><li class="lvl-3"><p><em><strong>dictname=dict(zip(listname1,listname2))</strong></em>，通过关键字dict和zip创建字典，参数是两个列表，第一个列表内的元素是键，第二个列表内的元素是值，生成的字典元素个数为两个列表中较短的一个。</p></li></ol><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autoit">a1 = &#123;&#125;<br>a3 = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>&#125;<br>a4 = dict.fromkeys([<span class="hljs-string">&#x27;aa&#x27;</span>,<span class="hljs-string">&#x27;bb&#x27;</span>,<span class="hljs-string">&#x27;cc&#x27;</span>,<span class="hljs-string">&#x27;dd&#x27;</span>])<br>a5 = dict.fromkeys([<span class="hljs-string">&#x27;aa&#x27;</span>,<span class="hljs-string">&#x27;bb&#x27;</span>,<span class="hljs-string">&#x27;cc&#x27;</span>,<span class="hljs-string">&#x27;dd&#x27;</span>],<span class="hljs-string">&quot;okok&quot;</span>)<br>a2 = dict()<br>a6 = dict(a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>,c=<span class="hljs-number">3</span>)<br>a7 = dict([(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>),(<span class="hljs-string">&quot;d&quot;</span>,<span class="hljs-number">4</span>)])<br>a8 = dict(zip([<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]))<br>print(a1,a2,a3,a4,a5,a6,a7,a8,sep=<span class="hljs-string">&#x27;\n&#x27;</span>)<br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># &#123;&#125;</span><br><span class="hljs-meta"># &#123;&#125;</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 2, <span class="hljs-string">&#x27;c&#x27;</span>: 3&#125;</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;aa&#x27;</span>: None, <span class="hljs-string">&#x27;bb&#x27;</span>: None, <span class="hljs-string">&#x27;cc&#x27;</span>: None, <span class="hljs-string">&#x27;dd&#x27;</span>: None&#125;</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;aa&#x27;</span>: <span class="hljs-string">&#x27;okok&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>: <span class="hljs-string">&#x27;okok&#x27;</span>, <span class="hljs-string">&#x27;cc&#x27;</span>: <span class="hljs-string">&#x27;okok&#x27;</span>, <span class="hljs-string">&#x27;dd&#x27;</span>: <span class="hljs-string">&#x27;okok&#x27;</span>&#125;</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 2, <span class="hljs-string">&#x27;c&#x27;</span>: 3&#125;</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 2, <span class="hljs-string">&#x27;c&#x27;</span>: 3, <span class="hljs-string">&#x27;d&#x27;</span>: 4&#125;</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 2, <span class="hljs-string">&#x27;c&#x27;</span>: 3, <span class="hljs-string">&#x27;d&#x27;</span>: 4&#125;</span><br></code></pre></td></tr></table></figure><h3 id="三字典的特性"><a href="#三字典的特性" class="header-anchor">¶</a>（三）字典的特性：</h3><h4 id="1-访问"><a href="#1-访问" class="header-anchor">¶</a>1. 访问：</h4><ul class="lvl-0"><li class="lvl-2"><p>通过键(key)访问值(value)：</p><p>形式：<em><strong>dictname[key]</strong></em></p><p>键是必须存在的，否则会抛出异常。</p></li><li class="lvl-2"><p>通过get方法访问指定键(key)对应的值：</p><p>形式：<em><strong>dictname.get(key,default)</strong></em></p><p>key参数是指定的键，不存在时不会抛出异常。</p><p>default参数是指查询的键不存在时，返回的默认值，不手动指定会返回None。</p></li><li class="lvl-2"><p>通过setdefault方法访问指定键(key)对应的值：</p><p>形式：<em><strong>dictname.setdefault(key,default)</strong></em></p><p>和get形式功能类似，但是唯一的区别是如果键不存在于字典中，会添加该键并将值设置为default。</p></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:1,<span class="hljs-string">&#x27;b&#x27;</span>:2,<span class="hljs-string">&#x27;c&#x27;</span>:3,<span class="hljs-string">&#x27;d&#x27;</span>:4,<span class="hljs-string">&#x27;e&#x27;</span>:5&#125;<br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;a&#x27;</span>])<br><span class="hljs-comment"># print(a[&#x27;f&#x27;]) 此句会执行失败</span><br><span class="hljs-built_in">print</span>(a.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&quot;不存在&quot;</span>))<br><span class="hljs-built_in">print</span>(a.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&quot;不存在&quot;</span>))<br><span class="hljs-built_in">print</span>(a.setdefault(<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&quot;不存在&quot;</span>))<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(a.setdefault(<span class="hljs-string">&#x27;f&#x27;</span>,<span class="hljs-string">&quot;不存在&quot;</span>))<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 不存在</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;e&#x27;: 5&#125;</span><br><span class="hljs-comment"># 不存在</span><br><span class="hljs-comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;e&#x27;: 5, &#x27;f&#x27;: &#x27;不存在&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-删除"><a href="#2-删除" class="header-anchor">¶</a>2. 删除：</h4><p>python自带垃圾回收机制，已创建的字典如不再使用，将会被编译器自动回收，不会产生内存垃圾。</p><p>如果需要可以手动删除，使用del 关键字手动删除字典。</p><p>形式为： <em><strong>del dictname</strong></em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">a</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span> #此句无法输出，因为a已经被删除了，a变量处于未定义状态<br></code></pre></td></tr></table></figure><h4 id="3-多维字典"><a href="#3-多维字典" class="header-anchor">¶</a>3. 多维字典：</h4><p>python中允许创建多维字典，将其他字典当做字典的元素放在一个列表当中，也就是字典的嵌套。</p><p>要注意的是，在手动创建时，如果直接使用类似 dictionary['a']['b']['c']=1的格式时，必须保证已经在键值a中创建了键值b，这样才能进行键值对的赋予——也就是多维的键值对创建时必须保证前面的键已经存在。</p><p>可以通过函数化简创建形式（此处略），否则只能一步步创建。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">a = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>a[<span class="hljs-string">&#x27;f&#x27;</span>]=<span class="hljs-number">6</span>  <span class="hljs-meta">#正确</span><br><span class="hljs-meta"># a[<span class="hljs-string">&#x27;a&#x27;</span>][<span class="hljs-string">&#x27;b&#x27;</span>]=1 错误，不能直接创建</span><br>a[<span class="hljs-string">&#x27;a&#x27;</span>]=&#123;<span class="hljs-string">&#x27;bb&#x27;</span>:<span class="hljs-number">1</span>&#125;<br>a.update(&#123;<span class="hljs-string">&#x27;b&#x27;</span>:&#123;<span class="hljs-string">&#x27;cc&#x27;</span>:<span class="hljs-number">7</span>&#125;&#125;) <span class="hljs-meta">#需要这样创建</span><br>print(a)<br><span class="hljs-meta"># 运行结果：</span><br><span class="hljs-meta"># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: &#123;<span class="hljs-string">&#x27;bb&#x27;</span>: 1&#125;, <span class="hljs-string">&#x27;b&#x27;</span>: &#123;<span class="hljs-string">&#x27;cc&#x27;</span>: 7&#125;, <span class="hljs-string">&#x27;c&#x27;</span>: 3, <span class="hljs-string">&#x27;d&#x27;</span>: 4, <span class="hljs-string">&#x27;e&#x27;</span>: 5, <span class="hljs-string">&#x27;f&#x27;</span>: 6&#125;</span><br></code></pre></td></tr></table></figure><h4 id="4-字典的主要操作"><a href="#4-字典的主要操作" class="header-anchor">¶</a>4. 字典的主要操作：</h4><ul class="lvl-0"><li class="lvl-2"><p>添加和查询键值对：</p><p>python中是不能修改字典的键的名字的，只能够修改值。添加只能添加和之前的键均不同的键。</p><ol><li class="lvl-5"><p>直接给key赋值即可，如果不存在键值python会自动生成新的键值对，如果有相同的键则将其值覆盖原有的值。</p><p>形式：<em><strong>dictname[key] = value</strong></em></p></li><li class="lvl-5"><p>使用update方法：</p><p>形式：<em><strong>dictname1.update(dictname2)</strong></em></p><p>可以将dictname2的键值对更新到dictname1，如果被更新的字典已经包含对应的键值对（实际上就是相同的键），那么原有的键值对会被覆盖，如果不包含则添加该键值对。</p></li></ol><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sas">a = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:1,<span class="hljs-string">&#x27;b&#x27;</span>:2,<span class="hljs-string">&#x27;c&#x27;</span>:3,<span class="hljs-string">&#x27;d&#x27;</span>:4,<span class="hljs-string">&#x27;e&#x27;</span>:5&#125;<br>a[<span class="hljs-string">&#x27;c&#x27;</span>]=33<br>a[<span class="hljs-string">&#x27;f&#x27;</span>]=6<br>a.up<span class="hljs-meta">date</span>(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:111&#125;)<br>a.up<span class="hljs-meta">date</span>(&#123;<span class="hljs-string">&#x27;g&#x27;</span>:7&#125;)<br>pr<span class="hljs-meta">int</span>(a)<br># 运行结果：<br># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: 111, <span class="hljs-string">&#x27;b&#x27;</span>: 2, <span class="hljs-string">&#x27;c&#x27;</span>: 33, <span class="hljs-string">&#x27;d&#x27;</span>: 4, <span class="hljs-string">&#x27;e&#x27;</span>: 5, <span class="hljs-string">&#x27;f&#x27;</span>: 6, <span class="hljs-string">&#x27;g&#x27;</span>: 7&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>删除键值对：</p><ol><li class="lvl-5"><p>用del语句删除：</p><p>形式：<em><strong>del dictname[key]</strong></em></p><p>将key对应的键值对删除，不能删除不存在的键，否则会报错。</p></li><li class="lvl-5"><p>用popitem方法删除：</p><p>形式：<em><strong>dictname.popitem()</strong></em></p><p>返回并删除字典中最后一组的键值对（也就是你输出或者定义的最后一个），返回类型为元组。</p></li><li class="lvl-5"><p>用pop方法删除：</p><p>形式：<em><strong>dictname.pop(key)</strong></em></p><p>删除指定键对应的键值对并返回值，返回类型根据值决定，不能删除不存在的键，否则会报错。</p></li><li class="lvl-5"><p>用clear删除全部删除：</p><p>形式：<em><strong>dictname.clear()</strong></em></p><p>清除全部元素成为空字典。</p></li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:1,<span class="hljs-string">&#x27;b&#x27;</span>:2,<span class="hljs-string">&#x27;c&#x27;</span>:3,<span class="hljs-string">&#x27;d&#x27;</span>:4,<span class="hljs-string">&#x27;e&#x27;</span>:5&#125;<br>b = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:1,<span class="hljs-string">&#x27;b&#x27;</span>:2,<span class="hljs-string">&#x27;c&#x27;</span>:3,<span class="hljs-string">&#x27;d&#x27;</span>:4,<span class="hljs-string">&#x27;e&#x27;</span>:5&#125;<br>c = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:1,<span class="hljs-string">&#x27;b&#x27;</span>:2,<span class="hljs-string">&#x27;c&#x27;</span>:3,<span class="hljs-string">&#x27;d&#x27;</span>:4,<span class="hljs-string">&#x27;e&#x27;</span>:5&#125;<br>a.clear()<br>x = b.popitem()<br>del c[<span class="hljs-string">&#x27;b&#x27;</span>]<br>y = c.pop(<span class="hljs-string">&#x27;a&#x27;</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;&#125;</span><br><span class="hljs-comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span><br><span class="hljs-comment"># &#123;&#x27;c&#x27;: 3, &#x27;d&#x27;: 4, &#x27;e&#x27;: 5&#125;</span><br><span class="hljs-comment"># (&#x27;e&#x27;, 5)</span><br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>查询键值对：</p><ol><li class="lvl-5"><p>判断某个键值对是否存在：</p><p>使用 in 和 not in来查询是否包括指定键对应的键值对（也就是基于key来判断）。</p><p>形式略（见代码）。</p><p>如果是python2.x版本也可以使用has_key方法：</p><p>形式：<em><strong>dictname.has_key(key)</strong></em></p><p>若有这个键返会True，否则返回False。（我是3.x，不做演示了）</p></li><li class="lvl-5"><p>查询全部键值对：</p><p>使用方法items()</p><p>形式：<em><strong>dictname.items()</strong></em></p><p>返回全部的键值对，以列表形式返回，每个元素均为元组的键,值对元组。</p></li><li class="lvl-5"><p>查询全部键：</p><p>使用方法keys()</p><p>形式：<em><strong>dictname.keys()</strong></em></p><p>返回全部的键，以列表形式。</p></li><li class="lvl-5"><p>查询全部值：</p><p>使用方法values()</p><p>形式：<em><strong>dictname.values()</strong></em></p><p>返回全部的值，以列表类型。</p></li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">a = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>,<span class="hljs-number">6</span>:<span class="hljs-string">&#x27;f&#x27;</span>&#125;<br>print(<span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">in</span> a)<br>print(<span class="hljs-string">&#x27;c&#x27;</span> not <span class="hljs-keyword">in</span> a)<br>print(a.items())<br>print(a.keys())<br>print(a.values())<br># 运行结果:<br># <span class="hljs-literal">True</span><br># <span class="hljs-literal">False</span><br># dict_items([(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">4</span>), (<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;f&#x27;</span>)])<br># dict_keys([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">6</span>])<br># dict_values([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;f&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-字典的其他操作"><a href="#5-字典的其他操作" class="header-anchor">¶</a>5. 字典的其他操作：</h4><p>比较经典的内容，如len()求长度，max()求最大值，min()求最小值，sorted排序等等，前面已经讲解过，不再重复，但是要注意：所有的操作是对键的操作，比如排序排的是键，不考虑值。</p><p>字典同样设计浅拷贝和深拷贝，区别和方法和列表类似，也不再重复。</p><p>此处唯一要讲的是字典的生成式：</p><p>格式：<em><strong>dictname1 = { x:y for x,y in dictname2.items() }</strong></em></p><p>x对应键，y对应值，遍历时获得两者组合成一个元素。</p><p>只对x遍历是键遍历，y是值遍历。</p><p>也可以对keys和values分别遍历得到键和值。</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gml">a = &#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;b&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;c&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;d&#x27;</span>:<span class="hljs-number">4</span>,<span class="hljs-string">&#x27;e&#x27;</span>:<span class="hljs-number">5</span>&#125;<br>b = &#123;<span class="hljs-variable language_">x</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span> in a.items()&#125;<br>bb = &#123;<span class="hljs-variable language_">x</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span> in a.keys()&#125;<br>c = &#123;<span class="hljs-variable language_">x</span>:<span class="hljs-variable language_">y</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span> in a.items()&#125;<br>d = &#123;<span class="hljs-variable language_">y</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">x</span>,<span class="hljs-variable language_">y</span> in a.items()&#125;<br>dd = &#123;<span class="hljs-variable language_">y</span> <span class="hljs-keyword">for</span> <span class="hljs-variable language_">y</span> in a.values()&#125;<br>print(b)<br>print(bb)<br>print(c)<br>print(d)<br>print(dd)<br># 运行结果：<br># &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br># &#123;<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;<br># &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;e&#x27;</span>: <span class="hljs-number">5</span>&#125;<br># &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br># &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——运算符重载(三)</title>
    <link href="/xiaohei07.github.io/2023/03/24/c++%E7%B1%BB%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD(%E4%B8%89)/"/>
    <url>/xiaohei07.github.io/2023/03/24/c++%E7%B1%BB%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD(%E4%B8%89)/</url>
    
    <content type="html"><![CDATA[<h3 id="类的类型转换"><a href="#类的类型转换" class="header-anchor">¶</a>类的类型转换：</h3><h4 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述</h4><p>数据类型转换在程序编译或者运行时实现，当使用基本类型的时候，如int和double之间可以直接进行灵活的类型转换，如果我们需要把一个类对象转换为其他类型类的对象或者基本类型呢？</p><p>类对象的类型转换可由两种方式实现：构造函数和转换函数（即类型转换运算符重载函数）。</p><p>前者是把其他类型转换为该类对象类型，后者是把该类对象类型转换为其他类型。</p><p>本文只考虑后者（前者已经在其他文章说明过）。</p><h4 id="二重载类型转换运算符"><a href="#二重载类型转换运算符" class="header-anchor">¶</a>（二）重载类型转换运算符</h4><ul class="lvl-0"><li class="lvl-2"><p>类型转换运算符函数是一种特殊的成员函数（不可以是友元函数），提供类对象之间或者类对象到基本类型显示类型转换的机制。</p></li><li class="lvl-2"><p>语法形式为： <em><strong>类名::operator type() { 函数体 }</strong></em></p><p>type一般为用户定义的其他类类型或者内置的数据类型（可以是typedef定义的别名），不允许是void，一般也不允许是数组或者函数类型，但可以是指针或者引用类型。</p><p>该函数无参数和返回类型，但是需要return语句，返回type类型的对象/数据。</p></li><li class="lvl-2"><p>功能：将该类对象转换为type类型的对象/数据。</p></li><li class="lvl-2"><p>一般情况下会用const修饰，因为其通常不会改变待转换对象的状态。、</p></li></ul><h4 id="三重载类型转换运算符的二义性和explicit"><a href="#三重载类型转换运算符的二义性和explicit" class="header-anchor">¶</a>（三）重载类型转换运算符的二义性和explicit</h4><ul class="lvl-0"><li class="lvl-2"><p>类型转换运算符可能产生意外结果：</p><p>对于类向bool的类型转换，有一个需要注意的问题。</p><p>我们以istream类对象cin为例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int a<span class="hljs-operator">=</span><span class="hljs-number">10</span><span class="hljs-comment">;</span><br>cin&lt;&lt;a<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>虽然istream未定义&lt;&lt;，代码应当产生错误，但是实际上此处istream的bool类型转换运算符将cin转换成了bool，而这个bool值再经过第二次类型转换提升为int作为了内置的左移运算符的左侧运算对象，这样会使得这个bool值（1或0）被左移了10个位置，虽然没有报错，但是结果与我们的预期完全不同。</p><p>解决方法：</p><p>IO类型中定义了向void*的转换规则来避免该问题。</p><p>新c++11标准中，IO标准库定义了一个向bool的显示类型转换来避免问题。</p><p>综上，在我们定义时，通常需要对operator bool用explicit关键字声明为显式的类型转换，避免隐式的。</p></li><li class="lvl-2"><p>explicit关键字：在类型转换运算符上声明，每次的类型转换需要显式的强制类型转换，可以避免隐式类型转换。</p><p>但是，如果表达式被用作条件，编译器会将显式的类型转换自动应用于它，即在以下场景时发生显式的类型转换被隐式地执行：</p><ol><li class="lvl-5"><p>if、while及do语句的条件部分。</p></li><li class="lvl-5"><p>for语句头的条件表达式。</p></li><li class="lvl-5"><p>作为逻辑非(!)/或(||)/与(&amp;&amp;)的运算对象。</p></li><li class="lvl-5"><p>条件运算符（?:）的条件表达式。</p></li></ol></li><li class="lvl-2"><p>类型转换运算符的二义性：</p><p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换来避免二义性转换。</p><p>以下是二义性情况：</p><ol><li class="lvl-5"><p>两个类提供了相同的类型转换。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs perl">//相同的类型转换：<br>//main外:<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class"></span>&#123;<br>public:<br>A() = default;<br>A(const B&amp;)&#123;&#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class"></span>&#123;<br>public:<br>operator A()const &#123; A temp; <span class="hljs-keyword">return</span> temp; &#125;<br>&#125;;<br>A f(const A&amp; a) <br>&#123;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br>//main内：<br>A a;<br>B b;<br>a = f(b); <span class="hljs-regexp">//</span>b需要转化为a，此时发生错误：是调用A中的转换构造函数把对象b变成a，还是调用B中的重载类型转换运算符将b变成a？<br></code></pre></td></tr></table></figure><p>解决方法：显式调用。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//修改a <span class="hljs-operator">=</span> f(b)<span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> f(A(b)<span class="hljs-comment">;</span><br><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> f(b.operator A())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-5"><p>类定义了多个转换规则，某些规则可以通过其他类型转换实现（多见于算术运算符）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//main外：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">double</span> a;<br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>) :a(i) &#123;&#125;<br>A(<span class="hljs-built_in">double</span> d) :a(d) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>() <span class="hljs-keyword">const</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">int</span>(a); &#125;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span>() <span class="hljs-keyword">const</span></span> &#123; <span class="hljs-keyword">return</span> a; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> <span class="hljs-built_in">double</span></span>)</span>&#123;&#125;<br><span class="hljs-comment">//main()内：</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>A a;<br>f(a);     <span class="hljs-comment">//二义性，是从double还是int的运算符重载提升为long double？</span><br><span class="hljs-built_in">long</span> d = a；<span class="hljs-comment">//二义性，是从double还是int的运算符重载提升为long double？</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有谁优于的原则不会产生此问题。（本题的两个提升地位相同）</p></li><li class="lvl-5"><p>重载运算符和类型转换函数结合导致了二义性：</p><p>一般是因为在某些情况下既可以是类对象转换为基本数据类型，或者基本数据类型转变为类类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//main外：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><br>&#123;<br>friend A <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> A&amp; a1,<span class="hljs-keyword">const</span> A&amp; a2);<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> a;<br><span class="hljs-keyword">public</span>:<br>A(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>) :a(i) &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>()<span class="hljs-keyword">const</span></span> &#123; <span class="hljs-keyword">return</span> a; &#125;<br>&#125;;<br>A <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> A&amp; a1, <span class="hljs-keyword">const</span> A&amp; a2) <br>&#123;<br><span class="hljs-keyword">return</span> A(a1.a + a2.a);<br>&#125;<br><span class="hljs-comment">//main()内：</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>A a1, a2;<br>A a3 = a1 + a2;  <span class="hljs-comment">//此处无问题，可以使用重载的+运算符</span><br>a3 = <span class="hljs-number">1</span> + a1;    <span class="hljs-comment">//二义性错误，不知道是将1转为类对象还是将a1转为int类型。</span><br>a3 = a2 + <span class="hljs-number">1</span>;    <span class="hljs-comment">//同上</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法：在构造函数上加explicit或者直接进行显式的强制类型转化。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//可以是；</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">int</span>()<span class="hljs-keyword">const</span></span> &#123; <span class="hljs-keyword">return</span> a; &#125;<br><span class="hljs-comment">//或者是：</span><br>a3 = A(<span class="hljs-number">1</span>) + a1<br>a3 = <span class="hljs-built_in">int</span>(a2) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>注意：出现此种情况说明我们的代码设计不够好。</p></li></ol></li></ul><h4 id="四代码展示"><a href="#四代码展示" class="header-anchor">¶</a>（四）代码展示</h4><p>对上一章中的newvector2提供相关的类型转化（转化为vector2和转换成基本类型double）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//添加两个成员函数</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">vector2</span>()</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2。cpp</span><br><span class="hljs-comment">//定义两个成员函数</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">newvector2::operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> xx, <span class="hljs-type">double</span> yy)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(xx * xx + yy * yy);<br>&#125;<br><br><span class="hljs-function">newvector2::<span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function">newvector2::<span class="hljs-keyword">operator</span> <span class="hljs-title">vector2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">vector2</span>(x, y);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vector2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">newvector2 <span class="hljs-title">newv</span><span class="hljs-params">(<span class="hljs-number">11</span>,<span class="hljs-number">13</span>,<span class="hljs-string">&quot;aaaa&quot;</span>)</span></span>;<br>vector2 v = newv;<br><span class="hljs-type">double</span> x = newv;<br>cout &lt;&lt; <span class="hljs-string">&quot;v:&quot;</span> &lt;&lt; v;<br>cout &lt;&lt; <span class="hljs-string">&quot;x:&quot;</span> &lt;&lt; x &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——运算符重载(二)</title>
    <link href="/xiaohei07.github.io/2023/03/24/c++%E7%B1%BB%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD(%E4%BA%8C)/"/>
    <url>/xiaohei07.github.io/2023/03/24/c++%E7%B1%BB%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h3 id="经典例子"><a href="#经典例子" class="header-anchor">¶</a>经典例子：</h3><p>我们以两个类，二维向量vector2和二维新式向量newvector2来说明各种运算符的重载。</p><p>vector全部使用友元函数重载，newvector全部使用成员函数重载，两个都可以时同时重载。</p><p>其成员为x和y，主要操作为x（如自增自减等等），次要操作为y。</p><h4 id="一重载和-"><a href="#一重载和-" class="header-anchor">¶</a>（一）重载++和--：</h4><p><ins>和--的重载分为前置和后置两种情况，另外，虽然修改了类对象的状态，但是可以使用友元函数传入引用来实现</ins>和--的类外重载。</p><p>前置++或--的成员函数不需要传入参数，在代码块内不需要拷贝临时变量返回，只通过this指针进行自增/自减。</p><p>后置<ins>或--需要传入一个int类型的参数，可以不指定名称，因为一般在代码块内部不会使用它，这个参数只是为了占位置，用于和前置</ins>/--运算符的区别。在代码块内需要先拷贝一个临时变量返回。只通过this指针自增/自减。</p><p>前置++或--的友元函数需要传入一个类对象的引用，不需要拷贝临时变量返回，直接对传入参数进行操作（因为引用可以对其有效修改）。</p><p>后置++或--的友元函数需要传入两个参数，一个是类对象的引用，且为左操作数，一个是占位的int类型参数（和上面逻辑相同），需要先拷贝临时变量返回，直接对传入参数进行操作。</p><p>详细代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">vector2</span><br>&#123;<br><span class="hljs-keyword">friend</span> vector2 <span class="hljs-keyword">operator</span> ++(vector2&amp; v);         <span class="hljs-comment">//前置++重载友元</span><br><span class="hljs-keyword">friend</span> vector2 <span class="hljs-keyword">operator</span> ++(vector2&amp; v, <span class="hljs-type">int</span>);    <span class="hljs-comment">//后置++重载友元</span><br><span class="hljs-keyword">friend</span> vector2 <span class="hljs-keyword">operator</span> --(vector2&amp; v);         <span class="hljs-comment">//前置--重载友元</span><br><span class="hljs-keyword">friend</span> vector2 <span class="hljs-keyword">operator</span> --(vector2&amp; v, <span class="hljs-type">int</span>);    <span class="hljs-comment">//后置--重载友元</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">vector2</span>(<span class="hljs-type">double</span> vx = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> vy = <span class="hljs-number">0</span>);<br><span class="hljs-built_in">vector2</span>(<span class="hljs-type">const</span> vector2 &amp;v);<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>~<span class="hljs-built_in">vector2</span>();<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">newvector2</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">newvector2</span>(<span class="hljs-type">double</span> vx = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> vy = <span class="hljs-number">0</span>);<br><span class="hljs-built_in">newvector2</span>(<span class="hljs-type">const</span> newvector2&amp; v);<br>newvector2 <span class="hljs-keyword">operator</span>++();             <span class="hljs-comment">//前置++重载成员</span><br>newvector2 <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> vx);       <span class="hljs-comment">//后置++重载成员</span><br>newvector2 <span class="hljs-keyword">operator</span>--(); <span class="hljs-comment">//前置--重载成员</span><br>newvector2 <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span> vy);       <span class="hljs-comment">//后置--重载成员 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>~<span class="hljs-built_in">newvector2</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vector2.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>vector2::<span class="hljs-built_in">vector2</span>(<span class="hljs-type">double</span> vx,<span class="hljs-type">double</span> vy):<span class="hljs-built_in">x</span>(vx),<span class="hljs-built_in">y</span>(vy)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建了一个二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>vector2::<span class="hljs-built_in">vector2</span>(<span class="hljs-type">const</span> vector2&amp; v)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = v.x;<br><span class="hljs-keyword">this</span>-&gt;y = v.y;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数创建了一个二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>vector2::~<span class="hljs-built_in">vector2</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构了一个二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br>vector2 <span class="hljs-keyword">operator</span> ++(vector2&amp; v)<br>&#123;<br>++v.x;<br><span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vector2::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;x:&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,y:&quot;</span> &lt;&lt; y &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>vector2 <span class="hljs-keyword">operator</span> ++(vector2&amp; v, <span class="hljs-type">int</span>) <br>&#123;<br><span class="hljs-function">vector2 <span class="hljs-title">temp</span><span class="hljs-params">(v)</span></span>;<br>v.x++;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br>vector2 <span class="hljs-keyword">operator</span> --(vector2&amp; v) <br>&#123;<br>--v.x;<br><span class="hljs-keyword">return</span> v;<br>&#125;<br><br>vector2 <span class="hljs-keyword">operator</span> --(vector2&amp; v, <span class="hljs-type">int</span>) <br>&#123;<br><span class="hljs-function">vector2 <span class="hljs-title">temp</span><span class="hljs-params">(v)</span></span>;<br>v.x--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><br><br>newvector2::<span class="hljs-built_in">newvector2</span>(<span class="hljs-type">double</span> vx, <span class="hljs-type">double</span> vy) :<span class="hljs-built_in">x</span>(vx), <span class="hljs-built_in">y</span>(vy)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>newvector2::<span class="hljs-built_in">newvector2</span>(<span class="hljs-type">const</span> newvector2&amp; v)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = v.x;<br><span class="hljs-keyword">this</span>-&gt;y = v.y;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数创建了一个二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>newvector2::~<span class="hljs-built_in">newvector2</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">newvector2::print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;x:&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,y:&quot;</span> &lt;&lt; y &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>newvector2 newvector2::<span class="hljs-keyword">operator</span>++() <br>&#123;<br>++<span class="hljs-keyword">this</span>-&gt;x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>newvector2 newvector2::<span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<br>&#123;<br><span class="hljs-function">newvector2 <span class="hljs-title">temp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br><span class="hljs-keyword">this</span>-&gt;x++;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br>newvector2 newvector2::<span class="hljs-keyword">operator</span>--() <br>&#123;<br>--<span class="hljs-keyword">this</span>-&gt;x;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>newvector2 newvector2::<span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>)<br>&#123;<br><span class="hljs-function">newvector2 <span class="hljs-title">temp</span><span class="hljs-params">(*<span class="hljs-keyword">this</span>)</span></span>;<br><span class="hljs-keyword">this</span>-&gt;x--;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs sas">//main.cpp<br>#include<span class="hljs-string">&quot;vector2.h&quot;</span><br>int mai<span class="hljs-meta">n</span>()<br>&#123;<br>vector2 v(2, 4);<br>vector2 vv;<br>cout &lt;&lt; <span class="hljs-string">&quot;开始的v: &quot;</span>;<br>v.pr<span class="hljs-meta">int</span>();<br>vv=v++;<br>cout &lt;&lt; <span class="hljs-string">&quot;v++后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v:&quot;</span>;<br>v.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;vv: &quot;</span>;<br>vv.pr<span class="hljs-meta">int</span>();<br>vv=++v;<br>cout &lt;&lt; <span class="hljs-string">&quot;++v后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v: &quot;</span>;<br>v.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;vv: &quot;</span>;<br>vv.pr<span class="hljs-meta">int</span>();<br>vv=v--;<br>cout &lt;&lt; <span class="hljs-string">&quot;v--后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v: &quot;</span>;<br>v.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;vv: &quot;</span>;<br>vv.pr<span class="hljs-meta">int</span>();<br>vv=--v;<br>cout &lt;&lt; <span class="hljs-string">&quot;--v后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;v: &quot;</span>;<br>v.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;vv: &quot;</span>;<br>vv.pr<span class="hljs-meta">int</span>();<br><br>newvector2 newv(2, 4);<br>newvector2 newvv;<br>cout &lt;&lt; <span class="hljs-string">&quot;开始的newv: &quot;</span>;<br>newv.pr<span class="hljs-meta">int</span>();<br>newvv = newv++;<br>cout &lt;&lt; <span class="hljs-string">&quot;newv++后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;newv:&quot;</span>;<br>newv.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;newvv: &quot;</span>;<br>newvv.pr<span class="hljs-meta">int</span>();<br>newvv = ++newv;<br>cout &lt;&lt; <span class="hljs-string">&quot;++nwev后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;newv: &quot;</span>;<br>newv.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;newvv: &quot;</span>;<br>newvv.pr<span class="hljs-meta">int</span>();<br>newvv = newv--;<br>cout &lt;&lt; <span class="hljs-string">&quot;newv--后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;newv: &quot;</span>;<br>newv.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;newvv: &quot;</span>;<br>newvv.pr<span class="hljs-meta">int</span>();<br>newvv = --newv;<br>cout &lt;&lt; <span class="hljs-string">&quot;--newv后: &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;newv: &quot;</span>;<br>newv.pr<span class="hljs-meta">int</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;newvv: &quot;</span>;<br>newvv.pr<span class="hljs-meta">int</span>();<br><span class="hljs-keyword">return</span> 0;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">/*运行结果:</span><br>创建了一个二维向量<br>创建了一个二维向量<br><span class="hljs-section">开始的v: x:2,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br><span class="hljs-section">v++后:</span><br><span class="hljs-section">v:x:3,y:4</span><br><span class="hljs-section">vv: x:2,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>析构了一个二维向量<br><span class="hljs-section">++v后:</span><br><span class="hljs-section">v: x:4,y:4</span><br><span class="hljs-section">vv: x:4,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br><span class="hljs-section">v--后:</span><br><span class="hljs-section">v: x:3,y:4</span><br><span class="hljs-section">vv: x:4,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>析构了一个二维向量<br><span class="hljs-section">--v后:</span><br><span class="hljs-section">v: x:2,y:4</span><br><span class="hljs-section">vv: x:2,y:4</span><br>创建了一个新式二维向量<br>创建了一个新式二维向量<br><span class="hljs-section">开始的newv: x:2,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br><span class="hljs-section">newv++后:</span><br><span class="hljs-section">newv:x:3,y:4</span><br><span class="hljs-section">newvv: x:2,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>析构了一个新式二维向量<br><span class="hljs-section">++nwev后:</span><br><span class="hljs-section">newv: x:4,y:4</span><br><span class="hljs-section">newvv: x:4,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br><span class="hljs-section">newv--后:</span><br><span class="hljs-section">newv: x:3,y:4</span><br><span class="hljs-section">newvv: x:4,y:4</span><br>调用拷贝构造函数创建了一个二维向量<br>析构了一个新式二维向量<br><span class="hljs-section">--newv后:</span><br><span class="hljs-section">newv: x:2,y:4</span><br><span class="hljs-section">newvv: x:2,y:4</span><br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>*/<br></code></pre></td></tr></table></figure><h4 id="二重载"><a href="#二重载" class="header-anchor">¶</a>（二）重载=：</h4><p>赋值运算符的重载用于对象数据的复制，且必须重载为成员函数，返回类型为对象的引用（为了能够连续操作，否则会有临时变量作为左值出现）。</p><p>赋值运算符是用已存在的对象给另一个对象赋新的值，该对象原来是有值的，所以重载的赋值运算符只能被已经存在了的对象调用，而不能凭空产生。</p><ul class="lvl-0"><li class="lvl-2"><p>和拷贝构造函数的区别：</p><ol><li class="lvl-5"><p>拷贝构造函数生成新的类对象，而重载的赋值运算符是给已有的类对象进行赋值。</p><p>——因此，如果是一个类对象初始化使用&quot;=&quot;运算符，右侧操作数即使也是这个类的对象，调用的仍然是拷贝构造函数而不是重载的赋值运算符，毕竟其还未被初始化完毕。</p></li><li class="lvl-5"><p>拷贝构造函数不必检测源对象是否与新建对象相同，而赋值运算符则需要。</p></li><li class="lvl-5"><p>如果赋值运算符中被赋值的对象有内存分配，需要先把内存释放掉再进行赋值。（要不原来的分配的内存就一直不会被释放了，另外此处的赋值他也是在堆上进行的）</p></li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//为newvector2添加一个新的char指针成员。</span><br><span class="hljs-type">char</span>* p;<br><span class="hljs-comment">//添加了一个重载赋值运算符</span><br>newvector2&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> newvector2&amp; v);<br><span class="hljs-comment">//构造函数参数修改：</span><br><span class="hljs-built_in">newvector2</span>(<span class="hljs-type">double</span> vx = <span class="hljs-number">0</span>, <span class="hljs-type">double</span> vy = <span class="hljs-number">0</span>,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*vp=<span class="hljs-string">&quot;\0&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.cpp</span><br><span class="hljs-comment">//构造函数修改：</span><br>newvector2::<span class="hljs-built_in">newvector2</span>(<span class="hljs-type">double</span> vx, <span class="hljs-type">double</span> vy,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*vp) :<span class="hljs-built_in">x</span>(vx), <span class="hljs-built_in">y</span>(vy)<br>&#123;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(vp) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(p, <span class="hljs-built_in">strlen</span>(vp)<span class="hljs-number">+1</span>, (<span class="hljs-type">char</span>*)vp);<br>cout &lt;&lt; <span class="hljs-string">&quot;创建了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//复制构造函数修改：</span><br>newvector2::<span class="hljs-built_in">newvector2</span>(<span class="hljs-type">const</span> newvector2&amp; v)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = v.x;<br><span class="hljs-keyword">this</span>-&gt;y = v.y;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(v.p) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(p, <span class="hljs-built_in">strlen</span>(v.p) + <span class="hljs-number">1</span>, v.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数创建了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//析构函数修改：</span><br>newvector2::~<span class="hljs-built_in">newvector2</span>()<br>&#123;<br><span class="hljs-keyword">delete</span>[]p;<br>p = <span class="hljs-literal">NULL</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//定义重载赋值运算符</span><br>newvector2&amp; newvector2::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> newvector2&amp; v) <br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = v.x;<br><span class="hljs-keyword">this</span>-&gt;y = v.y;<br><span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">this</span>-&gt;p);<br><span class="hljs-keyword">this</span>-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(v.p) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(<span class="hljs-keyword">this</span>-&gt;p,<span class="hljs-built_in">strlen</span>(v.p)<span class="hljs-number">+1</span>,v.p);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-comment">#include&quot;vector2.h&quot;</span><br><span class="hljs-symbol">int</span> main()<br>&#123;<br>newvector2 <span class="hljs-built_in">v1</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;first&quot;</span>)<span class="hljs-comment">;</span><br>newvector2 <span class="hljs-built_in">v2</span> = <span class="hljs-built_in">v1</span><span class="hljs-comment">;</span><br>newvector2 <span class="hljs-built_in">v3</span>, <span class="hljs-built_in">v4</span><span class="hljs-comment">;</span><br><span class="hljs-built_in">v4</span> = <span class="hljs-built_in">v3</span> = <span class="hljs-built_in">v1</span><span class="hljs-comment">;</span><br>return <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>创建了一个新式二维向量<br>调用拷贝构造函数创建了一个新式二维向量<br>创建了一个新式二维向量<br>创建了一个新式二维向量<br>调用赋值运算符为一个对象赋值<br>调用赋值运算符为一个对象赋值<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br></code></pre></td></tr></table></figure><h4 id="三重载-相同"><a href="#三重载-相同" class="header-anchor">¶</a>（三）重载+ (- | * | / | %相同)：</h4><p>一般建议使用友元函数重载，但是也可以使用全局函数或者成员函数重载。</p><p>本类型中尽量不要使用引用进行传递，否则会无法进行隐性的类型转化。</p><p>当然一般情况下建议使用引用进行传递，不过这样在不加其他函数的情况下不可以进行隐式类型转化。</p><p>成员函数的弊端是不能只把基本类型放在左操作数上（不发生隐形类型转化，有限制），不过可以让两个均为基本类型（均发生隐形类型转化）</p><p>是比较简单的二元运算符重载。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//vector2加一个友元函数：</span><br><span class="hljs-keyword">friend</span> vector2 <span class="hljs-keyword">operator</span> +(vector2 v1, vector2 v2);<br><span class="hljs-comment">//newvector2加一个成员函数：</span><br>newvector2 <span class="hljs-keyword">operator</span>+(newvector2 v);<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//vector2.cpp</span><br><span class="hljs-comment">//vector2的+运算符重载定义</span><br>vector2 <span class="hljs-keyword">operator</span>+(vector2 v1,vector2 v2)<br>&#123;<br><span class="hljs-keyword">return</span> vector2(v1.x + v2.x, v1.y + v2.y);<br>&#125;<br><span class="hljs-comment">//newvector2的+运算符重载定义</span><br>newvector2 newvector2::<span class="hljs-keyword">operator</span>+(newvector2 v) <br>&#123;<br><span class="hljs-keyword">return</span> newvector2(<span class="hljs-keyword">this</span>-&gt;x + v.x, <span class="hljs-keyword">this</span>-&gt;y + v.y, <span class="hljs-keyword">this</span>-&gt;p);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs smali">//main.cpp<br><span class="hljs-comment">#include&quot;vector2.h&quot;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">int </span>main()<br>&#123;<br>vector2 v1(1, 2);<br>vector2 v2(3, 4);<br>vector2 v3(4, 8);<br>vector2 v4 = v1 + v2 + v3;<br>v4.print();<br>vector2 v5 = 1.0 + v3;  //发生隐性类型转化<br>v5.print();<br>vector2 v6 = v3 + 2.0;  //同<br>v6.print();<br>vector2 v7 = 3.0 + 4.0; //同<br>v7.print();<br><br>newvector2 vv1(1, 2);<br>newvector2 vv2(2, 3);<br>newvector2 vv3(3, 4);<br>newvector2 vv4 = vv1 + vv2 + vv3;<br>vv4.print();<br>newvector2 vv6 = vv3 + 2.0;   //发生隐性类型转化<br>vv6.print();<br>//newvector2 vv5 = 1.0 + vv3; 成员函数的弊端：必须把左操作数设置为类对象<br>newvector2 vv7 = 3.0 + 4.0;   //同转化<br>vv7.print();<br><span class="hljs-built_in">return </span>0;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">//运行结果</span><br>创建了一个二维向量<br>创建了一个二维向量<br>创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>创建了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>创建了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">8</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">14</span><br>调用拷贝构造函数创建了一个二维向量<br>创建了一个二维向量<br>创建了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">5</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">8</span><br>创建了一个二维向量<br>调用拷贝构造函数创建了一个二维向量<br>创建了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">6</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">8</span><br>创建了一个二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">7</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">0</span><br>创建了一个新式二维向量<br>创建了一个新式二维向量<br>创建了一个新式二维向量<br>调用拷贝构造函数创建了一个新式二维向量<br>调用拷贝构造函数创建了一个新式二维向量<br>创建了一个新式二维向量<br>析构了一个新式二维向量<br>创建了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">6</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">9</span><br>创建了一个新式二维向量<br>创建了一个新式二维向量<br>析构了一个新式二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">5</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">4</span><br>创建了一个新式二维向量<br><span class="hljs-variable language_">x</span>:<span class="hljs-number">7</span>,<span class="hljs-variable language_">y</span>:<span class="hljs-number">0</span><br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个新式二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br>析构了一个二维向量<br></code></pre></td></tr></table></figure><p>可以仔细想想每个构造和析构函数出现的原因（当思考题了😋）</p><h4 id="四重载lt和gt-其他比较运算符性质相同"><a href="#四重载lt和gt-其他比较运算符性质相同" class="header-anchor">¶</a>（四）重载&lt;和&gt; (其他比较运算符性质相同)：</h4><p>此处只通过友元函数重载，且使用const引用。</p><p>注意，此要返回bool值，尽可能不要返回其他类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//vector2增加友元函数</span><br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> vector2&amp; v1, <span class="hljs-type">const</span> vector2&amp; v2);<br><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-type">const</span> vector2&amp; v1, <span class="hljs-type">const</span> vector2&amp; v2);<br></code></pre></td></tr></table></figure><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs smali">//vector2.cpp<br>//增加两个友元函数的定义<br>bool operator &lt;(const vector2&amp; v1,<span class="hljs-built_in"> const </span>vector2&amp; v2) <br>&#123;<br><span class="hljs-built_in">return </span>bool(v1.x * v1.x + v1.y + v1.y &lt; v2.x* v2.x + v2.y * v2.y);<br>&#125;<br><br>bool operator &gt;(const vector2&amp; v1,<span class="hljs-built_in"> const </span>vector2&amp; v2) <br>&#123;<br><span class="hljs-built_in">return </span>bool(v1.x * v1.x + v1.y + v1.y &gt; v2.x* v2.x + v2.y * v2.y);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vector2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">vector2 <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-function">vector2 <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span></span>;<br><span class="hljs-keyword">if</span> (v1 &lt; v2) &#123; cout &lt;&lt; <span class="hljs-string">&quot;v1到0距离小于v2&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1 &gt; v2) &#123; cout &lt;&lt; <span class="hljs-string">&quot;v1到0距离大于v2&quot;</span> &lt;&lt; endl; &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>创建了一个二维向量<br>创建了一个二维向量<br>v1到<span class="hljs-number">0</span>距离小于v2<br>析构了一个二维向量<br>析构了一个二维向量<br><br></code></pre></td></tr></table></figure><h4 id="五重载和"><a href="#五重载和" class="header-anchor">¶</a>（五）重载[]和()：</h4><p>是二元运算符，但是均只能用成员函数重载。</p><ul class="lvl-0"><li class="lvl-2"><p>重载下表运算符[]：</p><p>用于访问数据对象的元素，这种写法更符合我们的习惯。</p><p><strong>x[y]<strong>等价于</strong>x.operator(y)</strong></p><p>参数类型和返回类型可以自定。</p><p>但是需要我们自己增加下标越界检查，这样[]的使用更为安全。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//newvector2增加新成员函数：</span><br>double operator<span class="hljs-selector-attr">[]</span>(int i);<br><span class="hljs-comment">//增加新数据成员：</span><br>double darray<span class="hljs-selector-attr">[20]</span>;<br><span class="hljs-comment">//构造函数保持不变</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.cpp</span><br><span class="hljs-comment">//构造函数改为：</span><br>newvector2::<span class="hljs-built_in">newvector2</span>(<span class="hljs-type">double</span> vx, <span class="hljs-type">double</span> vy,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*vp) :<span class="hljs-built_in">x</span>(vx), <span class="hljs-built_in">y</span>(vy)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>darray[i] = i<span class="hljs-number">+1</span>;<br>&#125;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(vp) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(p, <span class="hljs-built_in">strlen</span>(vp)<span class="hljs-number">+1</span>, (<span class="hljs-type">char</span>*)vp);<br>cout &lt;&lt; <span class="hljs-string">&quot;创建了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br>newvector2::<span class="hljs-built_in">newvector2</span>(<span class="hljs-type">const</span> newvector2&amp; v)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = v.x;<br><span class="hljs-keyword">this</span>-&gt;y = v.y;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br><span class="hljs-keyword">this</span>-&gt;darray[i] = v.darray[i];<br>&#125;<br>p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(v.p) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(p, <span class="hljs-built_in">strlen</span>(v.p) + <span class="hljs-number">1</span>, v.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;调用拷贝构造函数创建了一个新式二维向量&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//赋值运算符改为</span><br>newvector2&amp; newvector2::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> newvector2&amp; v) <br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = v.x;<br><span class="hljs-keyword">this</span>-&gt;y = v.y;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) <br>&#123;<br><span class="hljs-keyword">this</span>-&gt;darray[i] = v.darray[i];<br>&#125;<br><span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">this</span>-&gt;p);<br><span class="hljs-keyword">this</span>-&gt;p = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(v.p) + <span class="hljs-number">1</span>];<br><span class="hljs-built_in">strcpy_s</span>(<span class="hljs-keyword">this</span>-&gt;p,<span class="hljs-built_in">strlen</span>(v.p)<span class="hljs-number">+1</span>,v.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;调用赋值运算符为一个对象赋值&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">//增加[]重载运算符的定义：</span><br><span class="hljs-type">double</span> newvector2::<span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <br>&#123;<br><span class="hljs-comment">//越界要检查</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">20</span> <span class="hljs-keyword">and</span> i &gt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> darray[i];<br>&#125;<br><span class="hljs-keyword">else</span>  <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;越界！将输出限定为0&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vector2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">newvector2 <span class="hljs-title">v</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;1&quot;</span>)</span></span>;<br>cout &lt;&lt; v[<span class="hljs-number">5</span>] &lt;&lt; endl;<br>cout &lt;&lt; v[<span class="hljs-number">222</span>] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>创建了一个新式二维向量<br><span class="hljs-number">6</span><br>越界！将输出限定为<span class="hljs-number">0</span><br><span class="hljs-number">0</span><br>析构了一个新式二维向量<br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>重载函数调用符：</p><p>用于函数调用。</p><p><strong>x(y1,y2,y3,...)<strong>等价于</strong>x.operator()(y1,y2,y3,...)</strong></p><p>这样，我们可以像使用函数一样使用类的对象，因为其可以存储类的状态，所以相较于函数这种写法更加灵活。</p><p>调用运算符的参数表是不唯一的，可以根据需要确定个数及类型。</p><p>返回类型也没有限定。</p><p>这里的函数调用符用于计算传入两个值作为一个点到（0,0）的距离。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//newvector2增加新成员函数：</span><br><span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">operator</span>()(<span class="hljs-params"><span class="hljs-built_in">double</span> xx, <span class="hljs-built_in">double</span> yy</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.cpp</span><br><span class="hljs-comment">//增加()重载运算符的定义：</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">newvector2::operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">double</span> xx, <span class="hljs-type">double</span> yy)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(xx * xx + yy * yy);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vector2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>newvector2 v;<br>cout &lt;&lt; <span class="hljs-built_in">v</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br>创建了一个新式二维向量<br><span class="hljs-number">3.60555</span><br>析构了一个新式二维向量<br></code></pre></td></tr></table></figure></li></ul><h4 id="六重载ltlt和gtgt"><a href="#六重载ltlt和gtgt" class="header-anchor">¶</a>（六）重载&lt;&lt;和&gt;&gt;：</h4><p>istream和ostream是c++的预定义流类。</p><p>cin是istream的对象，cout是ostream的对象。</p><p>运算符&lt;&lt;由ostream重载为插入操作，用于输出基本类型数据，我们可以对其重载，使输出为自定义的数据类型。</p><p>运算符&gt;&gt;由istream重载为提取操作，用于输入基本类型数据，我们可以对其重载，使输入为自定义的数据类型。</p><p>只能重载为友元函数。（因为cout&lt;&lt;的左操作数只能为cout，右操作数才是需要输出的对象，cin&gt;&gt;同理）</p><p>返回类型限定为ostream&amp; 和istream&amp;，第一个参数强制为ostream&amp;和istream&amp;，第二个参数为用户自定义的类型。（引用绝对不可以省略！）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//vector2.h</span><br><span class="hljs-comment">//vector2增加新友元函数：</span><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt;(ostream&amp; output, <span class="hljs-type">const</span> vector2&amp; v);<br><span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span> &gt;&gt;(istream&amp; input,  vector2&amp; v);<br></code></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-comment">//vector2.cpp</span><br><span class="hljs-comment">//增加&lt;&lt;和&gt;&gt;重载运算符的定义：</span><br>ostream&amp; operator &lt;&lt;(ostream&amp; <span class="hljs-keyword">output</span>, <span class="hljs-keyword">const</span> vector2&amp; v) <br>&#123;<br><span class="hljs-keyword">output</span> &lt;&lt; <span class="hljs-string">&quot;x:&quot;</span> &lt;&lt; v<span class="hljs-variable">.x</span> &lt;&lt; <span class="hljs-string">&quot;,y:&quot;</span> &lt;&lt; v<span class="hljs-variable">.y</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">output</span>;<br>&#125;<br><br>istream&amp; operator &gt;&gt;(istream&amp; <span class="hljs-keyword">input</span>, vector2&amp; v) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请分别输入这个二维向量的x和y：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">input</span> &gt;&gt; v<span class="hljs-variable">.x</span>;<br><span class="hljs-keyword">input</span> &gt;&gt; v<span class="hljs-variable">.y</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">input</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;vector2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector2 v;<br>cin &gt;&gt; v;<br>cout &lt;&lt; v;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出结果：</span><br>创建了一个二维向量<br>请分别输入这个二维向量的x和y：<br><span class="hljs-number">5</span> <span class="hljs-number">9</span><br>x:<span class="hljs-number">5</span>,y:<span class="hljs-number">9</span><br>析构了一个二维向量<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“c++类——运算符重载(一)”</title>
    <link href="/xiaohei07.github.io/2023/03/24/c++%E7%B1%BB%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD(%E4%B8%80)/"/>
    <url>/xiaohei07.github.io/2023/03/24/c++%E7%B1%BB%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h3 id="一引言和概念"><a href="#一引言和概念" class="header-anchor">¶</a>（一）引言和概念:</h3><p>C++预定义中的运算符的操作对象只局限于基本的内置数据类型。</p><p>但实际上，对于许多用户自定义类型（如类、结构等）也需要类似的运算操作。这时就必须在C ++ 中重新定义这些运算符，赋予已有运算符新的功能，使它能够用于特定类型执行特定的操作。</p><p>运算符重载的实质是特殊的函数重载或函数多态。定义运算符重载函数，目的在于让c++编译器在遇到该运算符时能够用同名的运算符来完成不同的基本操作。要重载运算符，需要使用运算符重载函数的特殊函数形式。</p><p>运算符重载提供了C ++ 的可扩展性，也是C ++ 最吸引人的特性之一。</p><p>本文主要是理论知识，详细代码会在下一节展示。</p><h3 id="二运算符重载的规则"><a href="#二运算符重载的规则" class="header-anchor">¶</a>（二）运算符重载的规则：</h3><ul class="lvl-0"><li class="lvl-2"><p>运算符限制：</p><p>可以重载绝大部分的运算符：</p><table><thead><tr><th>可重载类型</th><th>具体运算符</th></tr></thead><tbody><tr><td>双目算数运算符</td><td>+ (加)，-(减)，*(乘)，/(除)，% (取模)</td></tr><tr><td>关系运算符</td><td>==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于)，&lt;=(小于等于)，&gt;=(大于等于)</td></tr><tr><td>逻辑运算符</td><td>||(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非)</td></tr><tr><td>单目运算符</td><td>+ (正)，-(负)，*(指针)，&amp;(取地址)</td></tr><tr><td>自增自减运算符</td><td>++(自增)，--(自减)</td></tr><tr><td>位运算符</td><td>| (按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移)</td></tr><tr><td>赋值运算符</td><td>=, +=, -=, *=, /= , % = , &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=</td></tr><tr><td>空间申请与释放</td><td><input type="checkbox" id="checkbox0"><label for="checkbox0">, delete[]</label></td></tr><tr><td>其他运算符</td><td><strong>()</strong>(函数调用)，<strong>-&gt;</strong>(成员访问)，<strong>,</strong>(逗号)，<strong>[]</strong>(下标)</td></tr></tbody></table><p>但不能重载下面的运算符：</p><p>.                类成员选择运算符</p><p>.*              成员指针运算符</p><p>（这两个运算符不能被重载是为了保证访问成员的功能不被改变）</p><p>::               作用域运算符</p><p>sizeof      长度运算符</p><p>（这两个运算符的运算对象就是类型，而不是变量或者一般式，不具备重载的特征）</p><p>?:              条件表达式运算符</p><p>#              预处理符号</p><p>另外，只有“=”的重载函数不能被继承。</p><p>在c++11中，typeid、const_cast、dynamic_cast、reinterpret_cast、static_cast的强制类型转换运算符也不能进行重载。</p></li><li class="lvl-2"><p>运算符重载要保持原有的基本语义不变，不能改变用于内部对象时该运算符的含义。</p></li><li class="lvl-2"><p>重载运算符限制在c++语言中已有的运算符范围内的允许重载的运算符之中，不允许创建新的运算符。</p></li><li class="lvl-2"><p>被重载的运算符的优先级、结合性、操作数的个数和语法结构均不变。因此，不允许在重载的运算符函数中使用默认参数。</p></li><li class="lvl-2"><p>编译器对运算符重载的函数选择，遵循函数重载的选择规则（函数契合优先级保持不变，因为运算符重载本质上是函数重载）。</p></li><li class="lvl-2"><p>运算符重载函数只能和用户自定义类型的对象一起使用或者和内部类型的对象混用。即其操作对象至少有一个应该是类对象或类对象的引用。</p></li><li class="lvl-2"><p>另外，虽然没有强制规定，但是重载运算符的时候其功能应当和原有功能类似。</p></li></ul><h3 id="三运算符重载的定义"><a href="#三运算符重载的定义" class="header-anchor">¶</a>（三）运算符重载的定义：</h3><p><em><strong>(friend) 返回类型 类名:: operator op(参数表) { 函数结构体 }</strong></em></p><p>重载为友元函数在开头加friend关键字，否则无需添加。</p><p>返回类型可以是任何有效类型，但通常情况下是操作类的对象及其引用。</p><p>类名是在类外定义时需要添加的，如果是类内定义可以不用添加。</p><p>operator是关键字，指定其为运算符重载函数。</p><p>op为运算符，也是实际的函数名。</p><p>参数表为形参表，其参数的个数和重载的运算符操作数的个数有关。</p><h3 id="四运算符重载的形式"><a href="#四运算符重载的形式" class="header-anchor">¶</a>（四）运算符重载的形式：</h3><p>运算符函数重载一般有两种形式：重载为类的成员函数和重载为类的非成员函数。</p><p>非成员函数通常是友元函数，因为大多数时候重载运算符需要访问类的私有数据。</p><p>当然也可以把一个运算符作为一个非成员、非友元函数重载。但是，这样的运算符函数访问类的私有和保护成员时，必须使用类的公有接口中提供的设置数据和读取数据的函数，调用这些函数时会降低性能——所以一般都会设置为友元函数。</p><ul class="lvl-0"><li class="lvl-2"><p>重载为成员函数：</p><p>当运算符重载为类的成员函数，其参数个数比原来的操作数少一个（后置单目运算符除外），原因在于成员函数会使用this指针隐式访问类的一个对象，可以充当运算符函数最左边的操作数。</p><p>因此，成员函数的运算符重载函数的左操作数一定是运算符类的一个类对象或者类对象的引用。</p><ol><li class="lvl-5"><p>双目运算符重载为类的成员函数时，函数参数表只显式说明一个参数，该参数作为运算符右操作数参与运算。</p></li><li class="lvl-5"><p>前置单目运算符重载为类的成员函数时，没有形参，不需要显式说明。</p></li><li class="lvl-5"><p>后置单目运算符重载为类的成员函数时，函数需要一个整型形参。（不一定要使用这个形参，但是需要这个整型形参来区别前置和后置运算符）</p></li></ol></li><li class="lvl-2"><p>重载为友元函数：</p><p>没有隐含的this指针，因此操作数的个数没有发生变化，所有操作数都需要通过参数表来指定和传递，参数从左到右和操作数一一对应。</p></li><li class="lvl-2"><p>两种重载形式的联系和区别：</p><p>本质上，是因为成员函数能够有this指针，友元函数没有this指针。</p><p>两者的使用方法相同。但是实现方式不同，传递参数不同，应用场景也不同。</p></li><li class="lvl-2"><p>两种重载形式的不同特点：</p><ul class="lvl-2"><li class="lvl-4"><p>成员函数：</p><p>核心：如果左操作数只能是类对象的话一般使用重载成员函数。</p><ol><li class="lvl-7"><p>一般情况下，单目运算符重载为类的成员函数。（唯一操作数刚好可以是this所指向的类对象）</p></li><li class="lvl-7"><p>双目运算符 &quot;=&quot; 、&quot;()&quot; 、&quot;[]&quot; 、&quot;-&gt;&quot; 只能被重载为类的成员函数。（左操作数一定是类的对象，而且c++对这四个运算符有强制规定）</p></li><li class="lvl-7"><p>类型转换函数只能被定义为一个类的成员函数而不能是友元函数。（因为转换的主体只能是本类的对象）</p></li><li class="lvl-7"><p>如一个运算符需要修改对象的状态，则重载为成员函数最好。</p><p>（原因解释：此时若重载为友元函数，参数只能是引用参数，值传递无法影响原对象，指针会导致二义性，不如使用成员函数重载）</p></li></ol></li><li class="lvl-4"><p>友元函数：</p><p>核心：如果成员函数*this要作为右操作数,，只能将operator作为友元函数。</p><ol><li class="lvl-7"><p>一般情况下，双目运算符最好重载为类的友元函数。（因为左操作数一般不一定是类对象，而且运算符常常需要可交换性）</p></li><li class="lvl-7"><p>双目运算符&lt;&lt;和&gt;&gt;只能被重载为类的友元函数。（其左操作数通常不是该类对象）</p></li><li class="lvl-7"><p>当需要重载运算符具备可交换性时，选择重载为友元函数。</p></li><li class="lvl-7"><p>如果左右操作符数据类型不同，选择重载为友元函数。</p></li><li class="lvl-7"><p>如果左边的操作数必须是一个不同类的对象，或者是一个内部类型的对象，即需要对左边的操作数进行隐式的类型转换，该运算符重载函数必须作为友元函数实现。</p></li></ol></li></ul></li></ul><h4 id="五运算符重载的特殊情况"><a href="#五运算符重载的特殊情况" class="header-anchor">¶</a>（五）运算符重载的特殊情况：</h4><p>关系运算符的重载是成对的，&lt;和&gt;、&lt;=和&gt;=、==和!=要成对进行重载。</p><p>&amp;&amp; ||和 , 运算符在重载时对算子的操作顺序无法保留（原有的短路求值属性消失了），不推荐对这三个运算符进行重载。</p>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>V2rayNG入门使用介绍</title>
    <link href="/xiaohei07.github.io/2023/03/24/V2rayNG%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/xiaohei07.github.io/2023/03/24/V2rayNG%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一引言"><a href="#一引言" class="header-anchor">¶</a>（一）引言：</h3><p>本篇尽量位于v2rayN之后阅读。</p><p>前篇指路——<a href="https://07xiaohei.com/2023/03/18/v2rayN%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/">v2rayN入门使用介绍</a></p><p>v2rayNG和v2rayN不同的是它是用于你的安卓系统的。</p><p>本文章是在电脑上下载v2rayNG的，如果你有需要可以在手机上下载该软件，安装后直接使用（操作过程更简单）。</p><p>v2rayNG可以和v2rayN使用相同的订阅，但是要注意分享链接的时候尽量不要直接在你的微信orQQ上直接将复制链接粘贴，可以加一个txt文件存储复制链接然后传输txt文件。</p><p>本文仍为图文搭建：</p><h3 id="二下载和安装"><a href="#二下载和安装" class="header-anchor">¶</a>（二）下载和安装：</h3><p>还是找到2dust大神：</p><p><img src="https://s1.ax1x.com/2023/03/18/ppJl8N4.jpg" alt="ppJl8N4.jpg"></p><p>如果你懒得去找，直接点击这个链接即可：<a href="https://github.com/2dust/v2rayNG">v2rayNG下载</a>。(重复：请放心，链接绝对无害，只是有可能不稳定~ github只用国内链接访问懂得都懂)。</p><p>进入页面后，先不要直接找到链接就下载，先点击右侧releases下面的Lastest版本（如果你会使用github且对预发布版本感兴趣可以直接点releases下载最新预发布版本，看不懂的括号内内容当不存在就行）。</p><p><img src="https://s1.ax1x.com/2023/03/26/ppr1La4.png" alt="屏幕截图 2023-03-26 104817"></p><p>截止到我更新的日期，最新发布版本是1.7.38</p><p>进入其页面后，页面靠下方位置有一个Assets(7)</p><p><img src="https://s1.ax1x.com/2023/03/26/ppr1TMV.png" alt="屏幕截图 2023-03-26 101858"></p><p>我们点击第一个apk包下载即可。（apk就是安卓安装包的后缀，可能有点小卡，无伤大雅）</p><p>将该安装包下载后直接传到手机上进行安装即可。（一般不会报告安全警告，如果报告了无视即可）</p><h3 id="三界面和功能介绍"><a href="#三界面和功能介绍" class="header-anchor">¶</a>（三）界面和功能介绍：</h3><p>安装完成后点击v2rayNG,进入如下页面，各个功能的简介如下。</p><img src="https://s1.ax1x.com/2023/03/26/ppr8LC9.jpg" alt="微信图片_20230326110053" style="zoom: 33%;"><p>最右上角详细功能如下：</p><ul class="lvl-0"><li class="lvl-2"><p>服务重启：重新开启服务。</p></li><li class="lvl-2"><p>删除全部配置：将你使用的配置代理全部KO。</p></li><li class="lvl-2"><p>导出全部配置至剪贴板（发给别人就可以用了）。</p></li><li class="lvl-2"><p>测试：略（试试你就知道了）</p></li><li class="lvl-2"><p>排序：将最好的排在上面。</p></li><li class="lvl-2"><p>更新订阅：建议每次使用都可以更新一下。</p></li></ul><img src="C:/Users/Lenovo/Pictures/Screenshots/only_bolg/微信图片_20230326110703.jpg" alt="微信图片_20230326110703" style="zoom: 33%;"><p>过滤配置文件功能如图：</p><img src="https://s1.ax1x.com/2023/03/26/ppr8xu6.jpg" alt="微信图片_20230326110709" style="zoom:33%;"><p>导入功能如下：</p><p>注意v2rayNG支持Vmess、VLESS、SOCKS和Trojan的代理，也支持Shadowrockets的代理。</p><img src="https://s1.ax1x.com/2023/03/26/pprGSHO.jpg" alt="微信图片_20230326110716" style="zoom:33%;"><p>侧边栏功能如下：</p><p>设置中可以改语言和一些配置，可以从推广获得一些链接。</p><img src="https://s1.ax1x.com/2023/03/26/pprGFCd.jpg" alt="微信图片_20230326110720" style="zoom:33%;"><h3 id="四总结和更进一步的推荐"><a href="#四总结和更进一步的推荐" class="header-anchor">¶</a>（四）总结和更进一步的推荐：</h3><p>本文章只是对v2ray的一个初步介绍，许多配置的修改并未说明，只是一个入门级的介绍。</p><p>随着各位水平的深入，会发现我所讲的这些都是皮毛，到时候更多的内容，就需要你们自己去探索和发掘啦~</p><p>下面列举一些可能各位感兴趣的深入了解的推荐：</p><p><a href="https://www.linuxv2ray.com/">2022最新V2Ray搭建配置教程及V2Ray一键安装脚本</a> 可以学习一下怎么自己搭建服务器等等。</p><p><a href="https://v2rayng.org/">2022最新v2rayNG使用教程配置从入门到精通</a> v2rayNG官网，内容不止于使用，也会有许多简单的科普，强烈建议没有基础知识的人看看。</p><p>最后，祝各位使用愉快，能够看到更广阔的世界！！</p>]]></content>
    
    
    <categories>
      
      <category>生活寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ladder</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法——分治算法(2)</title>
    <link href="/xiaohei07.github.io/2023/03/24/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95(2)/"/>
    <url>/xiaohei07.github.io/2023/03/24/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95(2)/</url>
    
    <content type="html"><![CDATA[<p>例子均使用c++实现。</p><h3 id="一汉诺塔问题"><a href="#一汉诺塔问题" class="header-anchor">¶</a>（一）汉诺塔问题：</h3><h4 id="1-问题"><a href="#1-问题" class="header-anchor">¶</a>1. 问题：</h4><p>汉诺塔问题是一个经典的问题。该问题是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置n个盘子。</p><p>问题的目标是把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。</p><p>操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。</p><h4 id="2-基本思想"><a href="#2-基本思想" class="header-anchor">¶</a>2. 基本思想：</h4><p>假设共需要移动A柱的n个盘子。</p><p>首先考虑最大的盘子，如果移到B柱，未来仍需要移动到C柱，等于直接从A柱移到C柱，所以可以省略无用的这一步，直接从A-&gt;C，那么其他的n-1个盘子应当为其腾出空间移动，移动至B柱，否则此步无法进行。等待最大的移动到C柱之后将这n-1个盘子其移动到C柱，而此过程可以看作新的汉诺塔问题：从B柱到C柱移动n-1个盘子，问题性质不变.......直到只剩最小的盘子，此时可以直接移到C柱，问题的解是显然的。</p><p>由上面的过程和性质，汉诺塔问题显然可以分治解决，将一个复杂的N问题一步步分解为子问题，直到变成1问题，1问题的解是直观的，再逐步合并子问题，得到原问题的解。</p><h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="header-anchor">¶</a>3. 时间复杂度：</h4><p>设盘子个数为n时，需要T(n)步，把A柱子n-1个盘子移到B柱子，需要T(n-1)步，而A柱子最后一个盘子移到C柱子1步，B柱子上n-1个盘子移到C柱子上T(n-1)步。进而可得公式：</p><p><em><strong>T(n）=2T(n-1)+1</strong></em></p><p>所以汉诺塔问题的时间复杂度为<em><strong>O(2<sup>n</sup>)</strong></em>;</p><h4 id="4-代码"><a href="#4-代码" class="header-anchor">¶</a>4. 代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//b为辅助的那根柱子，a为盘子所在的柱子，c为要移动到的柱子</span><br><span class="hljs-comment">//盘子顺序由小到大排序，最小的为第一个盘子</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tower_of_Hanoi</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b, <span class="hljs-type">char</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;第1个盘子由&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; c &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">tower_of_Hanoi</span>(n - <span class="hljs-number">1</span>, a, c, b);   <span class="hljs-comment">//将A柱的n-1个盘子借助C移向B</span><br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;个盘子由&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span> &lt;&lt; c &lt;&lt; endl;   <span class="hljs-comment">//将A柱的最小的盘子移向C</span><br><span class="hljs-built_in">tower_of_Hanoi</span>(n - <span class="hljs-number">1</span>, b, a, c);   <span class="hljs-comment">//将B柱的n-1个盘子借助A移向C</span><br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">tower_of_Hanoi</span>(<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果:(仅展示n=4的结果，否则太长了)</span><br><span class="hljs-comment">//第1个盘子由A-&gt;B</span><br><span class="hljs-comment">//第2个盘子由A-&gt;C</span><br><span class="hljs-comment">//第1个盘子由B-&gt;C</span><br><span class="hljs-comment">//第3个盘子由A-&gt;B</span><br><span class="hljs-comment">//第1个盘子由C-&gt;A</span><br><span class="hljs-comment">//第2个盘子由C-&gt;B</span><br><span class="hljs-comment">//第1个盘子由A-&gt;B</span><br><span class="hljs-comment">//第4个盘子由A-&gt;C</span><br><span class="hljs-comment">//第1个盘子由B-&gt;C</span><br><span class="hljs-comment">//第2个盘子由B-&gt;A</span><br><span class="hljs-comment">//第1个盘子由C-&gt;A</span><br><span class="hljs-comment">//第3个盘子由B-&gt;C</span><br><span class="hljs-comment">//第1个盘子由A-&gt;B</span><br><span class="hljs-comment">//第2个盘子由A-&gt;C</span><br><span class="hljs-comment">//第1个盘子由B-&gt;C</span><br></code></pre></td></tr></table></figure><h3 id="二有序二分查找问题"><a href="#二有序二分查找问题" class="header-anchor">¶</a>（二）有序二分查找问题：</h3><h4 id="1-问题"><a href="#1-问题" class="header-anchor">¶</a>1. 问题：</h4><p>在某一个有序序列内查找某个值是否存在。</p><h4 id="2-基本思想"><a href="#2-基本思想" class="header-anchor">¶</a>2. 基本思想：</h4><p>二分查找算法，也称折半搜索算法、对数搜索算法，是一种在有序数组中查找某一特定元素的分治搜索算法。</p><p>二分查找算法有许多中变种。比如分散层叠可以提升在多个数组中对同一个数值的搜索，指数搜索将二分查找算法拓宽到无边界的列表。二叉搜索树和B树数据结构就是基于二分查找算法的。</p><p>二分查找算法的搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>我们假设查询对象是一个名为array的数组，且为升序排序，使用变量left表示查找范围的左边界，right表示右边界，mid表示中间位置(向下取整)，value为要查找的元素。二分查找算法的实现过程如下：</p><ol><li class="lvl-3"><p>初始化数组array的值(有序升序排序)。</p><p>left=0，指向array[ ]的第一个元素。</p><p>right=array.length-1，指向数组array[ ]的最后一个元素。</p><p>mid=(left+right) / 2，即指向查找范围的中间元素，且向下取整。</p></li><li class="lvl-3"><p>判定 left&lt;=right是否成立，如果不成立，算法结束，说明该列表中没有指定元素。</p></li><li class="lvl-3"><p>如果2中判断成立，比较value和 array[mid] 。如果 value == array[mid] ，搜索成功，算法结束，返回相对应的位置或者布尔值；如果 value &gt;array[mid] ，令 left=mid+1，并更新<em><strong>mid=(left+right) / 2</strong></em>，继续在数组的后半部分进行搜索，重复2和3步即可；如果 value &lt;array[mid] ，令 right=mid-1，同样更新mid，继续在数组的前半部分进行搜索，重复2和3步即可。</p></li></ol><h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="header-anchor">¶</a>3. 时间复杂度：</h4><p>二分查找每次会使得查找区间缩小一半，从n到n/2，n/4，…，n/2^k。</p><p>k为循环的次数，最坏情况下k次二分之后在区间长度为1时找到了需要的元素。</p><p>则有：<em><strong>n/2<sup>k</sup>=1</strong></em> ，可得 <em><strong>k=log<sub>2</sub>n</strong></em>，</p><p>故复杂度为 <em><strong>O(logn)</strong></em>;</p><p>二分查找算法在一般情况下的复杂度是对数时间并使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。</p><p>除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。尽管特定的、为了快速搜索而设计的数据结构更有效（比如哈希表），但二分查找算法应用面更广。</p><h4 id="4-代码"><a href="#4-代码" class="header-anchor">¶</a>4. 代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//用随机数测试二分查找（小范围，少数量）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search_binary</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;v, <span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = v.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid = left + right &gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (left &lt;= right)<br>&#123;<br><span class="hljs-keyword">if</span> (v[mid] == value)<br>&#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; v[mid])<br>&#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>left = mid + <span class="hljs-number">1</span>;<br>&#125;<br>mid = left + right &gt;&gt; <span class="hljs-number">1</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;未查询到结果!!!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::default_random_engine e;<br><span class="hljs-function">std::uniform_int_distribution&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">200</span>)</span></span>;<br>e.<span class="hljs-built_in">seed</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>vector&lt;<span class="hljs-type">int</span>&gt;v;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) <br>&#123;<br><span class="hljs-type">int</span> j = <span class="hljs-built_in">u</span>(e);<br>v.<span class="hljs-built_in">push_back</span>(j); <br>&#125;<br><span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(),v.<span class="hljs-built_in">end</span>());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>cout &lt;&lt; <span class="hljs-built_in">search_binary</span>(v, <span class="hljs-number">50</span> + i) &lt;&lt; endl;;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果随机</span><br></code></pre></td></tr></table></figure><h3 id="三归并排序"><a href="#三归并排序" class="header-anchor">¶</a>（三）归并排序：</h3><h4 id="1-问题"><a href="#1-问题" class="header-anchor">¶</a>1. 问题：</h4><h4 id="2-基本思想"><a href="#2-基本思想" class="header-anchor">¶</a>2. 基本思想：</h4><h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="header-anchor">¶</a>3. 时间复杂度：</h4><h4 id="4-代码"><a href="#4-代码" class="header-anchor">¶</a>4. 代码：</h4><h3 id="四快速排序"><a href="#四快速排序" class="header-anchor">¶</a>（四）快速排序：</h3><h4 id="1-问题"><a href="#1-问题" class="header-anchor">¶</a>1. 问题：</h4><h4 id="2-基本思想"><a href="#2-基本思想" class="header-anchor">¶</a>2. 基本思想：</h4><h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="header-anchor">¶</a>3. 时间复杂度：</h4><h4 id="4-代码"><a href="#4-代码" class="header-anchor">¶</a>4. 代码：</h4><h3 id="五线性时间选择无序二分查找"><a href="#五线性时间选择无序二分查找" class="header-anchor">¶</a>（五）线性时间选择（无序二分查找）：</h3><h4 id="1-问题"><a href="#1-问题" class="header-anchor">¶</a>1. 问题：</h4><p>给定线性序集中n个元素（元素不重复）和一个整数k，1≤k≤n，要求找出这n个元素中第k小的元素。</p><h4 id="2-基本思想"><a href="#2-基本思想" class="header-anchor">¶</a>2. 基本思想：</h4><p>使用线性时间选择算法Select()，此方法实际上是从快速排序方法上改进而来的。</p><p>此算法常使用的场景是：找出待排序序列中， 第k大或第k小元素(1&lt;k&lt;n)。此种算法常用于待排序序列&gt;75时，因为元素个数75时，时间复杂度很低，可以直接进行冒泡排序返回arr[n-k+1]。</p><p>步骤为：</p><ol><li class="lvl-3"><p>将n个输入元素划分成n/5（向上取整）个组，每组5个元素，最多只可能有一个组不是5个元素。用任意一种排序算法，将每个元素数量为5的组的元素排好序，同时依次将每组的中位数（第三小的元素）与该序列进行元素交换到序列最前方（以便于后续求中位数的中位数），中位数数量共n/5（向下取整）个。</p></li><li class="lvl-3"><p>求出序列开始处这n/5（向下取整）个元素的中位数。如果n/5（向下取整）是偶数，就找它的2个中位数中较大的一个。</p></li><li class="lvl-3"><p>将这个最终的中位数交换到序列最开始的地方，并以这个元素作为划分基准，遍历全序列进行划分，用两个指针从开始处和结尾处不断将前面比这个元素大的和后面比这个元素小的数进行交换（优先移动后面的指针，这样保证两个指针相遇时指向的值比划分元素小），直到两个指针相遇，随后将划分元素和指针指向的元素交换。</p><img src="https://s1.ax1x.com/2023/04/05/pp57e58.png" style="zoom:80%;"></li><li class="lvl-3"><p>此时根据此划分元素位置pos可以确定其为第pos+1小的元素，进行pos+1和k的比较，如果相等，返回划分元素即为答案；如果k&lt;pos+1，对划分元素左侧进行递归处理（即为子问题），如果k&gt;pos+1,对划分元素右侧进行递归处理。</p></li></ol><h4 id="3-时间复杂度"><a href="#3-时间复杂度" class="header-anchor">¶</a>3. 时间复杂度：</h4><p>线性时间选择算法划分的基准是固定的，可以在线性时间内找到一个划分基准并完成划分。</p><p>对于线性时间选择算法每次选择的划分元素，能够确定比划分元素大的数包括比它大的中位数，和这些中位数所在组的比这些中位数大的数，约占整个数组的3/10（1/2*3/5），确定比划分元素小的数的数量同理。——这也就是说，即使在最恶劣的情况下，也可以每次丢弃3/10的元素进行子问题的递归处理。</p><p>由此可得复杂度的递推公式：</p><p><em><strong>T(n) = T(3n/10)+O(n)</strong></em></p><p>由主方法，可解得</p><p><em><strong>T(n) =O(n)</strong></em></p><h4 id="4-代码"><a href="#4-代码" class="header-anchor">¶</a>4. 代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//冒泡排序：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp;a, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = p; i &lt; r; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= r; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[j] &lt; a[i])<br><span class="hljs-built_in">swap</span>(a[i], a[j]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//根据划分元素调整容器元素的位置，返回划分元素对应位置。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> val)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> pos=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q = p; q &lt;= r; q++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[q] == val)<br>&#123;<br>pos = q;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(a[p], a[pos]);<br><span class="hljs-type">int</span> midmidpos;<br><span class="hljs-type">int</span> i = p, j = r + <span class="hljs-number">1</span>, midmid = a[p];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">while</span> (a[--j] &gt; midmid &amp;&amp; j &gt; p<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">while</span> (a[++i] &lt; midmid);<br><span class="hljs-keyword">if</span> (i &gt;= j) &#123; <span class="hljs-keyword">break</span>; &#125;<br><span class="hljs-built_in">swap</span>(a[i], a[j]);<br>&#125;<br>a[p] = a[j];<br>a[j] = midmid;<br>midmidpos = j;<br><span class="hljs-keyword">return</span> midmidpos;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Select</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;a, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (r - p &lt; <span class="hljs-number">75</span>)<br>&#123;<br><span class="hljs-built_in">bubbleSort</span>(a, p, r);<br><span class="hljs-keyword">return</span> a[p + k - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//找中位数的中位数，r-p-4即上面所说的n-5</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= (r - p - <span class="hljs-number">4</span>) / <span class="hljs-number">5</span>; i++) <span class="hljs-comment">//把每个组的中位数交换到区间[p,p+(r-p-4)/4]</span><br>&#123;<br><span class="hljs-type">int</span> s = p + <span class="hljs-number">5</span> * i, t = s + <span class="hljs-number">4</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) <span class="hljs-comment">//冒泡排序，从后开始排，结果使得后三个数是排好顺序的（递增）</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = s; n &lt; t - j; n++)<br>&#123;<br><span class="hljs-keyword">if</span> (a[n] &gt; a[n + <span class="hljs-number">1</span>])<br><span class="hljs-built_in">swap</span>(a[n<span class="hljs-number">+1</span>], a[n]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">swap</span>(a[p + i], a[s + <span class="hljs-number">2</span>]);<span class="hljs-comment">//交换每组中的中位数到前面</span><br>&#125;<br><span class="hljs-comment">//(r-p-4)/5表示组数-1，则[p,p+(r-p-4)/5]</span><br><span class="hljs-comment">//求中位数的中位数 (r-p+1)/10 = (p+(r+p-4)/5-p+1)/2</span><br><span class="hljs-type">int</span> midmid = <span class="hljs-built_in">Select</span>(a, p, p + (r - p - <span class="hljs-number">4</span>) / <span class="hljs-number">5</span>, (r - p + <span class="hljs-number">1</span>) / <span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> midmidpos = <span class="hljs-built_in">Partition</span>(a, p, r, midmid);<br><span class="hljs-type">int</span> realmidmidpos = midmid - p + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (k &lt;= realmidmidpos)<span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a, p, midmidpos<span class="hljs-number">-1</span>, k);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Select</span>(a, midmidpos + <span class="hljs-number">1</span>, r , k - realmidmidpos);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x;<br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">1000</span>;i++)<br>&#123;<br>a.<span class="hljs-built_in">push_back</span>(i);<br>&#125;<br><span class="hljs-built_in">random_shuffle</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//容器a的大小为1000,值为1-1000的随机数。</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">15</span>;i++)<br>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; aa = a;<br><span class="hljs-comment">//可以找需要的第几小的数，可以在0-999的范围内随意找</span><br>cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;小的数是:&quot;</span> &lt;&lt; <span class="hljs-built_in">Select</span>(aa,<span class="hljs-number">0</span>,<span class="hljs-number">777</span>,i<span class="hljs-number">+1</span>)&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//运行结果：</span><br><span class="hljs-comment">//第1小的数是:2</span><br><span class="hljs-comment">//第2小的数是 : 5</span><br><span class="hljs-comment">//第3小的数是 : 6</span><br><span class="hljs-comment">//第4小的数是 : 9</span><br><span class="hljs-comment">//第5小的数是 : 10</span><br><span class="hljs-comment">//第6小的数是 : 11</span><br><span class="hljs-comment">//第7小的数是 : 12</span><br><span class="hljs-comment">//第8小的数是 : 13</span><br><span class="hljs-comment">//第9小的数是 : 14</span><br><span class="hljs-comment">//第10小的数是 : 16</span><br><span class="hljs-comment">//第11小的数是 : 18</span><br><span class="hljs-comment">//第12小的数是 : 21</span><br><span class="hljs-comment">//第13小的数是 : 22</span><br><span class="hljs-comment">//第14小的数是 : 23</span><br><span class="hljs-comment">//第15小的数是 : 24</span><br></code></pre></td></tr></table></figure><h3 id="六大整数乘法"><a href="#六大整数乘法" class="header-anchor">¶</a>（六）大整数乘法：</h3><h3 id="七strassen矩阵乘法"><a href="#七strassen矩阵乘法" class="header-anchor">¶</a>（七）Strassen矩阵乘法：</h3><h3 id="八循环赛日程表"><a href="#八循环赛日程表" class="header-anchor">¶</a>（八）循环赛日程表：</h3><h3 id="九最近点对问题"><a href="#九最近点对问题" class="header-anchor">¶</a>（九）最近点对问题：</h3><h3 id="十棋盘覆盖"><a href="#十棋盘覆盖" class="header-anchor">¶</a>（十）棋盘覆盖：</h3>]]></content>
    
    
    <categories>
      
      <category>algorithm_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(六)集合</title>
    <link href="/xiaohei07.github.io/2023/03/23/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AD)%E9%9B%86%E5%90%88/"/>
    <url>/xiaohei07.github.io/2023/03/23/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%85%AD)%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><p>集合set是一个无序的唯一确定元素序列。</p><p>无序代表着其每次输出时元素的排列顺序可能都不相同。</p><p>唯一确定意味着元素是不可重复的，且每个元素互不相同。</p><p>元素的个数无限制。</p><p>set是可变数据类型，其内容是可以改变的，因此set没有哈希值，不能被用作字典的键或是其他集合的元素。</p><p>同一集合中，只能存储不可变的数据类型，不能再存储列表、set集合、字典等可变数据类型元素，因此set集合没有多维形式。（代码见(二)内代码）</p><h3 id="二创建与形式"><a href="#二创建与形式" class="header-anchor">¶</a>（二）创建与形式：</h3><p>python用{}大括号表示set集合，并用逗号分隔元素。</p><p>形式为： <em><strong>setname = { element1 , element2 , ... , elementn }</strong></em></p><p>注意：set没有直接的空集合创建形式。因为直接用{}创建表示的是空字典，而不是空列表，此时应使用***set()***表示空集合。</p><p>set创建时若有重复元素，只保留其中一个。（备注：列表去除重复元素最迅速的方法就是转为集合，其运行时间远小于其他去重方法）</p><p>set集合内的bool值True不会被创建，只有False才会被创建（不知道为什么）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = &#123;1 , <span class="hljs-string">&quot;a&quot;</span> , 3.14 , <span class="hljs-literal">True</span> &#125;<br>b = &#123;&#125;<br>bb = <span class="hljs-built_in">set</span>()<br>c = &#123;1 , 1 , <span class="hljs-string">&quot;a&quot;</span> , <span class="hljs-string">&quot;a&quot;</span> , 3.14 , 3.14 , <span class="hljs-literal">False</span> , <span class="hljs-literal">True</span>&#125;<br><span class="hljs-comment"># d = &#123;[1,2,3],1,2,3&#125; 此句会运行失败，因为不允许在set集合内创建列表。</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(type(a))<br><span class="hljs-built_in">print</span>(type(b))<br><span class="hljs-built_in">print</span>(type(bb))<br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;&#x27;a&#x27;, 1, 3.14&#125;</span><br><span class="hljs-comment"># &lt;class &#x27;set&#x27;&gt;</span><br><span class="hljs-comment"># &lt;class &#x27;dict&#x27;&gt;</span><br><span class="hljs-comment"># &lt;class &#x27;set&#x27;&gt;</span><br><span class="hljs-comment"># &#123;&#x27;a&#x27;, 1, 3.14, False&#125;</span><br></code></pre></td></tr></table></figure><h3 id="三集合的特性"><a href="#三集合的特性" class="header-anchor">¶</a>（三）集合的特性：</h3><h4 id="1-访问元素"><a href="#1-访问元素" class="header-anchor">¶</a>1. 访问元素：</h4><p>set集合因其无序，没有索引和下标，一般情况下访问元素只能通过遍历和枚举逐一读取（枚举中会有索引值，但不意味着set有索引）。</p><p>遍历一般会使用in关键字。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = &#123;1,2,3,4,<span class="hljs-literal">True</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> enumerate(a):<br><span class="hljs-built_in">print</span>(i,<span class="hljs-string">&quot; &quot;</span>,v,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(i,<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 0   1</span><br><span class="hljs-comment"># 1   2</span><br><span class="hljs-comment"># 2   3</span><br><span class="hljs-comment"># 3   4</span><br><span class="hljs-comment"># 4   d</span><br><span class="hljs-comment"># 5   a</span><br><span class="hljs-comment"># 6   b</span><br><span class="hljs-comment"># 7   c</span><br><span class="hljs-comment"># 1 2 3 4 d a b c </span><br></code></pre></td></tr></table></figure><h4 id="2-删除集合"><a href="#2-删除集合" class="header-anchor">¶</a>2. 删除集合</h4><p>python自带垃圾回收机制，已创建的集合如不再使用，将会被编译器自动回收，不会产生内存垃圾。</p><p>如果需要可以手动删除，使用del 关键字手动删除集合。</p><p>形式为： <em><strong>del setname</strong></em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">del</span> a<br><span class="hljs-attribute">print</span>(a) #此句无法输出，因为a已经被删除了，a变量处于未定义状态<br></code></pre></td></tr></table></figure><h4 id="3-集合的关系"><a href="#3-集合的关系" class="header-anchor">¶</a>3. 集合的关系：</h4><ul class="lvl-0"><li class="lvl-2"><p>判断子集关系：</p><ul class="lvl-2"><li class="lvl-4"><p>使用关系运算符&lt; 、&lt;=、&gt;、&gt;=(用rop指代)：</p><p>形式：<em><strong>setname1 rop setname2</strong></em></p><p>返回True或者False</p><p>当rop为&lt;=，表示子集判断，即当setname1中元素均在setname2中出现时，表示集合1为集合2子集，返回True；否则返回False。</p><p>当rop为&lt;，表示真子集判断，即当setname1中元素均在setname2中出现且setname2有setname1中没有的元素时，表示集合1为集合2真子集，返回True，否则均返回False。</p><p>&gt;=和&gt;的逻辑和前两者相同，但是setname1和setname2的地位互换，表示setname1对setname2的包含和真包含关系。</p></li><li class="lvl-4"><p>使用方法：</p><ol><li class="lvl-7"><p>issubset方法：</p><p>形式：<em><strong>setname1.issubset(setname2)</strong></em></p><p>与<em><strong>setname1&lt;=setname2</strong></em>等价。</p></li><li class="lvl-7"><p>issuperset方法：</p><p>形式：<em><strong>setname1.issuperset(setname2)</strong></em></p><p>与<em><strong>setname&gt;=setname2</strong></em>等价。</p></li></ol></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">b</span> = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br><span class="hljs-attribute">c</span> = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">print</span>(b&lt;a,b&gt;a,b&lt;=a,b&gt;=a,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-attribute">print</span>(c&lt;a,c&gt;a,c&lt;=a,c&gt;=a,sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-attribute">print</span>(b.issubset(a),c.issubset(a),sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-attribute">print</span>(b.issuperset(a),c.issuperset(a),sep=<span class="hljs-string">&quot;\t&quot;</span>)<br><span class="hljs-comment"># True False TrueFalse</span><br><span class="hljs-comment"># False False TrueTrue</span><br><span class="hljs-comment"># True True</span><br><span class="hljs-comment"># False True</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>集合运算方法：</p><ul class="lvl-2"><li class="lvl-4"><p>交集运算：</p><p>形式：<em><strong>setname1&amp;setname2</strong></em> / <em><strong>setname1.intersection(setname2)</strong></em></p><p>两个集合可以交换位置，生成结果相同。</p><p>生成一个新集合获得两个集合的所有公共元素。</p><p>可以进行多个集合的连续交运算。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">c</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">print</span>(a&amp;b)<br><span class="hljs-attribute">print</span>(a.intersection(b))<br><span class="hljs-attribute">print</span>(b.intersection(a))<br><span class="hljs-attribute">print</span>(a&amp;b&amp;c)<br><span class="hljs-attribute">print</span>(c.intersection(a,b))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;3, 4, 5&#125;</span><br><span class="hljs-comment"># &#123;3, 4, 5&#125;</span><br><span class="hljs-comment"># &#123;3, 4, 5&#125;</span><br><span class="hljs-comment"># &#123;3, 5&#125;</span><br><span class="hljs-comment"># &#123;3, 5&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>并集运算：</p><p>形式：<em><strong>setname1 | setname2</strong></em> / <em><strong>setname1.union(setname2)</strong></em></p><p>两个集合可以交换位置，生成结果相同。</p><p>生成一个新集合获得两个集合的所有元素，且不重复。</p><p>可以进行多个集合的连续并运算。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">c</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">print</span>(a|b)<br><span class="hljs-attribute">print</span>(a.union(b))<br><span class="hljs-attribute">print</span>(b.union(a))<br><span class="hljs-attribute">print</span>(a|b|c)<br><span class="hljs-attribute">print</span>(c.union(a,b))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6, 7&#125;</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>差集运算：</p><p>形式：<em><strong>setname1 - setname2</strong></em> / <em><strong>setname1.difference(setname2)</strong></em></p><p>两个集合可以交换位置，但是生成结果会不同。</p><p>生成一个集合获得setname1中所有不在setname2中出现的元素，即新集合和setname2的交集一定为空集。</p><p>可以进行多个集合的差集运算，得到的是该集合去除其他所有集合含有元素之后的剩余元素。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">c</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">print</span>(a-b)<br><span class="hljs-attribute">print</span>(b-a)<br><span class="hljs-attribute">print</span>(a.difference(b))<br><span class="hljs-attribute">print</span>(b.difference(a))<br><span class="hljs-attribute">print</span>(c-a-b)<br><span class="hljs-attribute">print</span>(c.difference(a,b))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;1, 2&#125;</span><br><span class="hljs-comment"># &#123;6, 7&#125;</span><br><span class="hljs-comment"># &#123;1, 2&#125;</span><br><span class="hljs-comment"># &#123;6, 7&#125;</span><br><span class="hljs-comment"># &#123;8, 9&#125;</span><br><span class="hljs-comment"># &#123;8, 9&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>对称差集运算：</p><p>形式：<em><strong>setname1 ^ setname2</strong></em> / <em><strong>setname1.symmetric_difference(setname2)</strong></em></p><p>两个集合可以交换位置，生成结果相同。</p><p>生成一个集合获得setname1和setname2中不同时出现的元素，即新集合和两个集合的交集的交集一定为空集。</p><p>只能进行多个集合的连续对称差集运算，不能做同时的对称差集运算（也就是每次的运算对象只能有两个）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">c</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">print</span>(a^b)<br><span class="hljs-attribute">print</span>(a.symmetric_difference(b))<br><span class="hljs-attribute">print</span>(a^b^c)<br><span class="hljs-attribute">print</span>(c.symmetric_difference(a.symmetric_difference(b))) #不允许在symmetric_difference方法中加入多个参数。<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;1, 2, 6, 7&#125;</span><br><span class="hljs-comment"># &#123;1, 2, 6, 7&#125;</span><br><span class="hljs-comment"># &#123;3, 5, 8, 9&#125;</span><br><span class="hljs-comment"># &#123;3, 5, 8, 9&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>判断相交方法：</p><p>形式： <em><strong>setname1.isdisjoint(setname2)</strong></em></p><p>两个集合可以交换位置，生成结果相同。</p><p>两个集合交集为空时返回False，否则返回True(此时有公共元素)。</p><p>不允许连续集合相交判断或者多个集合同时相交判断。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">c</span>=&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125;<br><span class="hljs-attribute">print</span>(a.isdisjoint(b))<br><span class="hljs-attribute">print</span>(a.isdisjoint(c)) #isdisjoint方法只接受一个参数<br><span class="hljs-comment"># 运算结果：</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-集合的增删改查"><a href="#4-集合的增删改查" class="header-anchor">¶</a>4. 集合的增删改查：</h4><ul class="lvl-0"><li class="lvl-2"><p>向set集合添加元素：</p><p>set集合不支持重复和连接操作（也就是&quot;+&quot;和&quot;*&quot;运算符）。</p><ul class="lvl-2"><li class="lvl-4"><p>add方法：</p><p>形式：<em><strong>setname.add(element)</strong></em></p><p>只向set集合添加一个元素，只允许添加不可变类型。</p><p>添加已有元素不对集合进行任何操作。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">a</span>.add(<span class="hljs-number">6</span>)<br><span class="hljs-attribute">a</span>.add(<span class="hljs-number">1</span>)<br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>update方法：</p><p>形式：<em><strong>setname.update(elements)</strong></em></p><p>向set集合中添加传入update的一系列元素，只允许添加不可变类型。</p><p>添加已有元素不对集合进行任何操作。</p><p>update一般是传入另一个集合，会将其所有非公共元素分别加入setname中。</p><p>可以传入非集合的一系列字符串。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>&#125;<br><span class="hljs-attribute">a</span>.update(b)<br><span class="hljs-attribute">a</span>.update(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>)<br><span class="hljs-attribute">a</span>.update()<br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6, 7, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>交/差/对称差更新：</p><p>在其相关方法后加_update，不会返回新集合，而是直接将原集合替换为运算结果。（详细方法略，有兴趣请了解difference_update、intersection_update等函数）</p></li></ul></li><li class="lvl-2"><p>删除set集合元素：</p><ul class="lvl-2"><li class="lvl-4"><p>pop方法：</p><p>形式：<em><strong>setname.pop()</strong></em></p><p>pop方法从集合中移除并返回一个元素，此元素的选择是随机的。</p><p>注意：如果有一系列数字，从0开始删除，不是完全随机的。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a=&#123;<span class="hljs-string">&quot;a&quot;</span>,3,1,2,5,6,4,0&#125;<br>b=&#123;<span class="hljs-string">&quot;我&quot;</span>,<span class="hljs-string">&quot;你&quot;</span>,<span class="hljs-string">&quot;她&quot;</span>&#125;<br><span class="hljs-built_in">print</span>(a.pop())<br><span class="hljs-built_in">print</span>(a.pop())<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b.pop())<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 0</span><br><span class="hljs-comment"># 1</span><br><span class="hljs-comment"># &#123;2, 3, &#x27;a&#x27;, 5, 6, 4&#125;</span><br><span class="hljs-comment"># 你</span><br><span class="hljs-comment"># &#123;&#x27;她&#x27;, &#x27;我&#x27;&#125;、</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>remove方法：</p><p>形式：<em><strong>setname.remove(element)</strong></em></p><p>从集合中移除指定元素，如果该元素不存在会引发KeyError错误。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">a</span>.remove(<span class="hljs-number">1</span>)<br><span class="hljs-attribute">a</span>.remove(<span class="hljs-number">2</span>)<br><span class="hljs-comment"># a.remove(7) 此句会报错</span><br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>discard方法：</p><p>形式：<em><strong>setname.discard(element)</strong></em></p><p>和remove要求相同，但是在删除不存在元素时不会报错。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">a</span>.discard(<span class="hljs-number">1</span>)<br><span class="hljs-attribute">a</span>.discard(<span class="hljs-number">2</span>)<br><span class="hljs-attribute">a</span>.discard(<span class="hljs-number">7</span>) <br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># &#123;3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>clear方法：</p><p>形式：<em><strong>setname.discard()</strong></em></p><p>清空元素</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">a</span>.clear()<br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># set()</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>查询set集合元素</p><p>not in和in关键字。</p><p>使用形式不在赘述</p><p>注意：集合的查询时间是θ(1)，而列表的时间是θ(n)。</p></li></ul><h4 id="5集合的其他操作"><a href="#5集合的其他操作" class="header-anchor">¶</a>5.集合的其他操作：</h4><p>内置函数：</p><ol><li class="lvl-3"><p>len()求集合长度（即元素数量）。</p></li><li class="lvl-3"><p>max()求集合内元素最大值。</p></li><li class="lvl-3"><p>min()求集合内元素最小值。</p></li><li class="lvl-3"><p>sum()求集合元素之和(如果可以求出的话)。</p></li></ol><p>集合的复制：</p><p>集合的复制一般不考虑深浅拷贝。</p><ul class="lvl-0"><li class="lvl-2"><p>直接赋值：</p><p>= 直接赋值是非拷贝方法。</p><p>两个集合是等价的，修改其中任何一个集合都会影响另一个集合。（代码略）</p></li><li class="lvl-2"><p>集合推导式：</p><p>形式：<em><strong>setname1 = { i for i in setname2 }</strong></em></p><p>利用推导式完成复制。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">b</span>=&#123;i for i in a if i!=<span class="hljs-number">1</span>&#125;<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># &#123;2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>for循环：略</p></li><li class="lvl-2"><p>copy方法：</p><p>形式：<em><strong>setname1=setname2.copy()</strong></em></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">b</span>=a.copy()<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>deepcopy方法：</p><p>格式：<em><strong>setname1= copy.deepcopy(setname2)</strong></em></p><p>需要import copy库：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> copy<br><span class="hljs-attribute">a</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;<br><span class="hljs-attribute">b</span>=copy.deepcopy(a)<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span><br></code></pre></td></tr></table></figure></li></ul><p>排序：</p><p>sorted函数排序：略（有需要请看前面的内容）。</p><h4 id="四不可变集合frozenset"><a href="#四不可变集合frozenset" class="header-anchor">¶</a>（四）不可变集合frozenset ：</h4><p>和set相关，是不可变的，且为hashable，其元素一经创建无法更改。</p><p>可以用作字典的键或者其他集合的元素。</p><p>set中所有改变集合本身的方法都不支持（如add、remove方法等等），其余的方法都支持。</p><p>和set进行集合运算时，返回类型为运算左侧对象对应的类型。</p><p>如果set需要不可变就用frozenset来代替。</p><p>由元素创建时，frozenset必须由强制转化指定类型。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=frozenset(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;) #由强制转化创建<br><span class="hljs-attribute">b</span>=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>&#125; #可变<br><span class="hljs-attribute">print</span>(type(a&amp;b))<br><span class="hljs-attribute">print</span>(type(b&amp;a)) #和右边类型相同<br><span class="hljs-attribute">a</span>.issubset(b) #支持不改变集合的set的所用方法<br><span class="hljs-comment"># a.remove(1) 此句报错，frozenset没有改变元素的方法</span><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># &lt;class &#x27;frozenset&#x27;&gt;</span><br><span class="hljs-comment"># &lt;class &#x27;set&#x27;&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(五)元组</title>
    <link href="/xiaohei07.github.io/2023/03/22/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%94)%E5%85%83%E7%BB%84/"/>
    <url>/xiaohei07.github.io/2023/03/22/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%94)%E5%85%83%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><p>tuple元组是由一系列按特定顺序排序的元素组成的不可变的序列结构。</p><p>元组各种性质和列表是类似的（无限元素，任意类型，一个元组内可保存不同类型数据），但是元组保存的数据无法被修改（注意，如果保存了列表，那么不能修改指向的列表，但是可以修改指向列表的内容），也就没有了着增删改查等等操作。</p><p>通常而言，元组被用于需要同构数据的不可变序列的情况，或者存储异构数据的多项集。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-attribute">a</span>[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">4</span>   #元组内列表可修改<br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># (1, 2, 3, [1, 4, 3])</span><br></code></pre></td></tr></table></figure><h3 id="二创建形式"><a href="#二创建形式" class="header-anchor">¶</a>(二)创建形式：</h3><p>python用()表示列表，用逗号分隔元素。</p><p>用()包括所有元素不是必须的，如果将一串元素用逗号隔开不加括号，python编译器也会认为其为元组——决定该类型是否为元组的符号是逗号，而不是圆括号。</p><p>形式为：<em><strong>元组名=(元素1 , 元素2 , ...... , 元素n)</strong></em> / <em><strong>元组名=()</strong></em> / <em><strong>元组名=元素1, ...</strong></em></p><p>注意：如果仅有一个元素又想要生成元组，只需要在这个元素后面加一个逗号，python编译器就会将其解释为元组类型。（不加括号的情况下）</p><p>但是唯一元素时加小括号是不足够的，必须在该元素后面加一个逗号才能表示其为元组。（元组的判断关键在于逗号，而不是小括号）</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs clean">a=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4.22</span>,<span class="hljs-string">&quot;555&quot;</span>,[<span class="hljs-number">123</span>,<span class="hljs-number">321</span>])<br>b=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4.22</span>,<span class="hljs-string">&quot;555&quot;</span>,[<span class="hljs-number">123</span>,<span class="hljs-number">321</span>]    #可以不带括号<br>c=()  #空元组<br>d=<span class="hljs-number">1</span>,  #唯一元素的元组<br>e=(<span class="hljs-string">&quot;a&quot;</span>)  #此为字符串<br>f=<span class="hljs-string">&quot;a&quot;</span>,   #此为元组，关键在于后面的逗号<br>print(<span class="hljs-string">&quot;a:&quot;</span>,a,<span class="hljs-string">&quot;  type:&quot;</span>,type(a))<br>print(<span class="hljs-string">&quot;b:&quot;</span>,b,<span class="hljs-string">&quot;  type:&quot;</span>,type(b))<br>print(<span class="hljs-string">&quot;c:&quot;</span>,c,<span class="hljs-string">&quot;  type:&quot;</span>,type(c))<br>print(<span class="hljs-string">&quot;d:&quot;</span>,d,<span class="hljs-string">&quot;  type:&quot;</span>,type(d))<br>print(<span class="hljs-string">&quot;e:&quot;</span>,e,<span class="hljs-string">&quot;  type:&quot;</span>,type(e))<br>print(<span class="hljs-string">&quot;f:&quot;</span>,f,<span class="hljs-string">&quot;  type:&quot;</span>,type(f))<br># 输出结果：<br># a: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4.22</span>, <span class="hljs-string">&#x27;555&#x27;</span>, [<span class="hljs-number">123</span>, <span class="hljs-number">321</span>])   type: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br># b: (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4.22</span>, <span class="hljs-string">&#x27;555&#x27;</span>, [<span class="hljs-number">123</span>, <span class="hljs-number">321</span>])   type: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br># c: ()   type: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br># d: (<span class="hljs-number">1</span>,)   type: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br># e: a   type: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;str&#x27;</span>&gt;<br># f: (<span class="hljs-string">&#x27;a&#x27;</span>,)   type: &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;tuple&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h3 id="三元组的特性"><a href="#三元组的特性" class="header-anchor">¶</a>（三）元组的特性：</h3><h4 id="1-访问"><a href="#1-访问" class="header-anchor">¶</a>1. 访问：</h4><p>和列表的操作完全相同，不再赘述，详情请见：<a href="https://07xiaohei.com/2023/03/20/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%9B%9B)%E5%88%97%E8%A1%A8/">python基础——数据类型(四)列表</a></p><h4 id="2-删除"><a href="#2-删除" class="header-anchor">¶</a>2. 删除：</h4><p>python自带垃圾回收机制，已创建的元组如不再使用，将会被编译器自动回收，不会产生内存垃圾。</p><p>如果需要可以手动删除，使用del 关键字手动删除，详细方法同见上方。</p><h4 id="3-多维元组"><a href="#3-多维元组" class="header-anchor">¶</a>3. 多维元组：</h4><p>元组同样可以嵌套，和列表的性质相同。</p><p>注意：多维元组中除了含有列表时可修改列表内内容以外，任意元素不得修改。</p><h4 id="4-元组的主要操作"><a href="#4-元组的主要操作" class="header-anchor">¶</a>4. 元组的主要操作：</h4><p>无增删，只有改查。</p><ul class="lvl-0"><li class="lvl-2"><p>修改元组（不是修改元组元素！）：</p><p>如有列表元素，修改列表请见上文中的列表链接。</p><p>除此以外不可修改元素，只能进行替换和拼接。</p><ul class="lvl-2"><li class="lvl-4"><p>替换：</p><p>即重新赋值。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-attribute">a</span>=(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>)<br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># (4, 5, 6)</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>拼接：</p><p>实质上也是重新赋值。但是可以在某个/某些元组的基础上完成重新赋值。</p><p>&quot;+&quot;组合多个元组：</p><p>格式：<em><strong>tuplename = tuplename1+tuplename2+...+tuplenamen</strong></em></p><p>生成新的元组，元素顺序即按照所加顺序逐个元素填入新元组。</p><p>&quot;*&quot;重复n遍元组：</p><p>格式：<em><strong>tuplename= tuplename1</strong></em> ***** <em><strong>n</strong></em></p><p>生成新元组，将原元组元素重复n遍。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br><span class="hljs-attribute">b</span>=(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>)<br><span class="hljs-attribute">a</span> = a+b+a<br><span class="hljs-attribute">b</span> = b*<span class="hljs-number">4</span><br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5)</span><br><span class="hljs-comment"># (6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10, 6, 7, 8, 9, 10)</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>查询元素：</p><p>方法和列表相同，不再赘述。</p></li></ul><h4 id="5-元组的其他操作"><a href="#5-元组的其他操作" class="header-anchor">¶</a>5. 元组的其他操作：</h4><ul class="lvl-0"><li class="lvl-2"><p>获得最大，最小值以及长度：</p><p>分别为max()，min()和len()方法。</p><p>具体代码省略（有兴趣的自行尝试）。</p></li><li class="lvl-2"><p>sorted方法排序：</p><p>格式：<em><strong>sorted(iterable,</strong></em> ***** <em><strong>,key=None, reverse=False)</strong></em></p><p>元组没有内置的排序方法，只能使用python提供的sorted方法排序，sorted方法从一个可迭代对象根据iterable的项返回一个新的排序列表（注意不是元组）。</p><p>key：指定带有一个参数的函数，用于从每个序列元素中提取比较键。对应于传入序列中的每一项的键会被计算一次，然后在整个排序过程中使用，默认值None代表直接对序列项排序，不计算单独的键值。</p><p>reverse：为一个布尔值，默认False，表示升序排序，如果指定了True，则表示降序排序</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)<br><span class="hljs-attribute">b</span>=sorted(a,reverse=True)<br><span class="hljs-attribute">print</span>(b,<span class="hljs-string">&quot;   &quot;</span>,type(b))<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [5, 4, 3, 2, 1]     &lt;class &#x27;list&#x27;&gt;</span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>复制：</p><ul class="lvl-2"><li class="lvl-4"><p>直接赋值：</p><p>= 直接赋值是非拷贝方法。</p><p>两个元组是等价的，修改其中任何一个元组都会影响另一个元组。</p><p>注意和重新赋值区别（重新赋值不会影响另一个元组）。</p></li><li class="lvl-4"><p>使用切片（浅拷贝）：</p><p>格式：<em><strong>tuplenewname = tuplename[:]</strong></em></p><p>python中浅拷贝是指tuple保存的地址同样被复制过去，而不是创建新的地址复制值过去。</p><p>对嵌套的tuple只能对第一层实现深拷贝，而其内嵌套的tuple仍是浅拷贝。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">a = <span class="hljs-comment">[1,2,3,<span class="hljs-comment">[1,2,3]</span>]</span><br>b =a<span class="hljs-comment">[:]</span><br>a<span class="hljs-comment">[3]</span><span class="hljs-comment">[0]</span>=3<br>print(a)<br>print(b)<br># 输出结果：<br># <span class="hljs-comment">[1, 2, 3, <span class="hljs-comment">[3, 2, 3]</span>]</span><br># <span class="hljs-comment">[1, 2, 3, <span class="hljs-comment">[3, 2, 3]</span>]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>for循环（浅拷贝）：</p><p>此略（较简单）</p></li><li class="lvl-4"><p>元组生成式：</p><p>格式：<em><strong>tuplenewname = (i for i in tuplename )</strong></em></p><p>从形式上看，元组生成式和列表生成式类似，只是元组生成器推导式使用小括号，列表推导式直接生成列表对象，元组生成器推导式生成的不是列表又不是元组，而是一个生成器对象。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-attribute">b</span> = (i for i in a)<br><span class="hljs-attribute">a</span>[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-attribute">print</span>(tuple(b))<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># (1, 2, 3, [3, 2, 3])</span><br><span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x000001C8DFD89150&gt; 这是生成器</span><br><span class="hljs-comment"># (1, 2, 3, [3, 2, 3])</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>deepcopy方法（深拷贝）：</p><p>格式：<em><strong>tuplenewname= copy.deepcopy(tuplename)</strong></em></p><p>是深拷贝，原来的列表和新列表完全无关。</p><p>需要import copy库</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> copy<br><span class="hljs-attribute">a</span> = (<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br><span class="hljs-attribute">b</span> = copy.deepcopy(a)<br><span class="hljs-attribute">a</span>[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># (1, 2, 3, [3, 2, 3])</span><br><span class="hljs-comment"># (1, 2, 3, [1, 2, 3])</span><br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法——分治算法(1)</title>
    <link href="/xiaohei07.github.io/2023/03/21/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95(1)/"/>
    <url>/xiaohei07.github.io/2023/03/21/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95(1)/</url>
    
    <content type="html"><![CDATA[<h3 id="本文章只介绍理论下一篇讲解实例"><a href="#本文章只介绍理论下一篇讲解实例" class="header-anchor">¶</a>本文章只介绍理论，下一篇讲解实例！！</h3><h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念：</h3><p>分治法，即&quot;分而治之&quot;，意即将一个复杂的问题分解成若干个相同或者相似的子问题，再将这些子问题继续进行分解，直到产生足够简单能够直接求解的子问题。而对原问题的求解，就是对这些子问题的合并。</p><p>分治算法可以由递归过程来表示，因为分治法是大规模问题化为小规模问题的方法，是递归设计的一种具体策略。</p><p>因为计算机求解的计算时间往往与其规模有关，通过分治法来减少问题求解的规模，进而减少计算时间，对于大规模运算来说，是很重要的。</p><p>分治算法是很多高效算法的基础，如二分查找，归并和快速排序，大整数乘法，矩阵乘法，傅里叶变换等等。</p><h3 id="二基本思想和特征"><a href="#二基本思想和特征" class="header-anchor">¶</a>（二）基本思想和特征：</h3><p>分治策略：对于一个规模为n的问题，若可直接解决则直接解决，否则将其分解为k个规模较小的子问题，子问题之间要互相独立且与原问题形式相同，递归解决子问题后，可以将其合并得到原问题的解。</p><p>对这k个子问题，1&lt;k&lt;=n，且每个子问题是可以利用其子问题的解求出自身的解，进而求出原问题的解的。</p><p>互相独立是指子问题之间不能独自占用其公共的资源，产生问题间的冲突，也就是互不相交，互不影响。</p><p>形式相同是指其具有最优子结构，也就是大问题的最优解是由小问题的最优解组成的，不会出现非最优解的小问题合并出了最优解的大问题。</p><p>分治法的使用特征一般为：</p><ol><li class="lvl-3"><p>问题的规模缩小到一定的程度其最优解或唯一解是显然的。对于大多数问题，此特征是成立的。（问题复杂性一般随着问题规模增加）</p></li><li class="lvl-3"><p>问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。此特征是应用分治法的前提，大部分问题也可以满足此条件。（体现了递归思想）</p></li><li class="lvl-3"><p>利用该问题分解出的子问题的解可以合并为该问题的解。这是应用分治法的关键，能否利用分治法完全取决于是否具备此特征（如果具备前两个特征而不具备此特征，一般从动态规划和贪心算法的角度考虑）</p></li><li class="lvl-3"><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。此特征是分治法解决问题效率的关键，一般情况下，如果有重复的公共子问题，使用动态规划算法更好。</p></li></ol><h3 id="基本步骤"><a href="#基本步骤" class="header-anchor">¶</a>基本步骤：</h3><p>整体上，分治法是由不断的递归实现的。</p><p>对于每一层的递归分治法都有以下三个步骤：</p><ul class="lvl-0"><li class="lvl-2"><p>分解：将原问题分解为k个规模较小，相互独立，与原问题形式相同的子问题。</p></li><li class="lvl-2"><p>解决：若子问题规模较小而容易被解决则直接解决，否则递归地解各个子问题。</p></li><li class="lvl-2"><p>合并：将各个子问题的解合并为原问题的解。</p></li></ul><h3 id="分治法的复杂性分析"><a href="#分治法的复杂性分析" class="header-anchor">¶</a>分治法的复杂性分析：</h3><p>分治法将规模为n的问题分成a个规模为n/b的子问题去求解，直到n达到分解阈值以下时才可以直接求解。</p><p>设分解阈值n0=1，解规模为1的问题花费常数时间，分解k个子问题和合并k个子问题需要F(n)的时间，通常情况下，此时间我们认为就是 O(n<sup>d</sup>)的时间。则有：</p><img src="C:/Users/Lenovo/Pictures/Screenshots/only_bolg/屏幕截图 2023-03-29 190138.png" style="zoom:67%;"><p>这就是分治算法的时间复杂度公式。</p><h4 id="分治算法的主定理求解时间求解复杂度"><a href="#分治算法的主定理求解时间求解复杂度" class="header-anchor">¶</a>分治算法的主定理求解时间求解复杂度：</h4><p>此处不给出主定理的证明，而是直接说明结论：</p><p>对于a，b，d均大于0时，有：</p><img src="C:/Users/Lenovo/Pictures/Screenshots/only_bolg/屏幕截图 2023-03-29 185948.png" alt="屏幕截图 2023-03-29 185948" style="zoom:67%;"><p>使用时，确定a，b和d值即可确定分治法的时间复杂度了。</p><h3 id="分治法与动态规划的区别"><a href="#分治法与动态规划的区别" class="header-anchor">¶</a>分治法与动态规划的区别：</h3><p>动态规划除了分治法的要求外，还要求存在重叠子问题。</p><p>此处要解释一下，子问题相互独立和重叠子问题并不是矛盾的，它们是两个不同的概念，不是一个问题的不同方面。</p><p>前者说明了子问题是不共享资源的，或者说，它们之间不会存在互相抢占资源，争夺资源的问题。</p><p>而后者说明的是同一个子问题在不同的问题中出现了，也就是在两个不同的问题中分解后能够得到一个相同的子问题，这个子问题就是重叠子问题。</p><p>自顶向下的动态规划可以看作是带备忘的分治法。</p>]]></content>
    
    
    <categories>
      
      <category>algorithm_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(四)列表</title>
    <link href="/xiaohei07.github.io/2023/03/20/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%9B%9B)%E5%88%97%E8%A1%A8/"/>
    <url>/xiaohei07.github.io/2023/03/20/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E5%9B%9B)%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><p>list列表的本质是一种有序的集合，是可变的序列（具有先后顺序），是python最基本的数据结构，。</p><p>列表元素的个数没有限制，元素的类型是任意的（只要python支持），不同类型的元素也可以存储在同一列表中。</p><p>列表的长度是系统内置的，可以调用len()函数获得列表长度。</p><p>本章将会讲述所有列表相关操作，包括创建，索引访问，切片访问，增删改查、以及各类操作。</p><h3 id="二创建与形式"><a href="#二创建与形式" class="header-anchor">¶</a>（二）创建与形式：</h3><p>python中用[]方括号表示列表，并用逗号分割其中的元素。</p><p>形式为： <em><strong>列表名 = [元素1,元素2......]</strong></em>  / <em><strong>列表名=[]</strong></em>（空列表）</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean">list1 = []     #空列表<br>list2 = list() #格式化，空列表<br>list3 = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">6.28</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>], <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, <span class="hljs-number">3</span>+<span class="hljs-number">7</span>j, &#123;<span class="hljs-string">&quot;a&quot;</span>:<span class="hljs-number">1</span>&#125;, <span class="hljs-string">&quot;\n&quot;</span>]<br>print(list3)<br>#运算结果:<br># [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">3.14</span>, <span class="hljs-number">6.28</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-string">&#x27;bbb&#x27;</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>, (<span class="hljs-number">3</span>+<span class="hljs-number">7</span>j), &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&#x27;\n&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="三列表的特性"><a href="#三列表的特性" class="header-anchor">¶</a>（三）列表的特性：</h3><h3 id="1-访问"><a href="#1-访问" class="header-anchor">¶</a>1. 访问：</h3><ol><li class="lvl-3"><p>索引访问：</p><p>格式：<em><strong>listname[index]</strong></em>，listname是列表名字，index是索引值。</p><p>index的取值范围为**[0，列表长度-1]**</p><p>索引值有正负之分。</p><p>正索引值从0开始对应第一个元素，并以此类推。</p><p>负索引值从-1开始对应最后一个元素，是反向访问。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listprint = [1,2,3,4,5,6,7,8,9,10,<span class="hljs-string">&quot;11&quot;</span>,<span class="hljs-string">&quot;12&quot;</span>,<span class="hljs-string">&quot;13&quot;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range (0,13):<br>    <span class="hljs-built_in">print</span>(listprint[i],<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(0, 13):<br>    <span class="hljs-built_in">print</span>(listprint[-i-1],<span class="hljs-attribute">end</span>=<span class="hljs-string">&quot;  &quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment"># 运算结果：</span><br><span class="hljs-comment"># 1  2  3  4  5  6  7  8  9  10  11  12  13</span><br><span class="hljs-comment"># 13  12  11  10  9  8  7  6  5  4  3  2  1</span><br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p>切片访问：</p><p>格式：<em><strong>listname[start: end: step]</strong></em>，listname是列表名字，start是开始索引，默认为1，end是结束索引，默认为列表末尾，step是步长，默认为1。</p><p>开始索引到结束索引是一个左闭右开区间，表示截取此部分列表内容进行访问。步长是从开始索引开始每次访问相邻元素的距离。</p><p>三者均可以是负值，也可以不同时为正或负，两个索引为负代表反向索引，步长为负代表从结束索引向开始索引移动。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listprint</span> =<span class="hljs-meta"> [1,2,3,4,5,6,7,8,9,10,&quot;11&quot;,&quot;12&quot;,&quot;13&quot;]</span><br><span class="hljs-attribute">print</span>(listprint[::])     #相当于正向遍历<br><br><span class="hljs-attribute">print</span>(listprint[::-<span class="hljs-number">1</span>])   #相当于反向遍历<br><br><span class="hljs-attribute">print</span>(listprint[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>])    #相对于访问第<span class="hljs-number">3</span>-<span class="hljs-number">6</span>个元素<br><br><span class="hljs-attribute">print</span>(listprint[<span class="hljs-number">6</span>:<span class="hljs-number">2</span>])    #但结束索引小于开始索引，直接结束、<br><br><span class="hljs-attribute">print</span>(listprint[-<span class="hljs-number">2</span>:-<span class="hljs-number">6</span>])  #同上<br><br><span class="hljs-attribute">print</span>(listprint[-<span class="hljs-number">6</span>:-<span class="hljs-number">2</span>])  #相当于访问倒数第<span class="hljs-number">6</span>-<span class="hljs-number">3</span>个元素<br><br><span class="hljs-attribute">print</span>(listprint[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>:<span class="hljs-number">2</span>])  #相当于访问<span class="hljs-number">1</span>，<span class="hljs-number">3</span>，<span class="hljs-number">5</span>，<span class="hljs-number">7</span>索引元素<br><br><span class="hljs-attribute">print</span>(listprint[<span class="hljs-number">8</span>:<span class="hljs-number">1</span>:<span class="hljs-number">2</span>])  #直接结束<br><br><span class="hljs-attribute">print</span>(listprint[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>:-<span class="hljs-number">2</span>]) #要反向访问，开始索引应大于结束索引，否则直接结束<br><br><span class="hljs-attribute">print</span>(listprint[<span class="hljs-number">8</span>:<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>]) #相当于访问<span class="hljs-number">8</span>，<span class="hljs-number">6</span>，<span class="hljs-number">4</span>，<span class="hljs-number">1</span>索引元素<br><br><span class="hljs-attribute">print</span>(listprint[-<span class="hljs-number">1</span>:-<span class="hljs-number">8</span>:<span class="hljs-number">2</span>])#直接结束<br><br><span class="hljs-attribute">print</span>(listprint[-<span class="hljs-number">8</span>:-<span class="hljs-number">1</span>:<span class="hljs-number">2</span>])#相当于访问-<span class="hljs-number">8</span>，-<span class="hljs-number">6</span>，-<span class="hljs-number">4</span>，-<span class="hljs-number">2</span>元素<br><br><span class="hljs-attribute">print</span>(listprint[-<span class="hljs-number">1</span>:-<span class="hljs-number">8</span>:-<span class="hljs-number">2</span>])#相当于访问-<span class="hljs-number">1</span>，-<span class="hljs-number">3</span>，-<span class="hljs-number">5</span>，-<span class="hljs-number">7</span>元素<br><br><span class="hljs-attribute">print</span>(listprint[-<span class="hljs-number">8</span>:-<span class="hljs-number">1</span>:-<span class="hljs-number">2</span>])#直接结束<br><br><span class="hljs-comment"># 运算结果：</span><br><span class="hljs-comment">#1  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, &#x27;11&#x27;, &#x27;12&#x27;, &#x27;13&#x27;]</span><br><span class="hljs-comment">#2  [&#x27;13&#x27;, &#x27;12&#x27;, &#x27;11&#x27;, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span><br><span class="hljs-comment">#3  [3, 4, 5, 6]</span><br><span class="hljs-comment">#4  []</span><br><span class="hljs-comment">#5  []</span><br><span class="hljs-comment">#6  [8, 9, 10, &#x27;11&#x27;]</span><br><span class="hljs-comment">#7  [2, 4, 6, 8]</span><br><span class="hljs-comment">#8  []</span><br><span class="hljs-comment">#9  []</span><br><span class="hljs-comment">#10 [9, 7, 5, 3]</span><br><span class="hljs-comment">#11 []</span><br><span class="hljs-comment">#12 [6, 8, 10, &#x27;12&#x27;]</span><br><span class="hljs-comment">#13 [&#x27;13&#x27;, &#x27;11&#x27;, 9, 7]</span><br><span class="hljs-comment">#14 []</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="2-删除列表"><a href="#2-删除列表" class="header-anchor">¶</a>2. 删除列表：</h4><p>python自带垃圾回收机制，已创建的列表如不再使用，将会被编译器自动回收，不会产生内存垃圾。</p><p>如果需要可以手动删除，使用del 关键字手动删除列表。</p><p>形式为： <em><strong>del listname</strong></em></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">a=<span class="hljs-selector-attr">[1,2,3,4,5]</span><br><span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">a</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span> #此句无法输出，因为a已经被删除了，a变量处于未定义状态<br></code></pre></td></tr></table></figure><h4 id="3多维列表"><a href="#3多维列表" class="header-anchor">¶</a>3.多维列表:</h4><p>多维列表是将其他列表当做列表的元素放在一个列表当中，也就是列表的嵌套，一般我们常用的是二位列表，这里以二维列表为例。</p><p>二维列表形式为：</p><p><em><strong>listname = [ sublistname1, sublistname2 , sublistname3, ....... , sublistnamen ]</strong></em></p><p>访问形式为：</p><p><em><strong>listname[ index1] [index2]</strong></em></p><p>index1代表索引中的行，代表二维列表中第index1-1个列表；</p><p>index2代表索引中的列，代表二维列表中第index1-1个列表的第index2-1个元素。</p><p>如果是多维列表，逻辑同一维列表转变为二维列表。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>=[[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>],sep=<span class="hljs-string">&quot; &quot;</span>,end=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>],sep=<span class="hljs-string">&quot; &quot;</span>,end=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>],a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>],sep=<span class="hljs-string">&quot; &quot;</span>,end=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-attribute">print</span>(a[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>],a[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>],a[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>],sep=<span class="hljs-string">&quot; &quot;</span>,end=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-comment"># [1, 2, 3] [4, 5, 6] [7, 8, 9]</span><br><span class="hljs-comment"># 1 4 7</span><br><span class="hljs-comment"># 2 5 8</span><br><span class="hljs-comment"># 3 6 9</span><br></code></pre></td></tr></table></figure><h4 id="4-列表的主要操作增删改查"><a href="#4-列表的主要操作增删改查" class="header-anchor">¶</a>4. 列表的主要操作（增删改查）：</h4><ul class="lvl-0"><li class="lvl-2"><p>修改列表元素：</p><ul class="lvl-2"><li class="lvl-4"><p>单个元素的修改：</p><p>形式：<em><strong>list1[index] = value</strong></em>，就可以修改列表中对应索引的内容为value。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> =<span class="hljs-meta"> [1,2,3]</span><br><span class="hljs-attribute">a</span>[<span class="hljs-number">1</span>]=<span class="hljs-number">4</span><br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 4, 3]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>一组元素的修改：</p><p>实际上是使用切片的形式给一组元素赋值。此方法不能给单个数字赋值，也会把字符串自动转换为列表，每个字符对应一个元素。</p><p>如果不指定步长，新赋值的元素个数可以和要修改的列表元素个数不相同（实际上，这种方法可以为列表删除/添加元素）。</p><p>如果指定步长，要求新赋值的元素个数和要修改的列表元素个数相同。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs prolog">listdisplay = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br>print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br>listdisplay[<span class="hljs-number">0</span>: <span class="hljs-number">2</span>] = [<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]<br>print(<span class="hljs-string">&quot;修改后:&quot;</span>,listdisplay)<br><br># listdisplay = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br># print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br># listdisplay[<span class="hljs-number">0</span>: <span class="hljs-number">0</span>] = <span class="hljs-number">9</span>  #此句话错误，不能用切片方式对数字单独赋值。<br><br>listdisplay = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br>print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br>listdisplay[<span class="hljs-number">0</span>: <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;5678&quot;</span>  #此句话错误，不能用切片方式对数字单独赋值。<br>print(<span class="hljs-string">&quot;修改后:&quot;</span>,listdisplay)  #可以用切片方式对数字单独赋值，而且会改变元素个数<br><br>listdisplay = []<br>print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br>listdisplay[<span class="hljs-number">0</span>: <span class="hljs-number">0</span>] = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]  # 对空切片赋值<br>print(<span class="hljs-string">&quot;修改后:&quot;</span>,listdisplay)<br><br>listdisplay = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br>print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br>listdisplay[:] = [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]  # 新赋值的元素个数与原来的元素个数可以不相同。并且元素个数增加了。<br>print(<span class="hljs-string">&#x27;修改后:&#x27;</span>, listdisplay)<br><br>listdisplay = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>]<br>print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br>listdisplay[:] = [<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>,<span class="hljs-string">&quot;7&quot;</span>,<span class="hljs-string">&quot;8&quot;</span>,<span class="hljs-string">&quot;9&quot;</span>]  # 新赋值的元素个数与原来的元素个数可以不相同。并且元素个数减少了。<br>print(<span class="hljs-string">&#x27;修改后:&#x27;</span>, listdisplay)<br><br>listdisplay = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;5&quot;</span>,<span class="hljs-string">&quot;6&quot;</span>]<br>print(<span class="hljs-string">&quot;修改前:&quot;</span>,listdisplay)<br>listdisplay[<span class="hljs-number">1</span>: <span class="hljs-number">6</span>: <span class="hljs-number">2</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]  # 从索引 <span class="hljs-number">1</span> 开始每隔两个添加一个新元素，到索引 <span class="hljs-number">6</span> ，不包括 索引 <span class="hljs-number">6</span><br>print(<span class="hljs-string">&#x27;修改后:&#x27;</span>, listdisplay)<br><br># 运行结果：<br># 修改前: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br># 修改后: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br># 修改前: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br># 修改后: [<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br># 修改前: []<br># 修改后: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br># 修改前: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br># 修改后: [<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>]<br># 修改前: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>]<br># 修改后: [<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>]<br># 修改前: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>]<br># 修改后: [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>查询列表元素：</p><ul class="lvl-2"><li class="lvl-4"><p>使用 in 和 not in判断元素是否在列表内：</p><p>格式： <em><strong>value in listname</strong></em> / <em><strong>value not in listname</strong></em></p><p>可以判断value值是否在listname中，整体为布尔值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listdisplay = [1,2,3,4,5,6,7]<br><span class="hljs-built_in">print</span>(1 <span class="hljs-keyword">in</span> listdisplay)<br><span class="hljs-built_in">print</span>(3 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> listdisplay)<br><span class="hljs-built_in">print</span>(8 <span class="hljs-keyword">in</span> listdisplay)<br><span class="hljs-built_in">print</span>(10 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> listdisplay)<br><span class="hljs-comment"># 输出结果:</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><p>此方法配合下面的index方法食用更佳（先判断在不在列表内部，再用index方法，以免index没查到而报错）。</p></li><li class="lvl-4"><p>使用列表的index()方法查找元素：</p><p>格式：<em><strong>listname.index(obj, start, end)</strong></em></p><p>返回值为查找到的元素第一次在列表中出现的索引值。</p><p>obj表示要查找的元素；</p><p>start表示起始索引，默认为列表初始元素；</p><p>end表示结束索引，默认为列表末尾元素；（检查不包括end元素本身）</p><p>start和end均可不写，此时检索全列表。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="hljs-attribute">getindex1</span> = listdisplay.index(<span class="hljs-number">3</span>)  # 整个列表中检索元素<span class="hljs-number">3</span>的位置<br><span class="hljs-attribute">print</span>(getindex1)<br><br><span class="hljs-attribute">getindex2</span> = listdisplay.index(<span class="hljs-number">10</span>,<span class="hljs-number">0</span>,len(listdisplay)+<span class="hljs-number">1</span>) #和上面查询范围等价<br><span class="hljs-attribute">print</span>(getindex2)<br><br><span class="hljs-attribute">getindex3</span> = listdisplay.index(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)  # 检索元素<span class="hljs-number">5</span>在列表索引<span class="hljs-number">0</span>-<span class="hljs-number">4</span>中的位置<br><span class="hljs-attribute">print</span>(getindex3)<br><br><span class="hljs-comment"># getindex4 = listdisplay.index(6, 0, 5)  #检查元素6在列表索引中0-4的位置，但是不在其中，报错</span><br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 9</span><br><span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>使用列表的count()方法查找元素：</p><p>格式：<em><strong>listname.count(obj)</strong></em></p><p>返回值为查找元素在列表中出现的次数，返回0意味着列表中未出现此元素。</p><p>obj为要统计的元素。</p><p>不能指定查询列表的某个范围，只能全局查找。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span> =<span class="hljs-meta"> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 3, 3, 3]</span><br><span class="hljs-attribute">getcount1</span> = listdisplay.count(<span class="hljs-number">3</span>)  # 整个列表中检索元素<span class="hljs-number">3</span>的数量<br><span class="hljs-attribute">print</span>(getcount1)<br><span class="hljs-attribute">getcount2</span> = listdisplay.count(<span class="hljs-number">12</span>)  # 整个列表中检索元素<span class="hljs-number">12</span>的数量,返回<span class="hljs-number">0</span>,即未出现<br><span class="hljs-attribute">print</span>(getcount2)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># 0</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>添加列表元素：</p><ul class="lvl-2"><li class="lvl-4"><p>列表的组合（使用&quot;+&quot;符号）：</p><p>格式：<em><strong>listname = listname1+listname2+...+listnamen</strong></em></p><p>&quot;+&quot;运算符在操作多个列表时，可以将列表拼接到一起，生成一个新的列表，新列表按所加的顺序生成所有元素。</p><p>此方法虽然简便直观，但是执行效率低，不建议经常使用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listdisplay1 = [1, 2, 3, 4, 5]<br>listdisplay2 = [6, 7, 8, 9, 10]<br>listdisplay3 = listdisplay1+listdisplay2<br><span class="hljs-built_in">print</span>(listdisplay1)<br><span class="hljs-built_in">print</span>(listdisplay2)<br><span class="hljs-built_in">print</span>(listdisplay3)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># [6, 7, 8, 9, 10]</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>列表的重复（使用&quot;*&quot;符号）：</p><p>格式：<em><strong>listname= listname1</strong></em> ***** <em><strong>n</strong></em></p><p>&quot;*&quot;运算符对单个列表操作时，将被操作列表复制n遍合成一个列表，相当于用当前元素生成长度为原长度n倍的列表。</p><p>同样，此方法执行效率不高。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listdisplay = [1, 2, 3, 4, 5]<br>listdisplaynew = listdisplay<span class="hljs-number">*3</span><br><span class="hljs-built_in">print</span>(listdisplay)<br><span class="hljs-built_in">print</span>(listdisplaynew)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>append()方法添加元素：</p><p>格式：<em><strong>listname.append(obj)</strong></em></p><p>append()函数添加元素至列表末尾，obj可以是一个列表/元组等等，但是obj会作为一个整体被添加进入listname这个列表中，也就是只添加一个元素，形成一个新列表（但地址不变，只是长度和元素更新了）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-attribute">listdisplay</span>.append(<span class="hljs-number">5</span>)<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.append(<span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.append([<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.append(&#123;<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;)<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5]</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, &#x27;12345&#x27;]</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, &#x27;12345&#x27;, [6, 7, 8, 9, 10]]</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, &#x27;12345&#x27;, [6, 7, 8, 9, 10], &#123;11, 12, 13, 14, 15&#125;]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>extend()方法添加元素：</p><p>格式：<em><strong>listname.extend(obj)</strong></em></p><p>extend()函数添加元素至列表末尾，obj可以是一个字符串/列表/元组，但是不能是单个数据，必须是这种序列形式，哪怕里面只有一个元素。</p><p>extend()函数会将obj包含的所有元素逐个提取加入listname列表中，也就是被添加的数据不止一个，形成一个新列表（地址不变，只是长度和元素更新了）。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">listdisplay=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>listdisplay.<span class="hljs-built_in">extend</span>([<span class="hljs-number">5</span>])<br><span class="hljs-keyword">print</span>(listdisplay)<br>listdisplay.<span class="hljs-built_in">extend</span>(<span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-keyword">print</span>(listdisplay)<br>listdisplay.<span class="hljs-built_in">extend</span>([<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])<br><span class="hljs-keyword">print</span>(listdisplay)<br>listdisplay.<span class="hljs-built_in">extend</span>(&#123;<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;)<br><span class="hljs-keyword">print</span>(listdisplay)<br># # 输出结果：<br># [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br># [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>]<br># [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br># [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>]<br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>insert()方法添加元素：</p><p>格式：<em><strong>listname.insert(index , obj)</strong></em></p><p>insert()函数可以在列表的指定位置插入元素，通过index索引值确定插入位置，在此位置的原来的元素默认后移为新插入元素空出空间。</p><p>obj的插入和append的情况相同。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-attribute">listdisplay</span>.insert(<span class="hljs-number">1</span>,[<span class="hljs-number">1</span>.<span class="hljs-number">5</span>])<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.insert(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;12345&quot;</span>)<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.insert(<span class="hljs-number">4</span>,[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>])<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.insert(<span class="hljs-number">3</span>,&#123;<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;)<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-comment"># # 输出结果：</span><br><span class="hljs-comment"># [1, [1.5], 2, 3, 4]</span><br><span class="hljs-comment"># [&#x27;12345&#x27;, 1, [1.5], 2, 3, 4]</span><br><span class="hljs-comment"># [&#x27;12345&#x27;, 1, [1.5], 2, [6, 7, 8, 9, 10], 3, 4]</span><br><span class="hljs-comment"># [&#x27;12345&#x27;, 1, [1.5], &#123;11, 12, 13, 14, 15&#125;, 2, [6, 7, 8, 9, 10], 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>删除列表元素：</p><ul class="lvl-2"><li class="lvl-4"><p>del关键字进行删除：</p><p>格式：<em><strong>del listname[index]</strong></em></p><p>​    <em><strong>del listname[start : end]</strong></em></p><p>del关键字可以根据列表的索引值进行指定值/范围删除，也可以直接删除整个列表（见上），可以指定超过范围的索引值，但不建议。</p><p>删除后列表的长度和元素均进行更新。</p><p>end本身不会被删除。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-attribute">del</span> listdisplay[<span class="hljs-number">1</span>]   #删一个<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">del</span> listdisplay[<span class="hljs-number">1</span>:<span class="hljs-number">5</span>] #删四个<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">del</span> listdisplay[<span class="hljs-number">6</span>:<span class="hljs-number">7</span>] #无效操作<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">del</span> listdisplay[-<span class="hljs-number">2</span>:-<span class="hljs-number">1</span>] #删除倒数第二个<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-comment"># # 输出结果：</span><br><span class="hljs-comment"># [1, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="hljs-comment"># [1, 7, 8, 9, 10]</span><br><span class="hljs-comment"># [1, 7, 8, 9, 10]</span><br><span class="hljs-comment"># [1, 7, 8, 10]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>pop方法进行删除：</p><p>格式：<em><strong>listname.pop(index)</strong></em></p><p>pop()函数同样根据列表的索引值进行指定值删除，不能指定范围，不能整个列表删除。</p><p>index的默认值为列表最后一个元素，其值不能超过范围。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-attribute">listdisplay</span>.pop(<span class="hljs-number">1</span>)   #删位置为<span class="hljs-number">1</span>的元素<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.pop()  #删除最后一个元素<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.pop(-<span class="hljs-number">2</span>) #删除倒数第二个<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="hljs-comment"># [1, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># [1, 3, 4, 5, 6, 7, 9]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>remove方法进行删除：</p><p>格式：<em><strong>listname.remove(element)</strong></em></p><p>remove()函数根据元素本身的值（element）进行删除，且只删除第一个指定元素值，随后结束函数，不会删除其他相同元素。</p><p>被删除元素必须在列表中存在，否则会报错。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-attribute">listdisplay</span>.remove(<span class="hljs-number">2</span>) #删除第一个值为<span class="hljs-number">2</span>的元素，第二个不删除<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.remove(<span class="hljs-number">2</span>) #删除值为<span class="hljs-number">2</span>的元素<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-comment"># listdisplay.remove(-2)   #-2不存在，报错</span><br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 3, 4, 5, 6, 7, 2, 8, 9, 10]</span><br><span class="hljs-comment"># [1, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>clear方法进行删除：</p><p>格式：<em><strong>listname.clear()</strong></em></p><p>clear()函数删除所有元素，但变量名还存在（区别于上面del 删除列表操作）。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">listdisplay</span>.clear()<br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [1, 2, 3, 4, 5, 6, 7, 2, 8, 9, 10]</span><br><span class="hljs-comment"># []</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-列表的其他操作"><a href="#5-列表的其他操作" class="header-anchor">¶</a>5. 列表的其他操作：</h4><ul class="lvl-0"><li class="lvl-2"><p>获得最大，最小值：</p><p>格式：<em><strong>max(listname) / min(listname)</strong></em></p><p>获得列表最大值/最小值。（只限于可比较类型比较而出的最大/最小值）。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs monkey">listdisplay = [<span class="hljs-string">&quot;ayz&quot;</span>,<span class="hljs-string">&quot;bcd&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>]<span class="hljs-meta"> #按首字母的ASCII码比较</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(listdisplay))<span class="hljs-meta"></span><br><span class="hljs-meta"># 输出结果：</span><span class="hljs-meta"></span><br><span class="hljs-meta"># w  </span><br></code></pre></td></tr></table></figure></li><li class="lvl-2"><p>排序：</p><ul class="lvl-2"><li class="lvl-4"><p>列表的sort方法排序：</p><p>格式：<em><strong>listname.sort(</strong></em> ***** <em><strong>, key=None, reverse=False)</strong></em></p><p>key：指定带有一个参数的函数，用于从每个序列元素中提取比较键。对应于序列中的每一项的键会被计算一次，然后在整个排序过程中使用，默认值None代表直接对序列项排序，不计算单独的键值。</p><p>reverse：为一个布尔值，默认False，表示升序排序，如果指定了True，则表示降序排序</p><p>sort方法对原列表进行修改。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listdisplay = [8,6,4,6,8,1,9]<br>listdisplay.sort(<span class="hljs-attribute">reverse</span>=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(listdisplay)<br>listdisplay.sort()<br><span class="hljs-built_in">print</span>(listdisplay)<br>listdisplay2= [<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;qwe&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;zxc&quot;</span>]<br>listdisplay2.sort(<span class="hljs-attribute">reverse</span>=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(listdisplay2)<br><span class="hljs-comment"># 输出结果:</span><br><span class="hljs-comment"># [9, 8, 8, 6, 6, 4, 1]</span><br><span class="hljs-comment"># [1, 4, 6, 6, 8, 8, 9]</span><br><span class="hljs-comment"># [&#x27;abc&#x27;, &#x27;jkl&#x27;, &#x27;qwe&#x27;, &#x27;zxc&#x27;]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>内置的sorted()函数排序：</p><p>格式：<em><strong>sorted(iterable,</strong></em> ***** <em><strong>,key=None, reverse=False)</strong></em></p><p>sorted()函数从一个可迭代对象根据iterable的项返回一个新的排序列表</p><p>key和reverse同上。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listdisplay = [8,6,4,6,8,1,9]<br><span class="hljs-attribute">listdisplay2</span>=sorted(listdisplay,reverse=True)<br><span class="hljs-built_in">print</span>(listdisplay)<br><span class="hljs-built_in">print</span>(listdisplay2)<br><span class="hljs-attribute">listdisplay3</span>=sorted(listdisplay)<br><span class="hljs-built_in">print</span>(listdisplay)<br><span class="hljs-built_in">print</span>(listdisplay3)<br>listdisplay2= [<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;qwe&quot;</span>,<span class="hljs-string">&quot;jkl&quot;</span>,<span class="hljs-string">&quot;zxc&quot;</span>]<br><span class="hljs-attribute">listdisplay4</span>=sorted(listdisplay2,reverse=False)<br><span class="hljs-built_in">print</span>(listdisplay4)<br><span class="hljs-comment"># 输出结果:</span><br><span class="hljs-comment"># [8, 6, 4, 6, 8, 1, 9]</span><br><span class="hljs-comment"># [9, 8, 8, 6, 6, 4, 1]</span><br><span class="hljs-comment"># [8, 6, 4, 6, 8, 1, 9]</span><br><span class="hljs-comment"># [1, 4, 6, 6, 8, 8, 9]</span><br><span class="hljs-comment"># [&#x27;abc&#x27;, &#x27;jkl&#x27;, &#x27;qwe&#x27;, &#x27;zxc&#x27;]</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>复制：</p><ul class="lvl-2"><li class="lvl-4"><p>直接赋值：</p><p>= 直接赋值是非拷贝方法。</p><p>两个列表是等价的，修改其中任何一个列表都会影响另一个列表。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">listdisplay = [8,6,4,6,8,1,9]<br>listdisplay1= listdisplay<br>listdisplay1[1]=0<br><span class="hljs-built_in">print</span>(listdisplay)<br><span class="hljs-built_in">print</span>(listdisplay1)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [8, 0, 4, 6, 8, 1, 9]</span><br><span class="hljs-comment"># [8, 0, 4, 6, 8, 1, 9]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>copy方法（浅拷贝）：</p><p>格式：<em><strong>listnewname = listname.copy()</strong></em></p><p>python中浅拷贝是指list保存的地址同样被复制过去，而不是创建新的地址复制值过去。</p><p>copy方法对嵌套的list只能对第一层实现深拷贝，而其内嵌套的list仍是浅拷贝。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">listdisplay</span> =<span class="hljs-meta"> [1,2,3,[1,2,3]]</span><br><span class="hljs-attribute">listdisplay1</span>=listdisplay.copy()<br><span class="hljs-attribute">listdisplay</span>[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">listdisplay</span>[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">print</span>(listdisplay1)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [3, 2, 3, [1, 3, 3]]</span><br><span class="hljs-comment"># [1, 2, 3, [1, 3, 3]]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>使用切片：</p><p>格式：<em><strong>listnewname= listname[:]</strong></em></p><p>同为浅拷贝。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">listdisplay = <span class="hljs-comment">[1,2,3,<span class="hljs-comment">[1,2,3]</span>]</span><br>listdisplay1=listdisplay<span class="hljs-comment">[:]</span><br>listdisplay<span class="hljs-comment">[0]</span>=3<br>listdisplay<span class="hljs-comment">[3]</span><span class="hljs-comment">[1]</span>=3<br>print(listdisplay)<br>print(listdisplay1)<br># 输出结果：<br># <span class="hljs-comment">[3, 2, 3, <span class="hljs-comment">[1, 3, 3]</span>]</span><br># <span class="hljs-comment">[1, 2, 3, <span class="hljs-comment">[1, 3, 3]</span>]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>for循环遍历：</p><p>无具体格式，是一个操作流程。</p><p>同为浅拷贝。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs inform7">listdisplay = <span class="hljs-comment">[1,2,3,<span class="hljs-comment">[1,2,3]</span>]</span><br>listdisplay1=<span class="hljs-comment">[]</span><br>for i in range(len(listdisplay)):<br>    listdisplay1.append(listdisplay<span class="hljs-comment">[i]</span>)<br>listdisplay<span class="hljs-comment">[0]</span>=3<br>listdisplay<span class="hljs-comment">[3]</span><span class="hljs-comment">[1]</span>=3<br>print(listdisplay)<br>print(listdisplay1)<br># 输出结果：<br># <span class="hljs-comment">[3, 2, 3, <span class="hljs-comment">[1, 3, 3]</span>]</span><br># <span class="hljs-comment">[1, 2, 3, <span class="hljs-comment">[1, 3, 3]</span>]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>列表生成式：</p><p>格式：<em><strong>listnewname = [i for i in listname ]</strong></em></p><p>同为浅拷贝。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">listdisplay = <span class="hljs-comment">[1,2,3,<span class="hljs-comment">[1,2,3]</span>]</span><br>listdisplay1=<span class="hljs-comment">[i for i in listdisplay]</span><br>listdisplay<span class="hljs-comment">[0]</span>=3<br>listdisplay<span class="hljs-comment">[3]</span><span class="hljs-comment">[1]</span>=3<br>print(listdisplay)<br>print(listdisplay1)<br># 输出结果：<br># <span class="hljs-comment">[3, 2, 3, <span class="hljs-comment">[1, 3, 3]</span>]</span><br># <span class="hljs-comment">[1, 2, 3, <span class="hljs-comment">[1, 3, 3]</span>]</span><br></code></pre></td></tr></table></figure></li><li class="lvl-4"><p>deepcopy方法：</p><p>格式：<em><strong>listnewname= copy.deepcopy(listname)</strong></em></p><p>是深拷贝，原来的列表和新列表完全无关。</p><p>需要import copy库</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">import</span> copy<br><span class="hljs-attribute">listdisplay</span> =<span class="hljs-meta"> [1,2,3,[1,2,3]]</span><br><span class="hljs-attribute">listdisplay1</span> = copy.deepcopy(listdisplay)<br><span class="hljs-attribute">listdisplay</span>[<span class="hljs-number">0</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">listdisplay</span>[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">3</span><br><span class="hljs-attribute">print</span>(listdisplay)<br><span class="hljs-attribute">print</span>(listdisplay1)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># [3, 2, 3, [1, 3, 3]]</span><br><span class="hljs-comment"># [1, 2, 3, [1, 2, 3]] #唯一未随之改变的</span><br></code></pre></td></tr></table></figure></li></ul></li><li class="lvl-2"><p>翻转：</p><p>格式： <em><strong>listname.reverse()</strong></em></p><p>将列表元素倒叙，对原列表操作，不返回新列表。</p><p>不会翻转里面的内嵌套列表/字符串/元组，只是更换元素位置。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">listdisplay = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]<br>listdisplay.<span class="hljs-keyword">reverse</span>()<br><span class="hljs-keyword">print</span>((listdisplay))<br><span class="hljs-meta"># 输出结果：</span><br><span class="hljs-meta"># [[1, 2, 3], 3, 2, 1]</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(三)字符串</title>
    <link href="/xiaohei07.github.io/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%89)%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/xiaohei07.github.io/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%89)%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="一概述"><a href="#一概述" class="header-anchor">¶</a>（一）概述：</h3><p>字符串类型，也是文本序列类型，是Python中最常用的类型，在Python中是str类型。</p><p>在Python3.x版本中，字符串全部是由Unicode国际码构成的，是一个不可变序列，其存储位数全部为16位，不再有8位的ASCII码存储了。</p><p>但是如果需要在网络上传输或者保存到磁盘，这个序列需要变成以字节为单位的bytes。对于Python来说，bytes类型的数据只需要在字符串前面加上b前缀即可。</p><p>Unicode表示的str通过encode()方法可以编码为指定bytes，而bytes变为str可以统decode()方法转换。</p><p>注意：python中没有字符类型，单个字符默认为字符串类型。</p><p>格式化内容请参考<a href="https://07xiaohei.com/2023/03/18/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%AF%A6%E8%A7%A3/">python基础——输入和输出详解</a></p><p>本文无字符串函数讲解（太多了），可能以后会再补充博客进行单独说明~</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">a</span> = <span class="hljs-string">&quot;我&quot;</span><br><span class="hljs-title">b</span> = <span class="hljs-string">&quot;我&quot;</span>.encode()<br><span class="hljs-title">c</span> = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-title">d</span> = b<span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-title">print</span>(a,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-title">a</span>))</span><br><span class="hljs-title">print</span>(b,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-title">b</span>))</span><br><span class="hljs-title">print</span>(c,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-title">c</span>))</span><br><span class="hljs-title">print</span>(d,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-class"><span class="hljs-keyword">type</span>(<span class="hljs-title">d</span>))</span><br><span class="hljs-meta"># 输出结果：</span><br><span class="hljs-meta"># 我   &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-meta"># b&#x27;\xe6\x88\x91&#x27;   &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-meta"># a   &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-meta"># b&#x27;a&#x27;   &lt;class &#x27;bytes&#x27;&gt;</span><br></code></pre></td></tr></table></figure><h3 id="二形式"><a href="#二形式" class="header-anchor">¶</a>（二）形式：</h3><ol><li class="lvl-3"><p>单引号，形式为 <em><strong>'字符串内容 '</strong></em>，单引号内允许含有双引号。</p></li><li class="lvl-3"><p>双引号，形式为 <em><strong>&quot;字符串内容 &quot;</strong></em>，双引号内允许含有单引号。</p></li><li class="lvl-3"><p>三引号且均为单/双引号，此为长字符串，形式为 <em><strong>'''字符串内容 &quot;'<em><strong>或者是</strong></em>&quot;&quot;&quot;字符串内容 &quot;&quot;&quot;</strong></em>，此内容可以跨越多行，而且允许字符串包含换行符、制表符、单双引号（不会冲突）以及其他特殊字符，所有的空白字符也将包含在该字符串中。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;1&#x27;</span><br>b = <span class="hljs-string">&quot;1&quot;</span><br>c = <span class="hljs-string">&quot;&quot;&quot;1 </span><br><span class="hljs-string">2</span><br><span class="hljs-string">3 &quot;&quot;</span><br><span class="hljs-string">4&quot;&quot;&quot;</span><br>d = <span class="hljs-string">&#x27;&#x27;&#x27;1 </span><br><span class="hljs-string">2</span><br><span class="hljs-string">3 &#x27;&#x27;</span><br><span class="hljs-string">4&#x27;&#x27;&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name,a:&quot;</span>,a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name,b:&quot;</span>,b)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name,c:&quot;</span>,c)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;name,d:&quot;</span>,d)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># name,a: 1</span><br><span class="hljs-comment"># name,b: 1</span><br><span class="hljs-comment"># name,c: 1 </span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3 &quot;&quot;</span><br><span class="hljs-comment"># 4</span><br><span class="hljs-comment"># name,d: 1 </span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3 &#x27;&#x27;</span><br><span class="hljs-comment"># 4</span><br></code></pre></td></tr></table></figure><h3 id="三原始字符串"><a href="#三原始字符串" class="header-anchor">¶</a>（三）原始字符串：</h3><p>在字符串或者长字符串的开头加上r/R前缀，字符串将会变为原始字符串。</p><p>在原始字符串中，反斜杠不再是转义字符，所有内容均保持不变。</p><p>但如果出现引号，反斜杠仍然会对引号进行转义，这会导致如果是结尾处出现反斜杠，会将后面的引号转义，导致没有结束引号而产生错误，且这个反斜杠没有办法转义自己，无法断开与后面引号的练习。</p><p>解决方法：利用字符串拼接，将最后一个\放到另一个非原始字符串中然后进行拼接即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">r&quot;\n\n\n\n\n&quot;</span><br>b = <span class="hljs-string">R&quot;abcd\t&quot;</span><br>c = <span class="hljs-string">r&#x27;\\aaa&#x27;</span><br>d = <span class="hljs-string">r&quot;D:\pycharmwork&quot;</span>+<span class="hljs-string">&quot;\\&quot;</span><br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(d)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># \n\n\n\n\n</span><br><span class="hljs-comment"># abcd\t</span><br><span class="hljs-comment"># \\aaa</span><br><span class="hljs-comment"># D:\pycharmwork\</span><br></code></pre></td></tr></table></figure><h3 id="四转义字符"><a href="#四转义字符" class="header-anchor">¶</a>（四）转义字符：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python3">\n  ：换行<br>\\  ：反斜杠符号<br>\&#x27;  ：单引号<br>\&quot;  ：双引号<br>\000：空<br>\a  ：响铃<br>\b  ：退格<br>\v  ：纵向制表符<br>\t  ：横向制表符<br>\r  ：回车<br>\f  ：换页<br>\oyy：八进制数，yy代表的字符，例如：\o12代表换行<br>\xyy：十六进制数，yy代表的字符，例如：\x0a代表换行<br>\other：其它的字符以普通格式输出<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a = <span class="hljs-string">&quot;\\&quot;</span><br>b = <span class="hljs-string">&quot;1\n2\n3&quot;</span> <br>c = <span class="hljs-string">&quot;\&quot;我\&#x27;&quot;</span><br>d = <span class="hljs-string">&quot;wi\000n&quot;</span>    <span class="hljs-comment">#\000相当于空格了</span><br>e = <span class="hljs-string">&quot;1\t2\t3\t&quot;</span>  <span class="hljs-comment">#\t在制表</span><br>f = <span class="hljs-string">&quot;1111\b\b\b&quot;</span> <span class="hljs-comment">#\b将后面三个1退格而消失了</span><br>g = <span class="hljs-string">&quot;\012 \x24&quot;</span>  <span class="hljs-comment"># \012相当于换行 \x24对于ASCII码对应的是$</span><br>h = <span class="hljs-string">&quot;\v\v\v&quot;</span>     <span class="hljs-comment">#就是纵向制表</span><br>i = <span class="hljs-string">&quot;\r\r\r&quot;</span>     <span class="hljs-comment">#\r表示回车确定，无显示。</span><br><span class="hljs-section">print(&quot;显示值:&quot;+a,b,c,d,e,f,g,h,i,sep=&quot;\n显示值：&quot;)</span><br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># 显示值:\</span><br><span class="hljs-comment"># 显示值：1</span><br><span class="hljs-comment"># 2</span><br><span class="hljs-comment"># 3</span><br><span class="hljs-comment"># 显示值：&quot;我&#x27;</span><br><span class="hljs-comment"># 显示值：wi n</span><br><span class="hljs-comment"># 显示值：123</span><br><span class="hljs-comment"># 显示值：1</span><br><span class="hljs-comment"># 显示值：</span><br><span class="hljs-comment">#  $</span><br><span class="hljs-comment"># 显示值：</span><br></code></pre></td></tr></table></figure><h3 id="五字符串操作"><a href="#五字符串操作" class="header-anchor">¶</a>（五）字符串操作：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">+        字符串连接   <br>*        重复输出字符串   <br><span class="hljs-selector-attr">[]</span>       通过索引获取字符串中字符<br><span class="hljs-selector-attr">[x:y]</span>    截取字符串中的一部分，遵循左闭右开原则.<br>in       成员运算符-如果字符串中包含给定的字符返回True<br>not in   成员运算符-如果字符串中不包含给定的字符返回True<br><span class="hljs-attribute">r</span>/<span class="hljs-attribute">R</span>      原始字符串<br>%        格式化字符串<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a = <span class="hljs-string">&quot;I&quot;</span>+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-string">&quot;Love&quot;</span>+<span class="hljs-string">&quot;the world&quot;</span>+<span class="hljs-string">&quot;!&quot;</span><br>b = <span class="hljs-string">&quot;帅&quot;</span> * 8<br>c = a[2]<br>d = a[0:6]<br>e = <span class="hljs-string">&quot;&quot;</span><br>f = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-attribute">e</span>=<span class="hljs-string">&quot;666&quot;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-attribute">e</span>=<span class="hljs-string">&quot;欧尼酱~&quot;</span><br><span class="hljs-keyword">if</span> b <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-attribute">f</span>=<span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-attribute">f</span>=<span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-built_in">print</span>(a,b,c,d,e,f,<span class="hljs-attribute">sep</span>=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># I Lovethe world!</span><br><span class="hljs-comment"># 帅帅帅帅帅帅帅帅</span><br><span class="hljs-comment"># L</span><br><span class="hljs-comment"># I Love</span><br><span class="hljs-comment"># 666</span><br><span class="hljs-comment"># 1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型(二)数字型</title>
    <link href="/xiaohei07.github.io/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%8C)%E6%95%B0%E5%AD%97%E5%9E%8B/"/>
    <url>/xiaohei07.github.io/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%BA%8C)%E6%95%B0%E5%AD%97%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1整型int"><a href="#1整型int" class="header-anchor">¶</a>1.整型：int</h3><p>整数数据类型，简称整型，没有小数数字。</p><p>数字中的正整数、0和负整数均为整型，但只有int一种整数类型，表示为长整型</p><p>整型的长度范围不限，精度无限。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=114514<br><span class="hljs-attribute">b</span>=0<br><span class="hljs-attribute">c</span>=-123456789000000<br><span class="hljs-built_in">print</span>(a,<span class="hljs-string">&quot; &quot;</span>,type(a))<br><span class="hljs-built_in">print</span>(b,<span class="hljs-string">&quot; &quot;</span>,type(b))<br><span class="hljs-built_in">print</span>(c,<span class="hljs-string">&quot; &quot;</span>,type(c))<br><span class="hljs-comment">#运行结果:</span><br><span class="hljs-comment"># 114514   &lt;class &#x27;int&#x27;&gt;</span><br><span class="hljs-comment"># 0   &lt;class &#x27;int&#x27;&gt;</span><br><span class="hljs-comment"># -123456789000000   &lt;class &#x27;int&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>另外可以用二进制、八进制或者十六进制来表示整型：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=0x1111 #十六进制<br><span class="hljs-attribute">b</span>=0Xffff #x可以大写，后面同<br><span class="hljs-attribute">c</span>=0b01010 #二进制<br><span class="hljs-attribute">d</span>=0B101111<br><span class="hljs-attribute">e</span>=0o111 #八进制<br><span class="hljs-attribute">f</span>=0O333<br><span class="hljs-built_in">print</span>(a,b,c,d,e,f,<span class="hljs-attribute">sep</span>=<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">#输出结果：</span><br><span class="hljs-comment"># 4369 对应16^3+16^2+16^1+16^0</span><br><span class="hljs-comment"># 65535</span><br><span class="hljs-comment"># 10  对应2^3+2^1</span><br><span class="hljs-comment"># 47</span><br><span class="hljs-comment"># 73  对应8^2+8^2+8^0</span><br><span class="hljs-comment"># 219</span><br></code></pre></td></tr></table></figure><p>各进制之间允许转换：</p><ul class="lvl-0"><li class="lvl-2"><p>二进制：bin()</p></li><li class="lvl-2"><p>八进制：oct()</p></li><li class="lvl-2"><p>十六进制：hex()</p></li><li class="lvl-2"><p>十进制：int()</p></li></ul><p>注意上面三个返回的是字符串，如要当整型使用请使用函数*int(对应进制字符串变量名，对应进制数)*来完成转换</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">print</span>(&#x27;十进制数 <span class="hljs-number">63</span> 转换为二进制数为：&#x27;, bin(<span class="hljs-number">63</span>))<br><span class="hljs-built_in">print</span>(&#x27;十进制数 <span class="hljs-number">63</span> 转换为八进制数为：&#x27;, oct(<span class="hljs-number">63</span>))<br><span class="hljs-built_in">print</span>(&#x27;十进制数 <span class="hljs-number">63</span> 转换为十六进制数为：&#x27;, hex(<span class="hljs-number">63</span>))<br># 输出结果：<br># 十进制数 <span class="hljs-number">63</span> 转换为二进制数为： <span class="hljs-number">0b111111</span><br># 十进制数 <span class="hljs-number">63</span> 转换为八进制数为： <span class="hljs-number">0o77</span><br># 十进制数 <span class="hljs-number">63</span> 转换为十六进制数为： <span class="hljs-number">0x3f</span><br><br>a=<span class="hljs-number">0b111111</span> #a为二进制<br>b=bin(<span class="hljs-number">63</span>)  #b为从十进制<span class="hljs-number">63</span>转化而得的而得的二进制<span class="hljs-number">0b111111</span><br>c=int(<span class="hljs-number">0b111111</span>) #c为从二进制<span class="hljs-number">0b111111</span>转化得到的十进制数<br>d=int(b,<span class="hljs-number">2</span>) #注意b为字符串，字符串的转化为传入变量和需要转化成的进制数<br><span class="hljs-built_in">print</span>(type(a))<br><span class="hljs-built_in">print</span>(type(b))<br><span class="hljs-built_in">print</span>(type(c))<br><span class="hljs-built_in">print</span>(type(d))<br>#输出结果：<br># &lt;class &#x27;int&#x27;&gt;<br># &lt;class &#x27;str&#x27;&gt; 得到字符串<br># &lt;class &#x27;int&#x27;&gt; int转化就是整型<br># &lt;class &#x27;int&#x27;&gt; bin()转化后的二进制字符串通过int()转化为了<span class="hljs-number">10</span>进制数字<br><br><span class="hljs-built_in">print</span>(&#x27;二进制数 <span class="hljs-number">0b111111</span> 转换为十进制数为：&#x27;, <span class="hljs-number">0b111111</span>)   # <span class="hljs-built_in">print</span>() 函数输出整数默认为十进制<br><span class="hljs-built_in">print</span>(&#x27;二进制数 <span class="hljs-number">0b111111</span> 转换为八进制数为：&#x27;, oct(<span class="hljs-number">0b111111</span>))<br><span class="hljs-built_in">print</span>(&#x27;二进制数 <span class="hljs-number">0b111111</span> 转换为十六进制数为：&#x27;, hex(<span class="hljs-number">0b111111</span>))<br>#输出结果：<br># 二进制数 <span class="hljs-number">0b111111</span> 转换为十进制数为： <span class="hljs-number">63</span><br># 二进制数 <span class="hljs-number">0b111111</span> 转换为八进制数为： <span class="hljs-number">0o77</span><br># 二进制数 <span class="hljs-number">0b111111</span> 转换为十六进制数为： <span class="hljs-number">0x3f</span><br># 其他进制转换请自行尝试<br></code></pre></td></tr></table></figure><p>如果数字太长，可以使用数字分隔符”_“，从右往左每三位添加一个，不会影响结果，方便阅读。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">x</span>=10_000_000_000_000_000<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment">#输出结果：</span><br><span class="hljs-comment"># 10000000000000000</span><br></code></pre></td></tr></table></figure><h3 id="2浮点型float"><a href="#2浮点型float" class="header-anchor">¶</a>2.浮点型：float</h3><p>浮点数数据类型，简称为浮点型，专用于存储浮点小数。</p><p>python中没有double浮点数类型，只有float，但是是双精度的。</p><p>float的表示可以是十进制表示形式或者指数形式。</p><p>十进制表示方法中，float类型里必须含有小数点，但可以没有整数部分或小数部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">3.14</span><br>b = <span class="hljs-number">3.</span> <span class="hljs-comment">#没有后面，默认为0</span><br>c = <span class="hljs-number">.14</span> <span class="hljs-comment">#没有前面，默认为0</span><br><span class="hljs-built_in">print</span>(a,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">type</span>(a))<br><span class="hljs-built_in">print</span>(b,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">type</span>(b))<br><span class="hljs-built_in">print</span>(c,<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-built_in">type</span>(c))<br>运行结果：<br><span class="hljs-number">3.14</span>   &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br><span class="hljs-number">3.0</span>   &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br><span class="hljs-number">0.14</span>   &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;float&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>指数形式表示时，形式为<em><strong>aEn</strong></em>或者<em><strong>aen</strong></em> 等价于a x 10<sup>n</sup></p><p>a为尾数部分，是十进制数；n为指数部分，同为10进制数，而E或e是固定字符，表示分割尾数部分和指数部分。</p><p>值得一提的是，只要使用了指数形式来表示一个数，无论这个数的值如何，均为float类型。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=314159.26e-5<br><span class="hljs-attribute">b</span>=1.1e4<br><span class="hljs-attribute">c</span>=3e9 #整数值，但是是浮点数<br><span class="hljs-attribute">d</span>=9e0 #浮点数<br><span class="hljs-attribute">e</span>=0e3 #0.0也是浮点数<br><span class="hljs-built_in">print</span>(a,<span class="hljs-string">&quot; &quot;</span>,type(a))<br><span class="hljs-built_in">print</span>(b,<span class="hljs-string">&quot; &quot;</span>,type(b))<br><span class="hljs-built_in">print</span>(c,<span class="hljs-string">&quot; &quot;</span>,type(c))<br><span class="hljs-built_in">print</span>(d,<span class="hljs-string">&quot; &quot;</span>,type(d))<br><span class="hljs-built_in">print</span>(e,<span class="hljs-string">&quot; &quot;</span>,type(e))<br><span class="hljs-comment"># 运行结果：</span><br><span class="hljs-comment"># 3.1415926   &lt;class &#x27;float&#x27;&gt;</span><br><span class="hljs-comment"># 11000.0   &lt;class &#x27;float&#x27;&gt;</span><br><span class="hljs-comment"># 3000000000.0   &lt;class &#x27;float&#x27;&gt;</span><br><span class="hljs-comment"># 9.0   &lt;class &#x27;float&#x27;&gt;</span><br><span class="hljs-comment"># 0.0   &lt;class &#x27;float&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>浮点数的范围极大，但是如果位数过多会导致输出可能舍去一部分数字，而数字值本身巨大时（不一定是位数多）直接采用科学计数法输出。</p><p>当然也可以直接使用格式化输出（此处略，有兴趣的可以自行测试）。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=1.234567891011121314151617181920<br><span class="hljs-attribute">b</span>=12345678910111213141516.171819<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># 1.2345678910111213  #舍去一部分数值输出</span><br><span class="hljs-comment"># 1.2345678910111212e+22 #舍去的同时因为数值太大，采用科学计数法输出。</span><br></code></pre></td></tr></table></figure><p>计算机以二进制存储小数部分，会导致误差。</p><p>和十进制中1/3此类的无穷小数类似，如1.68，0.3等都是二进制中的无穷小数，所以在某些情况下，原本看似正确的小数（这个其实是计算机对原数值进行推测而显得正确的）输出实际上会产生问题：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">68</span><br><span class="hljs-attribute">b</span>=<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">1</span>+<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">print</span>(a)<br><span class="hljs-attribute">print</span>(b)<br><span class="hljs-comment"># 输出结果为</span><br><span class="hljs-comment"># 1.6800000000000002</span><br><span class="hljs-comment"># 0.30000000000000004</span><br></code></pre></td></tr></table></figure><p>因此，如果需要判断两个浮点数是否相等/得到我们想要的正确值，往往需要进行取近似值的操作。</p><p>对于python来说，浮点数是64位的，54位存位数，10位存指数。我们可以不选择在54的范围内比较其正确与否，而是缩小比较位数范围，比如在8位以内比较是否相等。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = <span class="hljs-number">1</span>.<span class="hljs-number">68</span><br><span class="hljs-attribute">b</span> = <span class="hljs-number">1</span> + <span class="hljs-number">0</span>.<span class="hljs-number">68</span><br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;a=&#123;:.20&#125;&quot;</span>.format(a))  #格式化输出<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;b=&#123;:.20&#125;&quot;</span>.format(b))<br><span class="hljs-attribute">eps</span> = <span class="hljs-number">0</span>.<span class="hljs-number">00000001</span><br><span class="hljs-attribute">if</span> abs(a - b) &lt; eps:    #看看精度在<span class="hljs-number">0</span>.<span class="hljs-number">00000001</span>范围内是否相等<br>    <span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;a == b&quot;</span>)<br><span class="hljs-comment"># 输出结果：</span><br><br><span class="hljs-attribute">a</span>=<span class="hljs-number">1</span>.<span class="hljs-number">6799999999999999378</span><br><span class="hljs-attribute">b</span>=<span class="hljs-number">1</span>.<span class="hljs-number">6800000000000001599</span><br><span class="hljs-attribute">a</span> == b<br></code></pre></td></tr></table></figure><h3 id="3布尔型bool"><a href="#3布尔型bool" class="header-anchor">¶</a>3.布尔型：bool</h3><p>布尔数据类型，简称布尔型，实际上是int类的一个子类。</p><p>含有关键字<em><strong>True</strong></em> （表示真）和<em><strong>False</strong></em>（表示假）（注意要大写）</p><p>布尔型主要用于判断对错（True=1=正确，False=0=错误），布尔运算，来判断某个条件是否成立。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">print(<span class="hljs-literal">True</span>)  # <span class="hljs-literal">True</span> 首字母要大写<br>print(<span class="hljs-literal">False</span>)  # <span class="hljs-literal">False</span> 首字母要大写<br>print(type(<span class="hljs-literal">True</span>))  # 查看 <span class="hljs-literal">True</span> 的类型<br>print(type(<span class="hljs-literal">False</span>))  # 查看 <span class="hljs-literal">False</span> 的类型<br># 输出结果：<br># <span class="hljs-literal">True</span><br># <span class="hljs-literal">False</span><br># &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bool&#x27;</span>&gt;<br># &lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;bool&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><p>尽管bool类型只有True和False两个实例，但是任何对象都可以进行真假值的判断。</p><p>下面举一些特殊的例子</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-number">1</span>)</span></span>) <span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-number">0</span>)</span></span>) <span class="hljs-selector-id">#False</span> <br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool([])</span></span>) <span class="hljs-selector-id">#False</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(()</span></span>)) <span class="hljs-selector-id">#False</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(&#123;&#125;)</span></span>) <span class="hljs-selector-id">#FALSE</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(-<span class="hljs-number">1</span>)</span></span>) <span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-string">&#x27;&#x27;</span>)</span></span>) <span class="hljs-selector-id">#False</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-string">&quot;False&quot;</span>)</span></span>) <span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-string">&quot;True&quot;</span>)</span></span>) <span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-number">0.0</span>)</span></span>)  <span class="hljs-selector-id">#False</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(<span class="hljs-number">1.0</span>)</span></span>)  <span class="hljs-selector-id">#True</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(bool(-<span class="hljs-number">0.0</span>)</span></span>) #False<br></code></pre></td></tr></table></figure><p>实际上，各种空的内容被判断为False，而非空内容被判断为True</p><p>数值类型中，只有0.0, -0.0和0是False</p><p>另外range(0) ,0j , None等也是False</p><p>布尔型参与的布尔运算中，使用的关联词是 and or not ，逻辑和一般逻辑运算相同。（不再详细介绍）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># True</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h4 id="特殊类型none"><a href="#特殊类型none" class="header-anchor">¶</a>特殊类型：None</h4><p>之所以放在这里，是因为None类型和布尔型的关系比较紧密。</p><p>None表示空，但是并不是空字符串、空列表等等，也不等于False（当然在条件判断中if None被认为是False），而是一个特殊的值，表示的是没有值，也就是空值，属于特殊类型NoneType，而且None是这个类型的唯一值。</p><p>None作用和其他语言中的Null，nil或者undefined类似，不过None可以赋给任何一个变量。</p><p>None实际上就是无返回值的实际返回值。</p><p>不管变量是什么值（包括空列表、空字符串等等），除非变量就是None，否则和None作相等的布尔运算时始终为False。</p><p>对于not 变量，如果变量就是None，not None被认为是True。因此，判定变量空操作时，比较建议写<em>if not 变量</em></p><p>此时不论是None还是其他空值，均返回True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python">a=<span class="hljs-literal">None</span><br>b = <span class="hljs-literal">False</span><br>c = []<br>d=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a)) <span class="hljs-comment">#输出类型</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bool</span>(<span class="hljs-literal">None</span>)) <span class="hljs-comment">#判断None的布尔类型</span><br><span class="hljs-keyword">if</span> a==b <span class="hljs-keyword">or</span> a==c <span class="hljs-keyword">or</span> a==d:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Y&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;N&quot;</span>)<br><span class="hljs-keyword">if</span> b <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> c <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> d <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Y&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;N&quot;</span>)<br><span class="hljs-comment"># 判断None和空列表、空字符串和False是否相等</span><br><span class="hljs-comment"># 输出结果:</span><br><span class="hljs-comment"># &lt;class &#x27;NoneType&#x27;&gt;</span><br><span class="hljs-comment"># False</span><br><span class="hljs-comment"># N</span><br><span class="hljs-comment"># N</span><br></code></pre></td></tr></table></figure><h3 id="4复数类型complex"><a href="#4复数类型complex" class="header-anchor">¶</a>4.复数类型：complex</h3><p>复数数据类型，简称复数类型，和其他语言不同，python中复数类型是内置类型，是数字类型的一部分，支持直接书写，不依赖其他库。</p><p>复数由实部和虚部组成，虚部带有后缀<strong>J/j</strong>，且实部和虚部的数值均为浮点数。</p><p>具体形式为 <em><strong>a+bj / a+bJ</strong></em>，a为实部，b为虚部。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">complex1</span>=10+5j<br><span class="hljs-attribute">complex2</span>=10-5j #可以是-号<br><span class="hljs-built_in">print</span>(complex1,<span class="hljs-string">&quot; &quot;</span>,type(complex1))<br><span class="hljs-comment"># 运行结果</span><br><span class="hljs-comment"># (10+5j)   &lt;class &#x27;complex&#x27;&gt;</span><br></code></pre></td></tr></table></figure><p>python支持从复数中提取实部和虚部：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">complex1</span>=123+321j<br><span class="hljs-attribute">r</span>=complex1.real<br><span class="hljs-attribute">i</span>=complex1.imag<br><span class="hljs-built_in">print</span>(r,<span class="hljs-string">&quot; &quot;</span>,type(r))<br><span class="hljs-built_in">print</span>(i,<span class="hljs-string">&quot; &quot;</span>,type(i))<br><span class="hljs-comment"># 输出结果为：</span><br><span class="hljs-comment"># 123.0   &lt;class &#x27;float&#x27;&gt; #实部内的数为浮点数，即使在复数中看起来是整数</span><br><span class="hljs-comment"># 321.0   &lt;class &#x27;float&#x27;&gt; #虚部内的数为浮点数，即使在复数中看起来是整数</span><br></code></pre></td></tr></table></figure><p>复数的计算：相信能看到这篇博客的你应该不能不会复数的计算😉，我就不写啦，自己去试试呗~</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——数据类型（一）简介</title>
    <link href="/xiaohei07.github.io/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%80)%E7%AE%80%E4%BB%8B/"/>
    <url>/xiaohei07.github.io/2023/03/19/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B(%E4%B8%80)%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1概念"><a href="#1概念" class="header-anchor">¶</a>1.概念：</h3><p>python中的数据类型主要是指变量所指的内存中对象的类型。</p><p>我们区分变量的数据类型主要是看其值和是否被强制转化过。</p><h3 id="2分类"><a href="#2分类" class="header-anchor">¶</a>2.分类：</h3><p>python中的基本数据类型共有六种，分别为:</p><ul class="lvl-0"><li class="lvl-2"><p>Number（数字） 包括整型、浮点型、复数型和布尔型</p></li><li class="lvl-2"><p>String（字符串）</p></li><li class="lvl-2"><p>List（列表）</p></li><li class="lvl-2"><p>Tuple（元组）</p></li><li class="lvl-2"><p>Set（集合）</p></li><li class="lvl-2"><p>Dictionary（字典）</p></li></ul><p>其中Number、String和Tuple是不可变数据类型，而List、Dictionary和Set是可变数据类型。</p><h3 id="3可变数据类型与不可变数据类型"><a href="#3可变数据类型与不可变数据类型" class="header-anchor">¶</a>3.可变数据类型与不可变数据类型：</h3><p>是指当该数据类型对应的变量的值改变后，内存地址是否发生了变化，如果内存地址不发生改变，则为可变数据类型，否则为不可变数据类型。</p><p>例如Number的值改变后其内存地址就会发生改变。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">a</span>=1<br><span class="hljs-built_in">print</span>(id(a))<br><span class="hljs-attribute">a</span>=2<br><span class="hljs-attribute">b</span>=2<br><span class="hljs-built_in">print</span>(id(a))<br><span class="hljs-built_in">print</span>(id(b))<br><span class="hljs-comment"># 输出结果：</span><br><span class="hljs-comment"># 140733592564520</span><br><span class="hljs-comment"># 140733592564552 a的地址改变了</span><br><span class="hljs-comment"># 140733592564552 b的地址和a的相同。</span><br></code></pre></td></tr></table></figure><p>鉴于每个部分的篇幅太长，接下来将会分成多篇文章进行讲解。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python基础——输入和输出详解</title>
    <link href="/xiaohei07.github.io/2023/03/18/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%AF%A6%E8%A7%A3/"/>
    <url>/xiaohei07.github.io/2023/03/18/python%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>(一)概念：</h3><p>此处说明的输入和输出是指控制台从键盘输入文本和输出在屏幕指定文字，暂不包括向文件的输入和输出。</p><p>输入是基于input()的函数输入，输出是基于print()的函数输出。</p><p>此外还将讲解print涉及的格式化输出。</p><h3 id="二基于input函数的输入"><a href="#二基于input函数的输入" class="header-anchor">¶</a>（二）基于input()函数的输入：</h3><h4 id="1基本用法"><a href="#1基本用法" class="header-anchor">¶</a>1.基本用法：</h4><p>input()函数的作用是获得键盘的输入数据。</p><p>一般格式： <em><strong>变量名=input(&lt;提示字符串&gt;)</strong></em></p><p>input()函数在接受输入前先输出提示字符串，等待用户的键盘输入。</p><p>以用户输入回车符作为结束的标志，随后input()函数结束，返回用户输入的字符串（回车符被丢弃）。</p><p>返回的字符串就是一行文本，且无论用户输入任何内容均被视为字符串，如需要其他类型，应对返回内容进行类型转化。</p><p>返回值被用来给变量赋值，否则返回值被丢弃，不会保留。</p><h4 id="2进阶用法"><a href="#2进阶用法" class="header-anchor">¶</a>2.进阶用法：</h4><ul class="lvl-0"><li class="lvl-2"><p>在提示字符串处加入变量：因为提示字符串必须是字符串的形式输出到终端，所以，如果希望在提示字符串处输出变量值，需要对非字符型的变量进行强制的类型转换。</p></li><li class="lvl-2"><p>input一次输入多个变量值：需要调用它所有的split()分割函数，这个函数的作用是一旦在输入中遇到它()中的内容就以其为分界符将输入内容分割开，对应的分割出的输入串数量我们也应该设置对应数量的变量来接收内容。另外，split后返回的是一个字符串列表，如要强制类型转换，需要在最外面再加一个map()对每个被分割的输入进行强制类型转换。（详见下方代码）</p></li></ul><h4 id="3代码展示"><a href="#3代码展示" class="header-anchor">¶</a>3.代码展示：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">testinput1 = <span class="hljs-string">&quot;请输入&quot;</span><br>name = <span class="hljs-built_in">input</span>(testinput1+<span class="hljs-string">&quot;名字\n&quot;</span>)  <span class="hljs-comment">#input()内有变量，\n是换行符</span><br>number = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(testinput1+name+<span class="hljs-string">&quot;他的序号数\n&quot;</span>)) <span class="hljs-comment">#对input结果进行强制类型转化</span><br>subject1,subject2,subject3 = <span class="hljs-built_in">input</span>(testinput1+<span class="hljs-built_in">str</span>(number)+<span class="hljs-string">&quot;号的三个学科名,以\&quot;,\&quot;分割\n&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>) <span class="hljs-comment">#input()得到多个输入值</span><br>score1,score2,score3 = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>,<span class="hljs-built_in">input</span>(testinput1+<span class="hljs-built_in">str</span>(number)+<span class="hljs-string">&quot;的三科成绩,以\&quot;,\&quot;分割\n&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>)) <span class="hljs-comment">#对input的多个输入值分别进行强制类型转化</span><br><span class="hljs-built_in">print</span>(subject1,subject2,subject3) <span class="hljs-comment">#展示结果</span><br><span class="hljs-built_in">print</span>(score1,score2,score3)<br></code></pre></td></tr></table></figure><h3 id="三基于print函数的输出"><a href="#三基于print函数的输出" class="header-anchor">¶</a>（三）基于print()函数的输出：</h3><p>print()函数可以说是python中大家认识最多的一个函数了，本次将会进行详细介绍。</p><h4 id="1基本用法"><a href="#1基本用法" class="header-anchor">¶</a>1.基本用法：</h4><p>函数语法为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(*objects, <span class="hljs-attribute">sep</span>=<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-attribute">file</span>=sys.stdout)<br></code></pre></td></tr></table></figure><p>其中objects对应复数，表示可以一次输出多个对象，用“,”进行分隔。</p><p>sep -用于间隔多个对象，默认是一个空格。</p><p>end -用于设定以什么为结尾，默认是换行符\n。</p><p>file -要写入的文件对象。</p><p>print()函数没有返回值。</p><p>print()函数可以输出任何变量，包括但不限于数值型、布尔型、列表型、字典型等等。</p><p>print()输出时end=的后面参数可以用条件语句来判断不同情况下输出的具体值。</p><p>代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span>(1) #输出数值<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;欧尼酱~&quot;</span>) #输出字符串<br><span class="hljs-built_in">print</span>(1,2,3,<span class="hljs-string">&quot;面对疾风吧&quot;</span>) #输出多个对象<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;www&quot;</span>,<span class="hljs-string">&quot;面对疾风吧&quot;</span>,<span class="hljs-string">&quot;com&quot;</span>,<span class="hljs-attribute">sep</span>=<span class="hljs-string">&quot;.&quot;</span>) #输出多个对象，并以<span class="hljs-string">&quot;.&quot;</span>分隔<br><span class="hljs-attribute">a</span>=3.1415926<br><span class="hljs-attribute">b</span>=<span class="hljs-string">&quot;abcdefg&quot;</span><br><span class="hljs-built_in">print</span>(a,b) #可以输出变量<br>list = [1, <span class="hljs-string">&#x27;a&#x27;</span>, 3,14]<br><span class="hljs-built_in">print</span>(list)  #输出列表变量<br>tuple = (1, <span class="hljs-string">&#x27;a&#x27;</span>, 3,14)<br><span class="hljs-built_in">print</span>(tuple)  #输出元组变量<br>dict = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: 1, <span class="hljs-string">&#x27;b&#x27;</span>: 2&#125;<br><span class="hljs-built_in">print</span>(dict)  # 输出字典变量<br><br>l= [1, 2, 3, 4]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> l:<br>    <span class="hljs-built_in">print</span>(x, <span class="hljs-attribute">end</span>=<span class="hljs-string">&#x27; &#x27;</span> <span class="hljs-keyword">if</span> x != l[-1] <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;\n&#x27;</span>) #不同情况输出的分隔符不同。<br></code></pre></td></tr></table></figure><h4 id="2格式化输出"><a href="#2格式化输出" class="header-anchor">¶</a>2.格式化输出：</h4><p>print中允许数据的格式化输出。其格式控制符和转换说明符用&quot;%&quot;分隔（C语言用逗号）</p><p>%字符在字符串中，是格式控制符，在后面则是转换说明符，%是标记转换的开始。</p><p>如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">s = <span class="hljs-string">&#x27;fxfILY&#x27;</span><br><span class="hljs-attribute">x</span> = <span class="hljs-built_in">len</span>(s)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;The length of %s is %d&#x27;</span> % (s,x)</span></span>) <br></code></pre></td></tr></table></figure><p>形式为***‘ 其他+%格式化字符 +其他 ’ % exp***</p><p>数据的格式化输出符号和描述：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haml"><span class="hljs-tag">%<span class="hljs-selector-tag">c</span></span> 格式化字符及其ASCII码<br><span class="hljs-tag">%<span class="hljs-selector-tag">s</span></span> 格式化字符串<br><span class="hljs-tag">%<span class="hljs-selector-tag">d</span></span> 格式化整数<br><span class="hljs-tag">%<span class="hljs-selector-tag">u</span></span> 格式化无符号整型<br><span class="hljs-tag">%<span class="hljs-selector-tag">o</span></span> 格式化无符号八进制数<br><span class="hljs-tag">%<span class="hljs-selector-tag">x</span></span> 格式化无符号十六进制数<br><span class="hljs-tag">%<span class="hljs-selector-tag">X</span></span> 格式化无符号十六进制数（大写）<br><span class="hljs-tag">%<span class="hljs-selector-tag">f</span></span> 格式化浮点数字，可指定小数点后的精度<br><span class="hljs-tag">%<span class="hljs-selector-tag">e</span></span> 用科学计数法格式化浮点数<br><span class="hljs-tag">%<span class="hljs-selector-tag">E</span></span> 作用同%e，用科学计数法格式化浮点数<br><span class="hljs-tag">%<span class="hljs-selector-tag">g</span></span> %f和%e的简写<br><span class="hljs-tag">%<span class="hljs-selector-tag">G</span></span> %f 和 %E 的简写<br><span class="hljs-tag">%<span class="hljs-selector-tag">p</span></span> 用十六进制数格式化变量的地址<br></code></pre></td></tr></table></figure><p>格式化操作符辅助指令：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode">*     定义宽度或者小数点精度<br>-     用做左对齐<br>+     在正数前面显示加号<span class="hljs-comment">( + )</span><br>&lt;sp&gt;  在正数前面显示空格<br><span class="hljs-attr">#     在八进制数前面显示零(&#x27;0</span><span class="hljs-string">&#x27;)，在十六进制前面显示&#x27;</span><span class="hljs-number">0</span>x<span class="hljs-string">&#x27;或者&#x27;</span><span class="hljs-number">0</span>X<span class="hljs-string">&#x27;(取决于用的是&#x27;</span>x<span class="hljs-string">&#x27;还是&#x27;</span>X<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">0     显示的数字前面填充&#x27;</span><span class="hljs-number">0</span><span class="hljs-string">&#x27;而不是默认的空格</span><br><span class="hljs-string">%     &#x27;</span><span class="hljs-meta">%</span><span class="hljs-meta">%</span><span class="hljs-string">&#x27;输出一个单一的&#x27;</span><span class="hljs-meta">%</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">(var) 映射变量(字典参数)</span><br><span class="hljs-string">m.n.  m是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">PI</span> = <span class="hljs-number">3</span>.<span class="hljs-number">141592653</span><br><span class="hljs-attribute">print</span>(&#x27;%<span class="hljs-number">10</span>.<span class="hljs-number">3</span>f&#x27;%PI)  #字段宽<span class="hljs-number">10</span>，精度<span class="hljs-number">3</span><br><span class="hljs-comment">#输出结果:     3.142（左边5个空格，以保证指定宽度为10成立，3f表明精确到小数点后三位）</span><br><br><span class="hljs-attribute">PI</span>=<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span><br><span class="hljs-attribute">print</span>(&#x27;%-<span class="hljs-number">10</span>.<span class="hljs-number">3</span>f&#x27; %PI) #-表示左对齐<br><span class="hljs-comment">#输出结果:3.142     (左对齐，仍为10个字符，但空格在右边)</span><br><br><span class="hljs-attribute">PI</span>=<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span><br><span class="hljs-attribute">print</span>(&#x27;%+f&#x27; % PI)  #+表示显式正负号<br><span class="hljs-comment">#输出结果:+3.141593(显示正号,类型f的默认精度为6位小数)  </span><br><br><span class="hljs-attribute">PI</span>=<span class="hljs-number">3</span>.<span class="hljs-number">1415926</span><br><span class="hljs-attribute">print</span>(&#x27;%<span class="hljs-number">010</span>.<span class="hljs-number">3</span>f&#x27;%PI) #<span class="hljs-number">0</span>表示转换值若位数不够则用<span class="hljs-number">0</span>填充<br><span class="hljs-comment">#输出结果:000003.142（字段宽度为10，精度为3，不足处用0填充空白）</span><br></code></pre></td></tr></table></figure><h4 id="3format函数"><a href="#3format函数" class="header-anchor">¶</a>3.format()函数：</h4><p>format()函数和%的格式化字符串功能类似，但更加强大。</p><p>形式上，format()函数用{|}来代替%（&quot;|&quot;可以是数字，代表后面的参数位置，也可以是变量名称，参数传递时直接传递给该变量），可以用接收参数的方式对字符串进行格式化。</p><p>参数位置可以不按显式顺序，参数也可以不用或者用多次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello &#123;0&#125;! I am &#123;1&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>)) <span class="hljs-comment">#按顺序</span><br><span class="hljs-comment"># 输入结果：Hello python! I am zzh</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello &#123;&#125; I am &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;python&#x27;</span>,<span class="hljs-string">&#x27;zzh&#x27;</span>)) <span class="hljs-comment">#默认顺序</span><br><span class="hljs-comment"># 输入结果：Hello python! I am zzh</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello &#123;1&#125;! I am &#123;0&#125;. &#123;0&#125; is alaways smart!&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-string">&#x27;python&#x27;</span>)) <span class="hljs-comment">#不按顺序+多次使用一个变量</span><br><span class="hljs-comment"># 输出结果：Hello python! I am zzh. zzh is alaways smart!</span><br><br>name = <span class="hljs-string">&#x27;zzh&#x27;</span><br>noname = <span class="hljs-string">&#x27;???&#x27;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;a&#125; love &#123;b&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a = name,b = noname)) <span class="hljs-comment">#使用变量</span><br><span class="hljs-comment">#输出结果：zzh love ???</span><br><br>name= [<span class="hljs-string">&#x27;zzh&#x27;</span>, <span class="hljs-string">&#x27;???&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;l[0]&#125; love &#123;l[1]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(l =name )) <span class="hljs-comment">#使用列表</span><br><br>names=&#123;<span class="hljs-string">&#x27;name1&#x27;</span>:<span class="hljs-string">&#x27;zzh&#x27;</span>,<span class="hljs-string">&#x27;name2&#x27;</span>:<span class="hljs-string">&#x27;???&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;name[name1]&#125; love &#123;name[name2]&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name=names)) <span class="hljs-comment">#用字典</span><br></code></pre></td></tr></table></figure><h4 id="4join函数"><a href="#4join函数" class="header-anchor">¶</a>4.join()函数：</h4><p>将一个包含多个字符串的可迭代对象，转为用分隔符s连接的字符。</p><p>不是字符串的可以参考上面的map()函数，第一个参数设置为str，将每个可迭代对象转化过来即可。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">number</span>=[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-attribute">print</span>(<span class="hljs-string">&quot;?&quot;</span>.join(map(str,(number))))<br><span class="hljs-comment">#输出结果: 0?1?2?3?4?5?6</span><br></code></pre></td></tr></table></figure><p>其他内容暂且不再详细介绍，暂时掌握这些基本够用了。</p>]]></content>
    
    
    <categories>
      
      <category>python_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>知识点</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>v2rayN入门使用介绍</title>
    <link href="/xiaohei07.github.io/2023/03/18/v2rayN%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <url>/xiaohei07.github.io/2023/03/18/v2rayN%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一引言"><a href="#一引言" class="header-anchor">¶</a>（一）引言：</h3><p>本人认为最舒服的一种（）方法。所以在此记录(●ˇ∀ˇ●)。</p><p>v2rayN可以用于your computer，无论是windows系统还是Linux系统，本文只讲述windows系统的安装使用方法（如果你Linux玩明白了我这篇教程容不下你`(<em>&gt;﹏&lt;</em>)′）。</p><p>因为本人目前尚未拥有自己的服务器，暂时没有搭建的打算，所以均使用现成的东西（可能需要一点小小的cost）(～￣▽￣)～。</p><p>本文是图文教程，向各位小白尽可能地详细讲解每一步的操作。</p><p>（新的附加提醒：节点就是配置哦）</p><h3 id="二下载和安装"><a href="#二下载和安装" class="header-anchor">¶</a>（二）下载和安装：</h3><p>登录你的github，搜索2dust这位大神，在他的热门存储库中，v2rayN名列榜首，直接点击进入即可。</p><p><a href="https://imgse.com/i/ppJl8N4"><img src="https://s1.ax1x.com/2023/03/18/ppJl8N4.jpg" alt="ppJl8N4.jpg"></a></p><p>（如果你不知道什么是github，强烈建议百度一下，学计算机不知道github会被人看不起的~）</p><p>如果你懒得去找，直接点击这个链接即可：<a href="https://github.com/2dust/v2rayN">v2rayN下载</a>。(请放心，链接绝对无害，只是有可能不稳定~ github只用国内链接访问懂得都懂)。</p><p>进入页面后，先不要直接找到链接就下载，先点击右侧releases下面的Lastest版本（如果你会使用github且对预发布版本感兴趣可以直接点releases下载最新预发布版本，看不懂的括号内内容当不存在就行）。</p><p><a href="https://imgse.com/i/ppJlNg1"><img src="https://s1.ax1x.com/2023/03/18/ppJlNg1.jpg" alt="ppJlNg1.jpg"></a></p><p>截止到我更新的日期，最新发布版本是5.39。</p><p>进入5.39版本页面后，页面靠下方位置有一个Assets (4) ，下面有四个文件，我们将从这四个中选择下载的程序。</p><p>后面两个不是我们的目标，我们选择前两个中的一个下载：</p><p>如果你是新手，下载那个带Core的zip文件，这个Core是指此压缩包自带内核，能够省去许多麻烦。（另一个则是无内核的，不用管）</p><p><a href="https://imgse.com/i/ppJlc8A"><img src="https://s1.ax1x.com/2023/03/18/ppJlc8A.png" alt="ppJlc8A.png"></a></p><p>点击后进行下载。如果出现如下提示：</p><p><a href="https://imgse.com/i/ppJlggI"><img src="https://s1.ax1x.com/2023/03/18/ppJlggI.png" alt="ppJlggI.png"></a></p><p>我们需要暂时关闭掉windows的系统防护功能（无需担心软件问题，这个很靠谱）。</p><p>点击你电脑左下角的win窗口，点击上面的设置，再点击windows安全中心（如果操作不对百度一下，每个电脑的进入方法可能不同）。再点击病毒和威胁防护，在其中关闭你的实时保护/安全保护等等（这个建议自行百度，每个电脑的界面都可能不同）。</p><p><a href="https://imgse.com/i/ppJl2vt"><img src="https://s1.ax1x.com/2023/03/18/ppJl2vt.jpg" alt="ppJl2vt.jpg"></a></p><p>再次下载，成功。</p><p>压缩包放到C盘以外你需要的文件夹中，在该文件夹进行解压</p><p><a href="https://imgse.com/i/ppJlWKP"><img src="https://s1.ax1x.com/2023/03/18/ppJlWKP.png" alt="ppJlWKP.png"></a></p><p>打开文件夹，点击v2rayN.exe即可运行（建议添加一个快捷方式到你的桌面）。</p><p><a href="https://imgse.com/i/ppJlfDf"><img src="https://s1.ax1x.com/2023/03/18/ppJlfDf.png" alt="ppJlfDf.png"></a></p><p>进入如下页面。</p><p><a href="https://imgse.com/i/ppJl5VS"><img src="https://s1.ax1x.com/2023/03/18/ppJl5VS.png" alt="ppJl5VS.png"></a></p><p>此时说明你的下载和安装成功了。</p><h3 id="三功能介绍"><a href="#三功能介绍" class="header-anchor">¶</a>（三）功能介绍：</h3><p>下面对v2rayN中的每个我们需要的选项进行详细介绍：</p><p>服务器：服务器内有很多添加选项，如果你拥有服务器/相关的服务器支持服务，在里面填好相应的内容即可（因本人无服务器不进行介绍，如果以后我购买了服务器自己搭建的话会回来更新的）。另外当你购买了某些服务后，它们会提供批量URL允许你复制到剪切板上，此时你只需要点击服务器中的从剪切板批量导入url即可获得对应的一系列服务器服务，如果是扫二维码点击扫描屏幕二维码即可。你也可以在这里测试你使用的服务器的延迟，导出你的服务器的URL进行分享。</p><p><a href="https://imgse.com/i/ppYiapF"><img src="https://s1.ax1x.com/2023/03/18/ppYiapF.jpg" alt="ppYiapF.jpg"></a></p><p>订阅：当你订购了相关的订阅之后在这里更新配置，包括分组的内容，相关的别名（帮助你记忆是哪个订阅的）等等，通常比较常用的是不通过代理更新订阅（看你的订阅要求按情况更新即可）。</p><p><a href="https://imgse.com/i/ppYiGT0"><img src="https://s1.ax1x.com/2023/03/18/ppYiGT0.jpg" alt="ppYiGT0.jpg"></a></p><p>分享：将你的订阅分享给他人，根据你的需要使用就行（请尽量不要大规模分享，这可以说是在作死了）。</p><p>设置：包括参数设置、路由设置等等。</p><p>​建议无需要不要乱改这些配置，不过建议将参数设置中的v2rayN设置中的开机自动启动打开（如果不行试试管理员身份设置），启用统计打开，如有需要也启用安全协议TLS v1.3即可。</p><p>​如果你的设置比较复杂，可以在点击设置下面的备份v2rayN配置文件，存储到一个安全的地方，以后需要恢复时打开它即可恢复配置。</p><p><a href="https://imgse.com/i/ppYitYT"><img src="https://s1.ax1x.com/2023/03/18/ppYitYT.jpg" alt="ppYitYT.jpg"></a></p><p><a href="https://imgse.com/i/ppYi8wq"><img src="https://s1.ax1x.com/2023/03/18/ppYi8wq.jpg" alt="ppYi8wq.jpg"></a></p><p>重启服务：顾名思义，就是点击后会将你的代理服务重启，卡了或者有问题时可以刷新试试。</p><p>检查更新：等你熟悉了之后如果考虑更新到新版本再使用，刚开始时不建议更新。</p><p>帮助：你可以在这里切换中英文和访问官网。</p><p>推广：为你推荐一些机场，随机排序（当然点前几个也是可以的），如果你没有任何VPN服务又有需要的话，可以在这里面购买你需要的服务（我用的是VC喵提供的服务，一个月8元24G，够用，速度还可以）。</p><p>你以为这就结束了吗？</p><p>不！最重要的点击功能在你的右下角v2rayN的图标上！</p><p>右击你的v2ray图标，下面的四个功能是我刚才提及的比较常用的几个功能。</p><p>上面的呢？正是v2rayN的服务开关、服务器指定和路由设置！</p><p><a href="https://imgse.com/i/ppYi3mn"><img src="https://s1.ax1x.com/2023/03/18/ppYi3mn.png" alt="ppYi3mn.png"></a></p><p>我们分别来介绍</p><p>系统代理：有三个选项，清除系统代理就是关闭你的v2rayN服务，不会使用你的流量；自动配置系统代理就是打开你的v2rayN服务，开始使用你的流量；不改变系统代理是保持“使用代理服务器”的原状，根据你的windows设置内的代理状态决定是否开启代理。通常你只需要使用前两项即可。</p><p><a href="https://imgse.com/i/ppYiNfU"><img src="https://s1.ax1x.com/2023/03/18/ppYiNfU.png" alt="ppYiNfU.png"></a></p><p>路由：分为全局，绕过大陆和黑名单。全局就是不管你访问什么网站均开启代理，这会导致访问部分国内站点缓慢or失败，一般很少使用；绕过大陆就是非国内站点均开启代理，较为常用；而黑名单是指只有访问某些不可直接访问的站点时才使用代理，最为常用。</p><p><a href="https://imgse.com/i/ppYidl4"><img src="https://s1.ax1x.com/2023/03/18/ppYidl4.png" alt="ppYidl4.png"></a></p><p>服务器：当你有多个服务器时，可以在这里进行不同服务器的选择（同一时刻不同地区服务器有好有坏）。</p><h3 id="四总结"><a href="#四总结" class="header-anchor">¶</a>（四）总结：</h3><p>这只是对v2ray的一个初步介绍，既没有说明如何自己搭建服务器/购买服务器，也没有说明很多配置的修改，算是一个入门级的使用介绍。随着各位水平的深入，会发现我所讲的这些都是皮毛（当然也可能你现在觉得讲的就是皮毛，但请不要狠狠地羞辱我😖），到时候更多的内容，就需要你们自己去探索和发掘啦~</p><p>祝各位使用愉快，能够看到更广阔的世界！！</p>]]></content>
    
    
    <categories>
      
      <category>生活寄巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ladder</tag>
      
      <tag>VPN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——成员类</title>
    <link href="/xiaohei07.github.io/2023/03/18/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%88%90%E5%91%98%E7%B1%BB/"/>
    <url>/xiaohei07.github.io/2023/03/18/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%88%90%E5%91%98%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念:</h3><p>当一个类的数据成员含有一个前面已经声明的类的对象时，这个被包含的类被称作成员类，该数据成员为成员对象。（即类的成员是一个其他类的对象）</p><p>这被称作类的包含（has A），是程序设计中的一种软件重用技术。定义一个新的类时，通过编译器把另一个类“抄”进来。</p><h3 id="二特性"><a href="#二特性" class="header-anchor">¶</a>（二）特性：</h3><ol><li class="lvl-3"><p>出现成员对象时，该类的构造函数也要初始化成员对象，且必须使用初始化语法形式（在构造函数体内将t初始化无效）。</p></li><li class="lvl-3"><p>如果构造函数的成员初始化列表没有对成员对象初始化时，则使用成员对象的缺省构造函数。</p></li><li class="lvl-3"><p>如果成员对象没有缺省构造函数（仅有参构造函数），那么必须在类的初始化列表对成员对象进行显式的初始化。</p></li><li class="lvl-3"><p>一个含有成员对象的类实例化时要优先调用成员对象的构造函数，然后再调用该类的构造函数；析构时先调用含成员对象的类的析构函数，再调用成员对象对应类的析构函数。</p></li><li class="lvl-3"><p>如果一个类有多个成员类对象，构造函数的调用顺序是对象在类中被声明的顺序，而不是在构造函数初始化列表中的顺序。</p></li></ol><h3 id="三代码实现"><a href="#三代码实现" class="header-anchor">¶</a>（三）代码实现：</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include&lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">second</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-built_in">second</span>(i3) <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Time类有参构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-title function_">Time</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Time类缺省构造函数&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">second</span> = <span class="hljs-number">0</span>; <br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Gethour</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">hour</span>; &#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Getminute</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">minute</span>; &#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">Getsecond</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">second</span>; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) &#123; <span class="hljs-built_in">hour</span> = i1; <span class="hljs-built_in">minute</span> = i2; <span class="hljs-built_in">second</span> = i3; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">second</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>~<span class="hljs-title function_">Time</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Time类析构函数&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">year</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">month</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">day</span>;<br>Time t;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Date</span>() &#123;<br><span class="hljs-built_in">year</span> = <span class="hljs-built_in">month</span> = <span class="hljs-built_in">day</span> = <span class="hljs-number">0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;Date类缺省构造函数&quot;</span> &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-title function_">Date</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-title function_">t</span>(&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;), <span class="hljs-built_in">year</span>(i1), <span class="hljs-built_in">month</span>(i2), <span class="hljs-built_in">day</span>(i3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Date类有参构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span>();<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3); <br>~<span class="hljs-title function_">Date</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Date类析构函数&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">void</span> Date::<span class="hljs-title function_">display</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">year</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">month</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">day</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>t.<span class="hljs-property">display</span>();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> Date::<span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3)<br>&#123;<br>t.<span class="hljs-property">settime</span>(i1,i2,i3);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>()<br>&#123;<br>Date d;<br>d.<span class="hljs-property">display</span>();<br>d.<span class="hljs-property">settime</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>d.<span class="hljs-property">display</span>();<br>Date <span class="hljs-title function_">d1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>d1.<span class="hljs-property">display</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><a href="https://imgse.com/i/ppJEii6"><img src="https://s1.ax1x.com/2023/03/18/ppJEii6.png" alt="ppJEii6.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——友元</title>
    <link href="/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%8F%8B%E5%85%83/"/>
    <url>/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%8F%8B%E5%85%83/</url>
    
    <content type="html"><![CDATA[<h3 id="一引言"><a href="#一引言" class="header-anchor">¶</a>（一）引言:</h3><p>类具有封装和信息隐藏的特性，只有类的成员函数能够访问类的私有成员，程序中其他的函数在一般情况下是无法访问私有成员的。</p><p>然而，有些时候，类要求自己的成员可对部分外部函数/类可见，如果将其内部数据成员和成员函数均声明为公有的，会破坏类隐藏的特性。另外，对某些成员函数多次调用时，由于参数传递、类型检查和安全性检查等需要时间开销，定义过多的成员函数会影响程序的运行效率。</p><p>因此，为了解决上述问题，需要在类中声明友元——为了让非成员函数/类即普通函数/类能够访问类的私有成员。</p><h3 id="二概念"><a href="#二概念" class="header-anchor">¶</a>（二）概念：</h3><p>友元是一种定义在类外部的普通函数或类或类的成员函数，需要在类的体内进行声明。</p><p>友元的关键字为 <strong>friend</strong>，在声明时加在需要设为友元的类/函数头前。</p><p>友元本身不是成员函数，但可以访问类中的私有成员，与成员函数的特权相同。</p><p>友元能够提高程序的运行效率，但是它破坏了类的封装性和隐蔽性，需要谨慎使用。</p><h3 id="三特性"><a href="#三特性" class="header-anchor">¶</a>（三）特性：</h3><ol><li class="lvl-3"><p>友元只能出现在类的定义中。</p></li><li class="lvl-3"><p>友元只能通过其所在类的对象访问它所在类的成员。</p></li><li class="lvl-3"><p>友元关系是单向的，不具有交换性，即A是B的友元，但B不一定是A的友元。</p></li><li class="lvl-3"><p>友元关系不具有传递性，即A是B的友元，B是C的友元，但是C不一定是A的友元。（以声明为准）</p></li><li class="lvl-3"><p>友元的声明位置在类中是任意的，不受类访问限定符限制。</p></li><li class="lvl-3"><p>友元函数不能用const修饰，也没有this指针。</p></li><li class="lvl-3"><p>一个函数/类可以是多个类的友元函数。</p></li><li class="lvl-3"><p>友元的成立是由这个类来决定的。</p></li></ol><h3 id="四分类"><a href="#四分类" class="header-anchor">¶</a>（四）分类：</h3><h4 id="1普通函数做友元"><a href="#1普通函数做友元" class="header-anchor">¶</a>1.普通函数做友元：</h4><p>多用于运算符重载(详见<a href>c++类——运算符重载</a>)。</p><p>形式为：类内  <em><strong>friend 返回类型 函数名(参数表) ;</strong></em></p><p>​   类外 <em><strong>返回类型 函数名(参数表) { 函数体}</strong></em></p><p>参数表内一定有类的值传递/引用传递/地址传递（用于访问类的私有成员，要不然定义它为友元干嘛呢）。</p><h4 id="2类做友元"><a href="#2类做友元" class="header-anchor">¶</a>2.类做友元：</h4><p>友元类中所有的成员函数均为友元函数。</p><p>编译器对格式有严格要求：</p><ol><li class="lvl-3"><p>首先对友元类进行前置声明（有些编译器可以省略，会自动补全）。</p></li><li class="lvl-3"><p>然后定义要声明友元类的一般类，此时在其中可以将友元类声明为友元。</p></li><li class="lvl-3"><p>最后定义友元类本身，因为前面对声明友元类的一般类进行了定义，此时可以在其中访问一般类的私有数据成员。</p></li></ol><p>即按声明友元类——定义一般类——定义友元类的顺序进行，一般类要声明友元，友元类可以访问一般类的私有数据成员。</p><h4 id="3类的成员函数做友元"><a href="#3类的成员函数做友元" class="header-anchor">¶</a>3.类的成员函数做友元：</h4><p>声明时要在函数名前加上类名::（是成员函数所在类）。</p><p>编译器对其格式要求更加严格。</p><ol><li class="lvl-3"><p>首先对一般类进行前置声明（在成员函数做友元时此句绝对不可以省略）。</p></li><li class="lvl-3"><p>然后对含友元函数的类进行定义。此时，要被用于作为友元函数的成员函数只进行声明，不进行定义。成员函数的参数表一定有一般类的值/引用/指针用于访问其私有成员。</p></li><li class="lvl-3"><p>定义一般类，声明友元函数（做友元函数的成员函数所在类类名一定要加上）。</p></li><li class="lvl-3"><p>定义做友元函数的成员函数（在其所在类的类外），因为前面的三步，此时才可以访问一般类的私有成员。</p></li></ol><h3 id="五代码实现"><a href="#五代码实现" class="header-anchor">¶</a>（五）代码实现：</h3><h4 id="1普通函数做友元"><a href="#1普通函数做友元" class="header-anchor">¶</a>1.普通函数做友元：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">double</span> <span class="hljs-title">Distance</span><span class="hljs-params">(Point&amp; a, Point&amp; b)</span></span>;<span class="hljs-comment">//一般建议友元函数声明放在最前面</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Point</span>()<br>&#123;<br>x = <span class="hljs-number">0</span>;<br>y = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br>~<span class="hljs-built_in">Point</span>()<br>&#123;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Distance</span><span class="hljs-params">(Point&amp; a, Point&amp; b)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> temp1 = a.x - b.x;<span class="hljs-comment">//因友元可以访问a和b对象的私有数据成员</span><br><span class="hljs-type">double</span> temp2 = a.y - b.y;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(temp1 * temp1 + temp2 * temp2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Distance2</span><span class="hljs-params">(Point&amp; a, Point&amp; b)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">double</span> temp1 = a.<span class="hljs-built_in">getX</span>() - b.<span class="hljs-built_in">getX</span>();<span class="hljs-comment">//不是友元函数，通过类公有的成员函数获得私有数据成员值</span><br><span class="hljs-type">double</span> temp2 = a.<span class="hljs-built_in">getY</span>() - b.<span class="hljs-built_in">getY</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(temp1 * temp1 + temp2 * temp2);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>);<br>Point* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>);<br>Point* p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>);<br><span class="hljs-type">double</span> d1 = <span class="hljs-built_in">Distance</span>(*p1, *p2);<br><span class="hljs-type">double</span> d2 = <span class="hljs-built_in">Distance</span>(*p1, *p3);<br>cout &lt;&lt; d1 &lt;&lt; endl &lt;&lt; d2 &lt;&lt; endl;<span class="hljs-comment">//均可成功</span><br><span class="hljs-keyword">delete</span> p1;<br><span class="hljs-keyword">delete</span> p2;<br><span class="hljs-keyword">delete</span> p3;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2类做友元"><a href="#2类做友元" class="header-anchor">¶</a>2.类做友元：</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include&lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>; <span class="hljs-comment">//前置声明，部分编译器可省略。</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br>friend <span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<span class="hljs-comment">//友元类声明</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">second</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-built_in">second</span>(i3) &#123;&#125;<br><span class="hljs-title function_">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">second</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">second</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span><span class="hljs-comment">//定义友元类</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">year</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">month</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">day</span>;<br>Time t;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Date</span>()&#123; <span class="hljs-built_in">year</span> = <span class="hljs-built_in">month</span> = <span class="hljs-built_in">day</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-title function_">Date</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">year</span>(i1), <span class="hljs-built_in">month</span>(i2), <span class="hljs-built_in">day</span>(i3)&#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">year</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">month</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">day</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>cout &lt;&lt; t.<span class="hljs-property">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; t.<span class="hljs-property">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; t.<span class="hljs-property">second</span> &lt;&lt; endl;<span class="hljs-comment">//友元类使用Time类私有数据成员</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3)<br>&#123;<br>t.<span class="hljs-property">hour</span> = i1, t.<span class="hljs-property">minute</span> = i2, t.<span class="hljs-property">second</span> = i3;<span class="hljs-comment">//友元类修改Time类私有数据成员的值</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>() <br>&#123;<br>Date d;<span class="hljs-comment">//可以调用Time类的构造函数</span><br>d.<span class="hljs-property">display</span>();<span class="hljs-comment">//可以使用上面创建的Time对象的值</span><br>d.<span class="hljs-property">settime</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//可修改</span><br>d.<span class="hljs-property">display</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3类的成员函数做友元"><a href="#3类的成员函数做友元" class="header-anchor">¶</a>3.类的成员函数做友元：</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include&lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span>; <span class="hljs-comment">//前置声明一般类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>  <span class="hljs-comment">//定义Date类，此类含有友元函数</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">year</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">month</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">day</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Date</span>() &#123; <span class="hljs-built_in">year</span> = <span class="hljs-built_in">month</span> = <span class="hljs-built_in">day</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-title function_">Date</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">year</span>(i1), <span class="hljs-built_in">month</span>(i2), <span class="hljs-built_in">day</span>(i3) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span>(Time&amp; t); <span class="hljs-comment">//声明成员函数，此为Time类的友元函数</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3, Time&amp; t); <span class="hljs-comment">//同上</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br>friend <span class="hljs-keyword">void</span> Date::<span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3, Time&amp; t);<span class="hljs-comment">//Date类的成员函数做友元函数的声明</span><br>friend <span class="hljs-keyword">void</span> Date::<span class="hljs-title function_">display</span>(Time &amp;t);<span class="hljs-comment">//同上</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> <span class="hljs-built_in">second</span>;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-built_in">second</span>(i3) &#123;&#125;<br><span class="hljs-title function_">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">second</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">second</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">void</span> Date::<span class="hljs-title function_">display</span>(Time&amp; t) <span class="hljs-comment">//定义Date类要做友元函数的成员函数，此时可访问Time类私有成员 </span><br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">year</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">month</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">day</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>cout &lt;&lt; t.<span class="hljs-property">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; t.<span class="hljs-property">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; t.<span class="hljs-property">second</span> &lt;&lt; endl; <span class="hljs-comment">//可以访问Time类的私有成员</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> Date::<span class="hljs-title function_">settime</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3, Time&amp; t) <span class="hljs-comment">//同上</span><br>&#123;<br>t.<span class="hljs-property">hour</span> = i1, t.<span class="hljs-property">minute</span> = i2, t.<span class="hljs-property">second</span> = i3;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>() <br>&#123;<br>Date d;<br>Time t;<br>d.<span class="hljs-property">display</span>(t);<br>d.<span class="hljs-property">settime</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,t);<br>d.<span class="hljs-property">display</span>(t);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——常成员</title>
    <link href="/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%B8%B8%E6%88%90%E5%91%98/"/>
    <url>/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%B8%B8%E6%88%90%E5%91%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念:</h3><p>类的常成员包括常数据成员，常成员函数，常对象。</p><p>下面每一部分分别介绍一个内容。</p><h3 id="二常数据成员"><a href="#二常数据成员" class="header-anchor">¶</a>（二）常数据成员：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>常数据成员是指在类中定义的不能修改其值的一些数据成员（只读变量），与常变量类似，一经赋值就无法再次进行更改。</p><p>形式为：<em><strong>const 类型 数据成员名;</strong></em></p><h4 id="2-特点"><a href="#2-特点" class="header-anchor">¶</a>2. 特点：</h4><ul class="lvl-0"><li class="lvl-2"><p>不同对象的相同常数据成员可以不同，但对于单个对象来说，常数据成员在初始化后是不可变的。</p></li><li class="lvl-2"><p>初始化时只允许通过初始化列表进行初始化，不允许在构造函数体内进行初始化/赋值等改变左值的操作。</p></li><li class="lvl-2"><p>对于任何函数，无论是成员函数、友元函数还是类外函数，均不允许修改其值，只能读取。</p></li></ul><h4 id="3-代码实现"><a href="#3-代码实现" class="header-anchor">¶</a>3. 代码实现：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Simple</span>():<span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>)<br>&#123;<br>x=<span class="hljs-number">0</span>;<span class="hljs-comment">//错误！不允许在构造函数体内初始化常数据成员x的值！</span><br>cout &lt;&lt; <span class="hljs-string">&quot;创建对象&quot;</span> &lt;&lt; endl;<br>y = <span class="hljs-number">0</span>; <br>&#125;;<br><span class="hljs-built_in">Simple</span> (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建对象&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showXY</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resetXY</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123;<br>x = a, y = b; <span class="hljs-comment">//错误！不允许修改常数据成员x的值！</span><br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Simple_thisuse</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>(*<span class="hljs-keyword">this</span>).x += a;<span class="hljs-comment">//错误！不允许修改常数据成员x的值！</span><br>(*<span class="hljs-keyword">this</span>).y += b;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>~<span class="hljs-built_in">Simple</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;释放对象&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Simple ss;<br><span class="hljs-function">Simple <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<span class="hljs-comment">//在构造函数处对常数据成员赋值</span><br>ss.<span class="hljs-built_in">showXY</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三常成员函数"><a href="#三常成员函数" class="header-anchor">¶</a>（三）常成员函数：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>用const修饰的成员函数即为常成员函数。实际上，const是在修饰该成员函数隐含的this指针。</p><p>（<em><strong>const 类名</strong></em> ***** <em><strong>const this</strong></em>）</p><p>形式：<em><strong>返回类型 成员函数名(参数表)  const { 成员函数体 }</strong></em></p><p>要注意const在成员函数开头时表示的是<strong>返回值是const</strong>的，即返回值不可修改。</p><p>const必须加在成员函数头部的<strong>结尾</strong>。</p><h4 id="2-特点"><a href="#2-特点" class="header-anchor">¶</a>2. 特点：</h4><ul class="lvl-0"><li class="lvl-2"><p>不更新对象的数据成员，但是都能够访问（读取）。</p></li><li class="lvl-2"><p>不能在常成员函数中调用没有用const修饰的成员函数，<strong>只能调用常成员函数</strong>。</p></li><li class="lvl-2"><p>可以被其他不是常成员函数的成员函数调用。</p></li><li class="lvl-2"><p>const关键字可以用来<strong>区别成员函数的重载</strong>情况——通常非const成员函数也需要定义const版本的重载函数，用于常对象对该函数功能的调用。</p></li><li class="lvl-2"><p>在类外写实现时<strong>const仍要保留</strong>。</p></li></ul><h4 id="3-代码实现"><a href="#3-代码实现" class="header-anchor">¶</a>3. 代码实现：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> x;<br><span class="hljs-built_in">int</span> y;<br><span class="hljs-keyword">public</span>:<br>Simple():x(<span class="hljs-number">0</span>),y(<span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建对象&quot;</span> &lt;&lt; endl;<br><br>&#125;;<br>Simple (<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) : x(a), y(b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建对象&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showXY</span>()</span><br>&#123;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showXY</span>() <span class="hljs-keyword">const</span>  <span class="hljs-comment">//正确，不修改任意成员变量，可以加const</span></span><br>&#123;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetXY</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> <br>&#123;<br>x = a, y = b;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetXY</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>) <span class="hljs-keyword">const</span> <span class="hljs-comment">//错误，修改了成员变量，不可以加const</span></span><br>&#123;<br>x = a, y = b; <br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Simple_thisuse</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>) <span class="hljs-comment">//const加入位置错误</span></span><br>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>(*<span class="hljs-keyword">this</span>).x += a;<br>(*<span class="hljs-keyword">this</span>).y += b;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>~Simple()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;释放对象&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><br>Simple ss;<br><span class="hljs-function">Simple <span class="hljs-title">s</span>(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span></span>)</span>;<br>ss.showXY();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四常对象"><a href="#四常对象" class="header-anchor">¶</a>（四）常对象：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>在声明对象前加const称该对象为常对象。</p><p>形式：<em><strong>类名 const 对象名[(参数表)]</strong></em> / <em><strong>const 类名 对象名[(参数表)]</strong></em> 两种意义相同。</p><h4 id="2-特点"><a href="#2-特点" class="header-anchor">¶</a>2. 特点：</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>常对象只能调用常成员函数，不能调用非const成员函数。</strong>——常对象无法修改任何数据成员。</p></li><li class="lvl-2"><p>常对象中的数据成员<strong>必须要有初值</strong>，一经确定将无法改变。</p></li><li class="lvl-2"><p>常成员的成员函数/数据成员不一定是常成员函数/常数据成员，但表现为常成员函数/常数据成员。</p></li></ul><h4 id="3代码实现"><a href="#3代码实现" class="header-anchor">¶</a>3.代码实现：</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Simple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> x;<br><span class="hljs-built_in">int</span> y;<br><span class="hljs-keyword">public</span>:<br>Simple():x(<span class="hljs-number">0</span>),y(<span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建对象&quot;</span> &lt;&lt; endl;<br><br>&#125;;<br>Simple (<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) : x(a), y(b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;创建对象&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showXY</span>()</span><br>&#123;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showXY</span>() <span class="hljs-keyword">const</span>  <span class="hljs-comment">//正确，不修改任意成员变量，可以加const</span></span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用const版本:&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resetXY</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span> <br>&#123;<br>x = a, y = b;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Simple_thisuse</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>) <span class="hljs-comment">//const加入位置错误</span></span><br>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>(*<span class="hljs-keyword">this</span>).x += a;<br>(*<span class="hljs-keyword">this</span>).y += b;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>~Simple()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;释放对象&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>Simple ss;<br><span class="hljs-function">Simple <span class="hljs-title">s</span>(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">2</span></span>)</span>;<br>ss.showXY();<br><span class="hljs-keyword">const</span> Simple s1;<br><span class="hljs-function">Simple <span class="hljs-keyword">const</span> <span class="hljs-title">s2</span>(<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">3</span></span>)</span>;<span class="hljs-comment">//两种都可以</span><br>s1.resetXY(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">//不可以调用非常成员函数</span><br>s2.showXY();<span class="hljs-comment">//调用const版本</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——析构函数</title>
    <link href="/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念:</h3><p>析构函数是一个特殊的成员函数。</p><p>析构函数的功能与构造函数是完全相反的。析构函数无需用户进行调用，而是在对象生命周期结束需要进行释放时自动调用，完成对对象的释放和对象使用的资源的清理工作，但析构函数不操作对象占用的内存，也不删除对象——析构后这部分内存可以被分配给新对象使用。</p><h3 id="二特性"><a href="#二特性" class="header-anchor">¶</a>（二）特性：</h3><ul class="lvl-0"><li class="lvl-2"><p>析构函数的形式是：<em><strong>~类名(){ 析构函数体 }</strong></em>  （~表示取反，意思是和构造函数性质相反。）</p></li><li class="lvl-2"><p>析构函数无参数，也无返回值。</p></li><li class="lvl-2"><p>析构函数不允许重载，一个类的析构函数唯一。</p></li><li class="lvl-2"><p>用户在类中未定义自己的析构函数时编译系统会自动生成默认的析构函数，但仅有形式，不会进行任何操作。</p></li><li class="lvl-2"><p>对于静态局部对象，函数调用结束不会释放，不执行析构函数，只在程序结束时才调用其析构函数释放对象。</p></li><li class="lvl-2"><p>如果用new动态建立对象，只在delete释放对象时才调用析构函数。</p></li></ul><h3 id="三代码实现"><a href="#三代码实现" class="header-anchor">¶</a>（三）代码实现：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;  <br><span class="hljs-type">int</span> minute;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-type">int</span>* p;<span class="hljs-comment">//动态指针使用</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>() &#123; hour = minute = sec = <span class="hljs-number">0</span>; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-built_in">sec</span>(i3) &#123; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); &#125;<br>~<span class="hljs-built_in">Time</span>() <br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;执行析构函数&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-comment">//如果没有这句话，系统不会对动态指针指向内存空间进行释放，可能会发生内存泄漏</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Time <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br>t<span class="hljs-number">1.</span><span class="hljs-built_in">show_time</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//执行析构函数</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——静态成员</title>
    <link href="/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    <url>/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念:</h3><p>类成员冠以static声明时，称为静态成员。静态成员用于解决类内数据共享的问题，既能够避免使用全局变量，又能够让同类的多个对象数据共享。</p><p>如果使用全局变量对封装的类来说并不安全，因为其他的类外函数能共享、修改全局变量，同时容易发生名字的冲突问题。</p><p>静态成员包括静态数据成员和静态成员函数。</p><p>下面分别介绍。</p><h3 id="二静态数据成员"><a href="#二静态数据成员" class="header-anchor">¶</a>（二）静态数据成员：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>c++类中声明数据成员时, 加上static关键字声明的成员成为静态数据成员。</p><p>形式：<em><strong>类内：static 数据类型 变量名;</strong></em> 声明</p><p>​<em><strong>类外：数据类型 类名::变量名=值;</strong></em>  / <em><strong>数据类型 类名::变量名;</strong></em> 定义和初始化</p><h4 id="2-特点"><a href="#2-特点" class="header-anchor">¶</a>2. 特点：</h4><ol><li class="lvl-3"><p>类中的静态数据成员遵守public、protected、private规则，但是<strong>只能在类中进行声明</strong>，<strong>不允许在类中进行定义和初始化</strong>（为了避免产生多个对象时多次定义初始化导致值的改变，导致数据变化。在类外一经定义必须初始化。</p></li><li class="lvl-3"><p>被类的所有对象共享，<strong>只有一份内存,<strong>保存在</strong>静态存储空间</strong>中，其生命周期和整个程序相同。独立于所有对象——即使没有对象也存在，能够被访问、赋值。<strong>本质上，静态数据成员是全局变量。</strong></p></li><li class="lvl-3"><p>可以通过对象访问静态数据成员，也可以通过<strong>类名::静态数据成员</strong>的方法去访问。</p></li><li class="lvl-3"><p>静态数据成员可以作为成员函数的默认参数值，其类型可以是所属类的类型（普通数据成员均不可）。</p></li><li class="lvl-3"><p><strong>静态数据成员在常成员函数中可以修改。</strong>（因为this指针指向对象const但静态数据成员不是对象的）</p></li><li class="lvl-3"><p>sizeof运算符计算对象所占用的存储空间时，<strong>不会将静态成员变量计算在内</strong>。类大小=非静态成员数据的类型大小之和。</p></li></ol><h4 id="3-代码实现"><a href="#3-代码实现" class="header-anchor">¶</a>3. 代码实现：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pointcounter;<span class="hljs-comment">//声明</span><br><span class="hljs-built_in">Point</span>()<br>&#123;<br>x = <span class="hljs-number">0</span>;<br>y = <span class="hljs-number">0</span>;<br>pointcounter++;<span class="hljs-comment">//可以使用，不是定义初始化</span><br>&#125;<br><span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>pointcounter++;<span class="hljs-comment">//同上</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br>~<span class="hljs-built_in">Point</span>()<br>&#123;<br>pointcounter--;<span class="hljs-comment">//仍旧存在，不会销毁，可以访问。</span><br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> Point::pointcounter = <span class="hljs-number">0</span>;<span class="hljs-comment">//在此处定义和初始化</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<span class="hljs-comment">//可以观察其变化情况是否独立于对象。</span><br>Point* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>Point* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>Point* p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p1;<br><span class="hljs-keyword">delete</span> p2;<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p3;<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三静态成员函数"><a href="#三静态成员函数" class="header-anchor">¶</a>（三）静态成员函数：</h3><h4 id="1-概念"><a href="#1-概念" class="header-anchor">¶</a>1. 概念：</h4><p>静态成员函数是指用static修饰的成员函数。</p><p>静态成员函数的作用不是为了对象之间的沟通，而是为了能处理静态数据成员。</p><p>形式：<em><strong>static 返回类型 函数名( 参数表) { 函数体 }</strong></em></p><h4 id="2特点"><a href="#2特点" class="header-anchor">¶</a>2.特点：</h4><ol><li class="lvl-3"><p>静态成员函数不属于某一对象，因此静态成员函数<strong>没有this指针</strong>（与成员函数的根本区别），其本质是一个全局函数。</p></li><li class="lvl-3"><p>静态成员函数只能够<strong>访问静态成员变量</strong>，但可以直接引用本类中的静态数据成员，因无this指针，不能够默认访问一个对象中的非静态成员。</p></li><li class="lvl-3"><p>静态成员函数的实现可以在类体内，也可以在类体外。</p></li><li class="lvl-3"><p>静态成员函数的调用可以通过类，也可以通过对象，且<strong>无需对象就可以调用静态成员函数</strong>。</p></li><li class="lvl-3"><p>（附）：静态成员函数不是绝对不能引用非静态成员，只是不能进行默认访问，因为不知道要找哪个对象，如果一定要引用，需要加对象名和成员运算符“.”。（不建议使用）</p></li></ol><h4 id="3代码实现"><a href="#3代码实现" class="header-anchor">¶</a>3.代码实现：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> x, y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pointcounter;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">addpointconuter</span><span class="hljs-params">()</span> <span class="hljs-comment">//类内声明</span></span><br><span class="hljs-function"></span>&#123;<br>pointcounter++;<span class="hljs-comment">//允许对静态数据成员进行操作</span><br><span class="hljs-comment">//x++; //不允许直接调用默认成员。</span><br><span class="hljs-keyword">return</span>;<br>&#125;<span class="hljs-comment">//静态成员函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">delpointconuter</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">Point</span>()<br>&#123;<br>x = <span class="hljs-number">0</span>;<br>y = <span class="hljs-number">0</span>;<br>pointcounter++;<br>&#125;<br><span class="hljs-built_in">Point</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>pointcounter++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = x;<br><span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> y;<br>&#125;<br>~<span class="hljs-built_in">Point</span>()<br>&#123;<br>pointcounter--;<br>&#125;<br>&#125; p;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Point::delpointconuter</span><span class="hljs-params">()</span> <span class="hljs-comment">//类外声明</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;x = <span class="hljs-keyword">this</span>-&gt;y = <span class="hljs-number">0</span>;<span class="hljs-comment">//错误，根本没有this指针。</span><br>p.x = p.y = <span class="hljs-number">0</span>;<br>pointcounter = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> Point::pointcounter = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Point* p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>Point* p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>Point* p3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br>Point::<span class="hljs-built_in">addpointconuter</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br>Point::<span class="hljs-built_in">delpointconuter</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p1;<br><span class="hljs-keyword">delete</span> p2;<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p3;<br>cout &lt;&lt; <span class="hljs-string">&quot;现存点数:&quot;</span> &lt;&lt; Point::pointcounter &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——复制构造函数(含深浅拷贝)</title>
    <link href="/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E5%90%AB%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)/"/>
    <url>/xiaohei07.github.io/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E5%90%AB%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)/</url>
    
    <content type="html"><![CDATA[<h3 id="一引言"><a href="#一引言" class="header-anchor">¶</a>（一）引言:</h3><p>对于普通类型，复制是极其简单的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">int <span class="hljs-attribute">a</span>=1;<br>int <span class="hljs-attribute">b</span>=a;//复制<br>int *<span class="hljs-attribute">p1</span>=&amp;a;<br>int *<span class="hljs-attribute">p2</span>=p1;//复制<br></code></pre></td></tr></table></figure><p>但对于内部含有多个数据成员的类对象，其结构复杂，复制也相对复杂。</p><p>这时就需要调用复制构造函数来完成拷贝过程。</p><h3 id="二概念"><a href="#二概念" class="header-anchor">¶</a>（二）概念:</h3><p>复制构造函数又名拷贝构造函数，是一种特殊的构造函数，它通过编译器调用完成基于同一类的其他对象的构造及初始化。</p><p>其形参是唯一的，且只能是本类的引用，一般情况下会在前面加const引用来保证被复制的类对象在复制过程中不被修改。</p><ul class="lvl-0"><li class="lvl-2"><p>如果形参是值传递，将会发生无穷递归，即被复制的类对象需要先复制出一个临时对象传入复制构造函数，然后临时对象又需要调用复制构造函数产生新的临时对象......</p></li><li class="lvl-2"><p>如果形参是指针传递，能够实现要求，但是会导致歧义。</p></li></ul><p>在类中如果没有显式给出复制构造函数时，则编译器自动给出一个默认复制构造函数。如果有自己定义的构造函数（包括复制构造函数），则按函数重载的规律，调用合适的构造函数。</p><h3 id="三调用时机"><a href="#三调用时机" class="header-anchor">¶</a>（三）调用时机:</h3><ol><li class="lvl-3"><p><strong>对象以值传递的方式传入函数参数。</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include &lt;iostream&gt;<br>using namespace std;<br>class <span class="hljs-built_in">Time</span><br>&#123;<br>priva<span class="hljs-symbol">te:</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-built_in">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sec</span>;<br>publ<span class="hljs-symbol">ic:</span><br><span class="hljs-built_in">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">sec</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-built_in">int</span> <span class="hljs-symbol">i1</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i2</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i3</span>) <span class="hljs-symbol">:ho</span>ur(<span class="hljs-symbol">i1</span>), <span class="hljs-built_in">minute</span>(<span class="hljs-symbol">i2</span>), <span class="hljs-built_in">sec</span>(<span class="hljs-symbol">i3</span>) &#123;&#125;<br><span class="hljs-built_in">Time</span>(const <span class="hljs-built_in">Time</span>&amp; <span class="hljs-built_in">t</span>) <br>&#123;<br><span class="hljs-built_in">hour</span> = t.hour;<br><span class="hljs-built_in">minute</span> = t.minute;<br><span class="hljs-built_in">sec</span> = t.sec;<br>cout &lt;&lt; <span class="hljs-string">&quot;复制构造函数&quot;</span> &lt;&lt; endl;<br>&#125;//复制构造函数<br>void set_time()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; <span class="hljs-built_in">sec</span>;<br>return;<br>&#125;<br>void show_time()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">sec</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br>void test(<span class="hljs-built_in">Time</span> <span class="hljs-built_in">t</span>) <br>&#123;<br>return;<br>&#125;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">Time</span> <span class="hljs-symbol">t1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>test(<span class="hljs-symbol">t1</span>);//发生复制<br><span class="hljs-symbol">t1</span>.show_time();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用test()时，会进行以下步骤：</p><ul class="lvl-2"><li class="lvl-5"><p>Time对象t1传入test形参时，产生临时对象temp。</p></li><li class="lvl-5"><p>调用复制构造函数将t1的值赋值给temp。即有Time temp(t1)发生。</p></li><li class="lvl-5"><p>在test函数本身执行完毕后，将temp析构掉</p></li><li class="lvl-5"><p>temp本质上是test的局部变量，生命周期和test相同。</p></li></ul></li><li class="lvl-3"><p><strong>对象以值传递的方式从函数返回。</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include &lt;iostream&gt;<br>using namespace std;<br>class <span class="hljs-built_in">Time</span><br>&#123;<br>priva<span class="hljs-symbol">te:</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-built_in">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sec</span>;<br>publ<span class="hljs-symbol">ic:</span><br><span class="hljs-built_in">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">sec</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-built_in">int</span> <span class="hljs-symbol">i1</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i2</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i3</span>) <span class="hljs-symbol">:ho</span>ur(<span class="hljs-symbol">i1</span>), <span class="hljs-built_in">minute</span>(<span class="hljs-symbol">i2</span>), <span class="hljs-built_in">sec</span>(<span class="hljs-symbol">i3</span>) &#123;&#125;<br><span class="hljs-built_in">Time</span>(const <span class="hljs-built_in">Time</span>&amp; <span class="hljs-built_in">t</span>) <br>&#123;<br><span class="hljs-built_in">hour</span> = t.hour;<br><span class="hljs-built_in">minute</span> = t.minute;<br><span class="hljs-built_in">sec</span> = t.sec;<br>cout &lt;&lt; <span class="hljs-string">&quot;复制构造函数&quot;</span> &lt;&lt; endl;<br>&#125;//复制构造函数<br>void set_time()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; <span class="hljs-built_in">sec</span>;<br>return;<br>&#125;<br>void show_time()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">sec</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-built_in">Time</span> test(<span class="hljs-built_in">int</span> <span class="hljs-symbol">i1</span>,<span class="hljs-built_in">int</span> <span class="hljs-symbol">i2</span>,<span class="hljs-built_in">int</span> <span class="hljs-symbol">i3</span>) <br>&#123;<br><span class="hljs-built_in">Time</span> <span class="hljs-built_in">t</span>(<span class="hljs-symbol">i1</span>, <span class="hljs-symbol">i2</span>, <span class="hljs-symbol">i3</span>);<br>return <span class="hljs-built_in">t</span>;//发生复制<br>&#125;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">Time</span> <span class="hljs-symbol">t1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-symbol">t1</span> = test(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>);<br><span class="hljs-symbol">t1</span>.show_time();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用test至return时，会进行以下步骤：</p><ul class="lvl-2"><li class="lvl-5"><p>在return处产生临时对象temp。</p></li><li class="lvl-5"><p>调用复制构造函数将test内创建的局部变量t的值赋值给temp。即有Time temp(t)发生。</p></li><li class="lvl-5"><p>在test函数本身执行到最后，将t析构掉</p></li><li class="lvl-5"><p>在test()执行完毕后（此时赋给t1已经结束了），析构temp(因其为临时对象)。</p></li></ul></li><li class="lvl-3"><p><strong>对象需要通过另外一个对象进行初始化。</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include &lt;iostream&gt;<br>using namespace std;<br>class <span class="hljs-built_in">Time</span><br>&#123;<br>priva<span class="hljs-symbol">te:</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-built_in">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sec</span>;<br>publ<span class="hljs-symbol">ic:</span><br><span class="hljs-built_in">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">sec</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-built_in">int</span> <span class="hljs-symbol">i1</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i2</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i3</span>) <span class="hljs-symbol">:ho</span>ur(<span class="hljs-symbol">i1</span>), <span class="hljs-built_in">minute</span>(<span class="hljs-symbol">i2</span>), <span class="hljs-built_in">sec</span>(<span class="hljs-symbol">i3</span>) &#123;&#125;<br><span class="hljs-built_in">Time</span>(const <span class="hljs-built_in">Time</span>&amp; <span class="hljs-built_in">t</span>) <br>&#123;<br><span class="hljs-built_in">hour</span> = t.hour;<br><span class="hljs-built_in">minute</span> = t.minute;<br><span class="hljs-built_in">sec</span> = t.sec;<br>cout &lt;&lt; <span class="hljs-string">&quot;复制构造函数&quot;</span> &lt;&lt; endl;<br>&#125;//复制构造函数<br>void set_time()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; <span class="hljs-built_in">sec</span>;<br>return;<br>&#125;<br>void show_time()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">sec</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">Time</span> <span class="hljs-symbol">t1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">Time</span> <span class="hljs-symbol">t2</span> = <span class="hljs-symbol">t1</span>;//发生复制<br><span class="hljs-symbol">t1</span>.show_time();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li class="lvl-3"><p><strong>当成员变量为类类型时。</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include &lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">year</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> years;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">year</span>() &#123; years = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">year</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">year</span>&amp; y) &#123; cout &lt;&lt; <span class="hljs-string">&quot;year复制构造函数&quot;</span> &lt;&lt; endl; &#125;<span class="hljs-comment">//year的复制构造函数</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-built_in">year</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-title function_">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-title function_">sec</span>(i3) &#123;&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">set_time</span>()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">show_time</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>()<br>&#123;<br>Time <span class="hljs-title function_">t1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>Time t2 = t1;<span class="hljs-comment">//发生复制,且调用的是成员类的复制构造函数。</span><br>t1.<span class="hljs-property">show_time</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为Time的复制构造函数不存在，且其成员类year中存在复制构造函数，所以，此时编译器合成一个Time类的复制构造函数，但是这个合成的复制构造函数的目的是向其中插入能够去调用类year的复制构造函数的代码。</p><p>如需要两个被同时调用，需要自己构造Time的复制构造函数，并且对成员类进行显式赋值。</p><p>代码如下：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs excel">#include &lt;iostream&gt;<br>using namespace std;<br>class <span class="hljs-built_in">year</span><br>&#123;<br>priva<span class="hljs-symbol">te:</span><br><span class="hljs-built_in">int</span> years;<br>publ<span class="hljs-symbol">ic:</span><br><span class="hljs-built_in">year</span>() &#123; years = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">year</span>(const <span class="hljs-built_in">year</span>&amp; y) &#123;cout &lt;&lt; <span class="hljs-string">&quot;year复制构造函数&quot;</span> &lt;&lt; endl;&#125;//<span class="hljs-built_in">year</span>复制构造函数<br>&#125;;<br>class <span class="hljs-built_in">Time</span><br>&#123;<br>priva<span class="hljs-symbol">te:</span><br><span class="hljs-built_in">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-built_in">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">sec</span>;<br><span class="hljs-built_in">year</span> y;<br>publ<span class="hljs-symbol">ic:</span><br><span class="hljs-built_in">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = <span class="hljs-built_in">sec</span> = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-built_in">int</span> <span class="hljs-symbol">i1</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i2</span>, <span class="hljs-built_in">int</span> <span class="hljs-symbol">i3</span>) <span class="hljs-symbol">:ho</span>ur(<span class="hljs-symbol">i1</span>), <span class="hljs-built_in">minute</span>(<span class="hljs-symbol">i2</span>), <span class="hljs-built_in">sec</span>(<span class="hljs-symbol">i3</span>) &#123;&#125;<br><span class="hljs-built_in">Time</span>(const <span class="hljs-built_in">Time</span>&amp; <span class="hljs-built_in">t</span>)<span class="hljs-symbol">:y</span>(t.y)<br>&#123;<br><span class="hljs-built_in">hour</span> = t.hour;<br><span class="hljs-built_in">minute</span> = t.minute;<br><span class="hljs-built_in">sec</span> = t.sec;<br>cout &lt;&lt; <span class="hljs-string">&quot;复制构造函数&quot;</span> &lt;&lt; endl;<br>&#125;//复制构造函数<br>void set_time()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; <span class="hljs-built_in">sec</span>;<br>return;<br>&#125;<br>void show_time()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">sec</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-built_in">int</span> main()<br>&#123;<br><span class="hljs-built_in">Time</span> <span class="hljs-symbol">t1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br><span class="hljs-built_in">Time</span> <span class="hljs-symbol">t2</span> = <span class="hljs-symbol">t1</span>;//发生复制，且调用了各自的复制构造函数<br><span class="hljs-symbol">t1</span>.show_time();<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="四浅拷贝和深拷贝"><a href="#四浅拷贝和深拷贝" class="header-anchor">¶</a>（四）浅拷贝和深拷贝:</h3><ol><li class="lvl-3"><p><strong>默认拷贝构造函数</strong>：</p><p>当我们自己未定义任何复制构造函数时，编译器会为我们自动生成一个默认拷贝构造函数，以保证需要复制对象时不会产生问题。</p><p>但是此函数是使用被复制对象的值对复制对象的数据成员进行赋值，不会复制静态数据成员（实际上不会进行任何操作），需要手动添加。</p></li><li class="lvl-3"><p><strong>浅拷贝</strong>：</p><p>浅拷贝是指对象复制只对对象中的数据成员进行简单赋值（默认构造函数即为浅拷贝）。</p><p>浅拷贝的对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 。如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><p>浅拷贝中，一旦存在动态成员，将会产生大问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;  <br><span class="hljs-type">int</span> minute;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-type">int</span>* p;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>() &#123; hour = minute = sec = <span class="hljs-number">0</span>; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-built_in">sec</span>(i3) &#123; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">5</span>); &#125;<br>~<span class="hljs-built_in">Time</span>() <br>&#123;<br><span class="hljs-keyword">delete</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Time <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br><span class="hljs-function">Time <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;<br>t<span class="hljs-number">2.</span><span class="hljs-built_in">show_time</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行此代码将会发生p指针指向的动态数组发生了多次释放。</p><p>分析此过程：</p><p>因为浅拷贝是将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用。所以，两个不同对象的动态数组指针p地址值其实是相同的，<strong>它们指向的是同一个空间</strong>。</p><p>在销毁对象时，两个对象的析构函数对同一空间进行了两次释放，进而产生了指针悬挂错误。</p><p>我们所需要的是两个动态指针p指向两个不同空间，但是两个空间具有相同的值，而不是两个动态指针p指向同一空间。</p><p>此时需要进行深拷贝。</p></li><li class="lvl-3"><p><strong>深拷贝</strong>：</p><p>深拷贝是指将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p><p>深拷贝创建一个新的对象和数组，重新动态分配空间，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，拷贝的是“值”而不是“引用”。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> hour;  <br><span class="hljs-type">int</span> minute;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-type">int</span>* p;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Time</span>() &#123; hour = minute = sec = <span class="hljs-number">0</span>; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-built_in">sec</span>(i3) &#123; p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>); &#125;<br><span class="hljs-built_in">Time</span>(<span class="hljs-type">const</span> Time&amp; t)<br>&#123;<br>hour = t.hour;<br>minute = t.minute;<br>sec = t.sec;<br>p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*t.p);<br>cout &lt;&lt; <span class="hljs-string">&quot;复制构造函数&quot;</span> &lt;&lt; endl;<br>&#125;<span class="hljs-comment">//复制构造函数</span><br>~<span class="hljs-built_in">Time</span>() <br>&#123;<br><span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span>&lt;&lt;&amp;p &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> p;<br>p = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_time</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Time <span class="hljs-title">t1</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br><span class="hljs-function">Time <span class="hljs-title">t2</span><span class="hljs-params">(t1)</span></span>;<span class="hljs-comment">//发生复制</span><br>t<span class="hljs-number">2.</span><span class="hljs-built_in">show_time</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到两次析构函数析构前的动态指针p指向地址不同，说明两个动态指针p各自指向不同的内存空间，且指向的内容相同，此时即有深拷贝。</p></li><li class="lvl-3"><p><strong>防止浅拷贝发生</strong>：</p><p>声明一个私有复制构造函数，可以不定义，此时如果按值传递或或函数返回该类对象，不会发生浅拷贝错误，可以避免问题。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++类——构造函数</title>
    <link href="/xiaohei07.github.io/2023/03/16/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/xiaohei07.github.io/2023/03/16/c++%E7%B1%BB%E2%80%94%E2%80%94%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一概念"><a href="#一概念" class="header-anchor">¶</a>（一）概念:</h3><p>创建类的对象的时候，编译系统需要对象分配内存空间，完成数据成员的初始化工作并请求其他资源，此时，编译系统自动调用构造函数来完成这些工作。</p><p>因此，构造函数是在创建类的对象时使用，它的核心作用是<strong>初始化对象的数据成员</strong>和<strong>分配内存</strong>。</p><h3 id="二原型和特点"><a href="#二原型和特点" class="header-anchor">¶</a>（二）原型和特点:</h3><p>构造函数的原型为：**<em>类名::<em>类名(<em>参数表</em>):<em>初始化列表 { 构造函数体 }</em></em></em></p><p>​   ——所有倾斜内容表示在构造函数中此内容可选，不是必要的。</p><p>​       ——参数表即为所有的传入形参</p><p>​       ——初始化列表结构为：<em>数据成员名(某形参名),数据成员名(某形参名)...</em></p><p>​    ——构造函数体可执行相关操作可为cout&lt;&lt;某些信息，对数据成员的某些操作等等。</p><p>构造函数的特点：</p><ol><li class="lvl-3"><p>名字<strong>与类名相同</strong>，允许设定参数，但是<strong>不允许设置返回值</strong>(<strong>包括void</strong>)。</p></li><li class="lvl-3"><p>构造函数是编译系统在实例化一个对象时<strong>自动执行</strong>的，不需要手动调用(当然也可以主动手动调用)。调用后会对对象的数据成员进行初始化。</p><p>定义自己的无参构造函数实际上是<strong>有用构造函数</strong></p></li><li class="lvl-3"><p>构造函数<strong>可以重载</strong>，但是对象的实例化只会使用其中的一个构造函数（参数类型和个数能够最佳匹配），且实例化后<strong>不会再次执行</strong>构造函数，另外，重载构造函数后<strong>不允许出现二义性</strong>情况。</p><ul class="lvl-2"><li class="lvl-5"><p>重载构造函数具有不同的参数表和相同的名称</p></li><li class="lvl-5"><p>根据传参个数决定调用哪个构造函数</p></li><li class="lvl-5"><p>创建对象时要传参数让编译器明确知道调用哪个构造函数</p></li></ul></li><li class="lvl-3"><p>在未定义构造函数时，编译系统生成一个<strong>无用的默认构造函数</strong>，无用的默认构造函数不含参数，<strong>不做任何初始化工作</strong>。</p><p>一旦定义了自己的构造函数，系统不会自己生成无用的默认的无参构造函数，但是仍然可以自己指定系统生成无用默认无参构造函数。</p></li></ol><h3 id="三分类"><a href="#三分类" class="header-anchor">¶</a>（三）分类:</h3><ol><li class="lvl-3"><p>默认构造函数，又名缺省构造函数，分为有用和无用两种，是不需要显式指定实参的构造函数——即原型为无参构造函数。</p></li><li class="lvl-3"><p>初始化构造函数——有参数。</p></li><li class="lvl-3"><p>复制(拷贝构造函数(不显式指定时有默认的复制构造函数)。</p></li><li class="lvl-3"><p>转换构造函数</p></li></ol><h3 id="四基本用法"><a href="#四基本用法" class="header-anchor">¶</a>（四）基本用法:</h3><h4 id="1默认构造函数"><a href="#1默认构造函数" class="header-anchor">¶</a>1.默认构造函数：</h4><p>形式：</p><ol><li class="lvl-3"><p><em>“<strong>类名() =default;</strong></em>”的形式或者不存在任何构造函数——指定无用默认构造函数。</p></li><li class="lvl-3"><p>&quot;<em><strong>类名(){ 函数体 }</strong></em>&quot;的形式——指定有用默认构造函数</p></li></ol><p>调用时，因默认构造参数不需要形参，直接声明类的对象即可(<strong>切记不要在后面跟“()”!</strong>)。</p><p>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include &lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">int</span> hour;  <br><span class="hljs-built_in">int</span> minute;<br><span class="hljs-built_in">int</span> sec;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//此时状态为无构造参数，编译系统自动生成无用构造参数</span><br><span class="hljs-comment">//Time() = default; 仅去掉本行注释仍为无用构造参数</span><br><span class="hljs-comment">//Time() &#123;hour=0;minute=0;sec=0;&#125; 仅去掉本行注释为有用构造参数,可对三个数初始化为0</span><br><span class="hljs-comment">//上两行注释不能同时去掉，否则产生二义性。</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set_time</span>()</span><br>&#123;<br>cin &gt;&gt; hour &gt;&gt; minute &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show_time</span>()</span><br>&#123;<br>cout &lt;&lt; hour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>Time t1; <span class="hljs-comment">//不能加&quot;()&quot;</span><br>t1.set_time(); <br>t1.show_time();  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2带参构造函数"><a href="#2带参构造函数" class="header-anchor">¶</a>2.带参构造函数：</h4><p>形式：<strong>类名:构造函数名(参数表):初始化列表 { 构造函数体 }</strong></p><p>如果数据成员中有数组，要在构造函数体中用语句对其进行赋值，<strong>不能用初始化列表</strong>进行初始化。</p><p>以其他类作为数据成员时，需要在初始化列表进行初始化。初始化列表需要<strong>首先调用成员类</strong>的构造函数，再初始化自身的数据成员。</p><p>通常带参构造函数需要重载。</p><p>代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include &lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//Time() = default;</span><br><span class="hljs-title function_">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-title function_">sec</span>(i3) &#123;&#125;<span class="hljs-comment">//初始化列表方法</span><br><span class="hljs-comment">//Time(int i1, int i2, int i3) &#123; hour = i1; minute = i2; sec = i3; &#125;//构造函数体方法</span><br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> h) :<span class="hljs-built_in">hour</span>(h) &#123; <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//重载构造函数1，实际上是转换构造函数</span><br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> m) :<span class="hljs-built_in">hour</span>(h), <span class="hljs-built_in">minute</span>(m) &#123; sec = <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//重载构造函数2</span><br><span class="hljs-comment">//Time(int i1=0,int i2=0,int i3=0) :hour(i1), minute(i2), sec(i3) &#123;&#125;//含默认参数的构造函数，但要注意如果三个数均含默认参数，则会导致与默认构造参数产生二义性，只能保留一个。</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">set_time</span>()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">show_time</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>()<br>&#123;<br>Time <span class="hljs-title function_">t1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-comment">//Time t2;</span><br>    <span class="hljs-comment">//Time t3(1,2);</span><br>    <span class="hljs-comment">//Time t4(1);</span><br>t1.<span class="hljs-property">set_time</span>(); <br>t1.<span class="hljs-property">show_time</span>();  <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3复制拷贝构造函数"><a href="#3复制拷贝构造函数" class="header-anchor">¶</a>3.复制（拷贝）构造函数：</h4><p>此内容较多，单开一篇博客，详见<a href="https://07xiaohei.com/2023/03/17/c++%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0(%E5%90%AB%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D)/">c++类——复制构造函数</a></p><h4 id="4转换构造函数"><a href="#4转换构造函数" class="header-anchor">¶</a>4.转换构造函数：</h4><p>形式：<strong>类名:构造函数名(单一参数):初始化列表 { 构造函数体 }</strong></p><p>转换构造函数用于将其他类型的变量，<strong>隐式</strong>转换为本类对象。</p><p>传入的单一参数不能是本类的const引用，否则为复制构造函数。</p><p>转换构造函数可以与运算符重载配合使用（运算符重载详见c++类——运算符重载）。</p><p>代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include &lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//Time() = default;</span><br><span class="hljs-title function_">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-title function_">sec</span>(i3) &#123;&#125;<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> h) :<span class="hljs-built_in">hour</span>(h) &#123; <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//转换构造函数</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">set_time</span>()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">show_time</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br>Time operator+(<span class="hljs-keyword">const</span> Time&amp; temp) <br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">Time</span>(<span class="hljs-variable">this</span>-&gt;<span class="hljs-built_in">hour</span> + temp.<span class="hljs-property">hour</span>, <span class="hljs-variable">this</span>-&gt;<span class="hljs-built_in">minute</span> + temp.<span class="hljs-property">minute</span>, <span class="hljs-variable">this</span>-&gt;sec + temp.<span class="hljs-property">sec</span>);<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>()<br>&#123;<br>Time t1=<span class="hljs-number">4</span>; <span class="hljs-comment">//此处4先被编译器用转换构造函数隐式转换为Time类的匿名变量，再复制给t1（调用了默认复制函数和转换构造函数）。</span><br>t1.<span class="hljs-property">show_time</span>();<br>t1 = t1 + <span class="hljs-number">5</span>; <span class="hljs-comment">//此处发生的是5先被编译器用转换构造函数隐式转换为Time类的匿名变量，再和t1通过运算符重载的函数进行相加。</span><br>t1.<span class="hljs-property">show_time</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>附：关键字explicit：</p><p>因为隐式类型转换往往会导致工程中出现一些奇奇怪怪的bug，所以，c++中定义了关键字explicit来杜绝转换构造函数的隐式类型转换。</p><p>关键字explicit只能用于修饰转换构造函数(也就是只含一个参数的类构造函数)或参数表中仅有一个没有默认参数的带参构造函数（等效于转换构造函数），其作用是表明该转换构造函数是显式的，而不是隐式的。</p><p>如果想指定默认情况为隐式的声明，可在前面指定关键字implicit。(不常用)</p><p>代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs processing">#include &lt;iostream&gt;<br>using namespace std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> <span class="hljs-built_in">hour</span>;  <br><span class="hljs-type">int</span> <span class="hljs-built_in">minute</span>;<br><span class="hljs-type">int</span> sec;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//Time() = default;</span><br><span class="hljs-title function_">Time</span>() &#123; <span class="hljs-built_in">hour</span> = <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<br><span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> i1, <span class="hljs-type">int</span> i2, <span class="hljs-type">int</span> i3) :<span class="hljs-built_in">hour</span>(i1), <span class="hljs-built_in">minute</span>(i2), <span class="hljs-title function_">sec</span>(i3) &#123;&#125;<br>explicit <span class="hljs-title function_">Time</span>(<span class="hljs-type">int</span> h) :<span class="hljs-built_in">hour</span>(h) &#123; <span class="hljs-built_in">minute</span> = sec = <span class="hljs-number">0</span>; &#125;<span class="hljs-comment">//转换构造函数</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">set_time</span>()<br>&#123;<br>cin &gt;&gt; <span class="hljs-built_in">hour</span> &gt;&gt; <span class="hljs-built_in">minute</span> &gt;&gt; sec;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">show_time</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">hour</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">minute</span> &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; sec &lt;&lt; endl;<br>&#125;<br>Time operator+(<span class="hljs-keyword">const</span> Time&amp; temp) <br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-title function_">Time</span>(<span class="hljs-variable">this</span>-&gt;<span class="hljs-built_in">hour</span> + temp.<span class="hljs-property">hour</span>, <span class="hljs-variable">this</span>-&gt;<span class="hljs-built_in">minute</span> + temp.<span class="hljs-property">minute</span>, <span class="hljs-variable">this</span>-&gt;sec + temp.<span class="hljs-property">sec</span>);<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span>()<br>&#123;<br>Time t1= static_cast&lt;Time&gt;(<span class="hljs-number">4</span>);<span class="hljs-comment">//必须显式指定，不会隐式转换。</span><br><span class="hljs-comment">//t1.set_time(); </span><br>t1.<span class="hljs-property">show_time</span>();<br>t1 = t1 + <span class="hljs-number">5</span>;<span class="hljs-comment">// 不会发生隐式转换，运算符重载函数发生错误。</span><br>t1.<span class="hljs-property">show_time</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“网站简介”</title>
    <link href="/xiaohei07.github.io/2023/03/15/start/"/>
    <url>/xiaohei07.github.io/2023/03/15/start/</url>
    
    <content type="html"><![CDATA[<h4 id="07xiaoheiの博客开始建设啦"><a href="#07xiaoheiの博客开始建设啦" class="header-anchor">¶</a>07xiaoheiの博客开始建设啦！</h4><p>本网站旨在更新：</p><ul class="lvl-0"><li class="lvl-2"><p>python、c++的相关知识点</p></li><li class="lvl-2"><p>机器学习及计算机视觉的内容</p></li><li class="lvl-2"><p>一些使用的数据结构和算法的知识整理和例子</p></li><li class="lvl-2"><p>各类常用的网络资源以及使用的简单教程</p></li><li class="lvl-2"><p>一些日常的bug记录</p></li><li class="lvl-2"><p>其他个人认为值得记录的</p></li></ul><p>我会及时更新的！也请各位有兴趣阅读此网站内容的朋友们对我进行监督！</p><p>希望这个网站能够帮助你们解决你们遇到的问题！</p><p>最后，祝各位平安幸福，身体安康，前程似锦！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++类——this指针</title>
    <link href="/xiaohei07.github.io/2023/03/15/c++%E7%B1%BB%E2%80%94%E2%80%94this%E6%8C%87%E9%92%88/"/>
    <url>/xiaohei07.github.io/2023/03/15/c++%E7%B1%BB%E2%80%94%E2%80%94this%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一引言"><a href="#一引言" class="header-anchor">¶</a>（一）引言:</h3><p>在c++中，我们在类中创建成员函数，在创建类的对象后，在类的对象上使用类的成员函数可以访问类的此对象的数据。</p><p>那么这个成员函数是怎么知道要访问的是此对象的数据成员，而不是其他对象的呢？</p><p>其原因就是每个对象拥有的this指针——每个对象使用成员函数时通过传入自己的this指针来使成员函数能够确定要访问的对象。</p><p>下面对this指针进行详细介绍。</p><h3 id="二概念"><a href="#二概念" class="header-anchor">¶</a>（二）概念:</h3><p>定义：关键字this是指向对象自己的一个<strong>常量指针</strong>，，所以，this指针是不能够被赋值或者改变的。</p><p>this指针是成员函数的隐含形参，换言之，类的对象在正常为成员函数传入参数时，实际上最后还有一个额外的参数位置，参数类型是该类的常量指针，并含有默认值，默认值即为此调用对象的地址，在调用成员函数时，this指针作为实参被传入成员函数。</p><p>this指针本质上是成员函数的局部变量。</p><p>例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Simple</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Simple</span> (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Finish the constructed function&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resetXY</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123;<br>x = a,y = b;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br>~<span class="hljs-built_in">Simple</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Finish deconstructor&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Simple <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>s.<span class="hljs-built_in">resetXY</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//在此处调用时，实际上是调用</span><br> <span class="hljs-comment">//resetXY(2,3,Simple *const this)</span><br> <span class="hljs-comment">//&#123; this-&gt;x=a,this-&gt;y=b;&#125;</span><br> <span class="hljs-comment">//使用了this指针</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三this指针的注意要点"><a href="#三this指针的注意要点" class="header-anchor">¶</a>（三）this指针的注意要点:</h3><ol><li class="lvl-3"><p>作为常量指针，不能给this指针<strong>赋值</strong>。</p></li><li class="lvl-3"><p>this指针的作用域在类成员函数的内部，只能在<strong>成员函数内部</strong>，在类外无法获取。</p></li><li class="lvl-3"><p>this指针的创建：</p><p><strong>this指针在成员函数的开始执行前构造，并在成员函数的执行结束后清除。</strong></p></li><li class="lvl-3"><p>只有<strong>非静态成员函数</strong>才拥有this指针</p><p>​         ——友元函数不是类的成员函数，没有this指针。</p><p>​         ——静态函数不属于某个对象（详见<a href="https://07xiaohei.com/2023/03/17/c-%E7%B1%BB%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/">c++类——静态成员</a>)博客），没有this指针。</p></li><li class="lvl-3"><p>this指针不可以显式声明，但可以显式使用。</p><p>​  ——显式使用是指可以在成员函数内调用this指针，比如使用this地址，(*this).x，this-&gt;x</p><p>​  x为数据成员/某些成员函数。</p></li><li class="lvl-3"><p>this指针不是对象的一部分，其所占的内存大小不会反应在sizeof操作符上。</p></li></ol><h3 id="四this指针的显式使用样例"><a href="#四this指针的显式使用样例" class="header-anchor">¶</a>（四）this指针的显式使用样例:</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> x;<br><span class="hljs-type">int</span> y;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Simple</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Simple</span> (<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Finish the constructed function&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">resetXY</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123;<br>x = a, y = b;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Simple_thisuse</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>(*<span class="hljs-keyword">this</span>).x += a;<br>(*<span class="hljs-keyword">this</span>).y += b;<br>cout &lt;&lt; <span class="hljs-keyword">this</span>-&gt;x &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;y &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-keyword">this</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>~<span class="hljs-built_in">Simple</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Finish deconstructor&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Simple <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>s.<span class="hljs-built_in">resetXY</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>s.<span class="hljs-built_in">Simple_thisuse</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：<a href="https://imgse.com/i/pp8l0u8"><img src="https://s1.ax1x.com/2023/03/16/pp8l0u8.png" alt="pp8l0u8.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>c++_study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
      <tag>类</tag>
      
      <tag>知识点</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
